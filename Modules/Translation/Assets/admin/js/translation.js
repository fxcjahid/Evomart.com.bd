/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./Modules/Translation/node_modules/x-editable/dist/bootstrap3-editable/js/bootstrap-editable.js":
/*!*******************************************************************************************************!*\
  !*** ./Modules/Translation/node_modules/x-editable/dist/bootstrap3-editable/js/bootstrap-editable.js ***!
  \*******************************************************************************************************/
/***/ (() => {

eval("/*! X-editable - v1.5.1 \n* In-place editing with Twitter Bootstrap, jQuery UI or pure jQuery\n* http://github.com/vitalets/x-editable\n* Copyright (c) 2013 Vitaliy Potapov; Licensed MIT */\n/**\nForm with single input element, two buttons and two states: normal/loading.\nApplied as jQuery method to DIV tag (not to form tag!). This is because form can be in loading state when spinner shown.\nEditableform is linked with one of input types, e.g. 'text', 'select' etc.\n\n@class editableform\n@uses text\n@uses textarea\n**/\n(function ($) {\n    \"use strict\";\n    \n    var EditableForm = function (div, options) {\n        this.options = $.extend({}, $.fn.editableform.defaults, options);\n        this.$div = $(div); //div, containing form. Not form tag. Not editable-element.\n        if(!this.options.scope) {\n            this.options.scope = this;\n        }\n        //nothing shown after init\n    };\n\n    EditableForm.prototype = {\n        constructor: EditableForm,\n        initInput: function() {  //called once\n            //take input from options (as it is created in editable-element)\n            this.input = this.options.input;\n            \n            //set initial value\n            //todo: may be add check: typeof str === 'string' ? \n            this.value = this.input.str2value(this.options.value); \n            \n            //prerender: get input.$input\n            this.input.prerender();\n        },\n        initTemplate: function() {\n            this.$form = $($.fn.editableform.template); \n        },\n        initButtons: function() {\n            var $btn = this.$form.find('.editable-buttons');\n            $btn.append($.fn.editableform.buttons);\n            if(this.options.showbuttons === 'bottom') {\n                $btn.addClass('editable-buttons-bottom');\n            }\n        },\n        /**\n        Renders editableform\n\n        @method render\n        **/        \n        render: function() {\n            //init loader\n            this.$loading = $($.fn.editableform.loading);        \n            this.$div.empty().append(this.$loading);\n            \n            //init form template and buttons\n            this.initTemplate();\n            if(this.options.showbuttons) {\n                this.initButtons();\n            } else {\n                this.$form.find('.editable-buttons').remove();\n            }\n\n            //show loading state\n            this.showLoading();            \n            \n            //flag showing is form now saving value to server. \n            //It is needed to wait when closing form.\n            this.isSaving = false;\n            \n            /**        \n            Fired when rendering starts\n            @event rendering \n            @param {Object} event event object\n            **/            \n            this.$div.triggerHandler('rendering');\n            \n            //init input\n            this.initInput();\n            \n            //append input to form\n            this.$form.find('div.editable-input').append(this.input.$tpl);            \n            \n            //append form to container\n            this.$div.append(this.$form);\n            \n            //render input\n            $.when(this.input.render())\n            .then($.proxy(function () {\n                //setup input to submit automatically when no buttons shown\n                if(!this.options.showbuttons) {\n                    this.input.autosubmit(); \n                }\n                 \n                //attach 'cancel' handler\n                this.$form.find('.editable-cancel').click($.proxy(this.cancel, this));\n                \n                if(this.input.error) {\n                    this.error(this.input.error);\n                    this.$form.find('.editable-submit').attr('disabled', true);\n                    this.input.$input.attr('disabled', true);\n                    //prevent form from submitting\n                    this.$form.submit(function(e){ e.preventDefault(); });\n                } else {\n                    this.error(false);\n                    this.input.$input.removeAttr('disabled');\n                    this.$form.find('.editable-submit').removeAttr('disabled');\n                    var value = (this.value === null || this.value === undefined || this.value === '') ? this.options.defaultValue : this.value;\n                    this.input.value2input(value);\n                    //attach submit handler\n                    this.$form.submit($.proxy(this.submit, this));\n                }\n\n                /**        \n                Fired when form is rendered\n                @event rendered\n                @param {Object} event event object\n                **/            \n                this.$div.triggerHandler('rendered');                \n\n                this.showForm();\n                \n                //call postrender method to perform actions required visibility of form\n                if(this.input.postrender) {\n                    this.input.postrender();\n                }                \n            }, this));\n        },\n        cancel: function() {   \n            /**        \n            Fired when form was cancelled by user\n            @event cancel \n            @param {Object} event event object\n            **/              \n            this.$div.triggerHandler('cancel');\n        },\n        showLoading: function() {\n            var w, h;\n            if(this.$form) {\n                //set loading size equal to form\n                w = this.$form.outerWidth();\n                h = this.$form.outerHeight(); \n                if(w) {\n                    this.$loading.width(w);\n                }\n                if(h) {\n                    this.$loading.height(h);\n                }\n                this.$form.hide();\n            } else {\n                //stretch loading to fill container width\n                w = this.$loading.parent().width();\n                if(w) {\n                    this.$loading.width(w);\n                }\n            }\n            this.$loading.show(); \n        },\n\n        showForm: function(activate) {\n            this.$loading.hide();\n            this.$form.show();\n            if(activate !== false) {\n                this.input.activate(); \n            }\n            /**        \n            Fired when form is shown\n            @event show \n            @param {Object} event event object\n            **/                    \n            this.$div.triggerHandler('show');\n        },\n\n        error: function(msg) {\n            var $group = this.$form.find('.control-group'),\n                $block = this.$form.find('.editable-error-block'),\n                lines;\n\n            if(msg === false) {\n                $group.removeClass($.fn.editableform.errorGroupClass);\n                $block.removeClass($.fn.editableform.errorBlockClass).empty().hide(); \n            } else {\n                //convert newline to <br> for more pretty error display\n                if(msg) {\n                    lines = (''+msg).split('\\n');\n                    for (var i = 0; i < lines.length; i++) {\n                        lines[i] = $('<div>').text(lines[i]).html();\n                    }\n                    msg = lines.join('<br>');\n                }\n                $group.addClass($.fn.editableform.errorGroupClass);\n                $block.addClass($.fn.editableform.errorBlockClass).html(msg).show();\n            }\n        },\n\n        submit: function(e) {\n            e.stopPropagation();\n            e.preventDefault();\n            \n            //get new value from input\n            var newValue = this.input.input2value(); \n\n            //validation: if validate returns string or truthy value - means error\n            //if returns object like {newValue: '...'} => submitted value is reassigned to it\n            var error = this.validate(newValue);\n            if ($.type(error) === 'object' && error.newValue !== undefined) {\n                newValue = error.newValue;\n                this.input.value2input(newValue);\n                if(typeof error.msg === 'string') {\n                    this.error(error.msg);\n                    this.showForm();\n                    return;\n                }\n            } else if (error) {\n                this.error(error);\n                this.showForm();\n                return;\n            } \n            \n            //if value not changed --> trigger 'nochange' event and return\n            /*jslint eqeq: true*/\n            if (!this.options.savenochange && this.input.value2str(newValue) == this.input.value2str(this.value)) {\n            /*jslint eqeq: false*/                \n                /**        \n                Fired when value not changed but form is submitted. Requires savenochange = false.\n                @event nochange \n                @param {Object} event event object\n                **/                    \n                this.$div.triggerHandler('nochange');            \n                return;\n            } \n\n            //convert value for submitting to server\n            var submitValue = this.input.value2submit(newValue);\n            \n            this.isSaving = true;\n            \n            //sending data to server\n            $.when(this.save(submitValue))\n            .done($.proxy(function(response) {\n                this.isSaving = false;\n\n                //run success callback\n                var res = typeof this.options.success === 'function' ? this.options.success.call(this.options.scope, response, newValue) : null;\n\n                //if success callback returns false --> keep form open and do not activate input\n                if(res === false) {\n                    this.error(false);\n                    this.showForm(false);\n                    return;\n                }\n\n                //if success callback returns string -->  keep form open, show error and activate input               \n                if(typeof res === 'string') {\n                    this.error(res);\n                    this.showForm();\n                    return;\n                }\n\n                //if success callback returns object like {newValue: <something>} --> use that value instead of submitted\n                //it is usefull if you want to chnage value in url-function\n                if(res && typeof res === 'object' && res.hasOwnProperty('newValue')) {\n                    newValue = res.newValue;\n                }\n\n                //clear error message\n                this.error(false);   \n                this.value = newValue;\n                /**        \n                Fired when form is submitted\n                @event save \n                @param {Object} event event object\n                @param {Object} params additional params\n                @param {mixed} params.newValue raw new value\n                @param {mixed} params.submitValue submitted value as string\n                @param {Object} params.response ajax response\n\n                @example\n                $('#form-div').on('save'), function(e, params){\n                    if(params.newValue === 'username') {...}\n                });\n                **/\n                this.$div.triggerHandler('save', {newValue: newValue, submitValue: submitValue, response: response});\n            }, this))\n            .fail($.proxy(function(xhr) {\n                this.isSaving = false;\n\n                var msg;\n                if(typeof this.options.error === 'function') {\n                    msg = this.options.error.call(this.options.scope, xhr, newValue);\n                } else {\n                    msg = typeof xhr === 'string' ? xhr : xhr.responseText || xhr.statusText || 'Unknown error!';\n                }\n\n                this.error(msg);\n                this.showForm();\n            }, this));\n        },\n\n        save: function(submitValue) {\n            //try parse composite pk defined as json string in data-pk \n            this.options.pk = $.fn.editableutils.tryParseJson(this.options.pk, true); \n            \n            var pk = (typeof this.options.pk === 'function') ? this.options.pk.call(this.options.scope) : this.options.pk,\n            /*\n              send on server in following cases:\n              1. url is function\n              2. url is string AND (pk defined OR send option = always) \n            */\n            send = !!(typeof this.options.url === 'function' || (this.options.url && ((this.options.send === 'always') || (this.options.send === 'auto' && pk !== null && pk !== undefined)))),\n            params;\n\n            if (send) { //send to server\n                this.showLoading();\n\n                //standard params\n                params = {\n                    name: this.options.name || '',\n                    value: submitValue,\n                    pk: pk \n                };\n\n                //additional params\n                if(typeof this.options.params === 'function') {\n                    params = this.options.params.call(this.options.scope, params);  \n                } else {\n                    //try parse json in single quotes (from data-params attribute)\n                    this.options.params = $.fn.editableutils.tryParseJson(this.options.params, true);   \n                    $.extend(params, this.options.params);\n                }\n\n                if(typeof this.options.url === 'function') { //user's function\n                    return this.options.url.call(this.options.scope, params);\n                } else {  \n                    //send ajax to server and return deferred object\n                    return $.ajax($.extend({\n                        url     : this.options.url,\n                        data    : params,\n                        type    : 'POST'\n                    }, this.options.ajaxOptions));\n                }\n            }\n        }, \n\n        validate: function (value) {\n            if (value === undefined) {\n                value = this.value;\n            }\n            if (typeof this.options.validate === 'function') {\n                return this.options.validate.call(this.options.scope, value);\n            }\n        },\n\n        option: function(key, value) {\n            if(key in this.options) {\n                this.options[key] = value;\n            }\n            \n            if(key === 'value') {\n                this.setValue(value);\n            }\n            \n            //do not pass option to input as it is passed in editable-element\n        },\n\n        setValue: function(value, convertStr) {\n            if(convertStr) {\n                this.value = this.input.str2value(value);\n            } else {\n                this.value = value;\n            }\n            \n            //if form is visible, update input\n            if(this.$form && this.$form.is(':visible')) {\n                this.input.value2input(this.value);\n            }            \n        }               \n    };\n\n    /*\n    Initialize editableform. Applied to jQuery object.\n\n    @method $().editableform(options)\n    @params {Object} options\n    @example\n    var $form = $('&lt;div&gt;').editableform({\n        type: 'text',\n        name: 'username',\n        url: '/post',\n        value: 'vitaliy'\n    });\n\n    //to display form you should call 'render' method\n    $form.editableform('render');     \n    */\n    $.fn.editableform = function (option) {\n        var args = arguments;\n        return this.each(function () {\n            var $this = $(this), \n            data = $this.data('editableform'), \n            options = typeof option === 'object' && option; \n            if (!data) {\n                $this.data('editableform', (data = new EditableForm(this, options)));\n            }\n\n            if (typeof option === 'string') { //call method \n                data[option].apply(data, Array.prototype.slice.call(args, 1));\n            } \n        });\n    };\n\n    //keep link to constructor to allow inheritance\n    $.fn.editableform.Constructor = EditableForm;    \n\n    //defaults\n    $.fn.editableform.defaults = {\n        /* see also defaults for input */\n\n        /**\n        Type of input. Can be <code>text|textarea|select|date|checklist</code>\n\n        @property type \n        @type string\n        @default 'text'\n        **/\n        type: 'text',\n        /**\n        Url for submit, e.g. <code>'/post'</code>  \n        If function - it will be called instead of ajax. Function should return deferred object to run fail/done callbacks.\n\n        @property url \n        @type string|function\n        @default null\n        @example\n        url: function(params) {\n            var d = new $.Deferred;\n            if(params.value === 'abc') {\n                return d.reject('error message'); //returning error via deferred object\n            } else {\n                //async saving data in js model\n                someModel.asyncSaveMethod({\n                   ..., \n                   success: function(){\n                      d.resolve();\n                   }\n                }); \n                return d.promise();\n            }\n        } \n        **/        \n        url:null,\n        /**\n        Additional params for submit. If defined as <code>object</code> - it is **appended** to original ajax data (pk, name and value).  \n        If defined as <code>function</code> - returned object **overwrites** original ajax data.\n        @example\n        params: function(params) {\n            //originally params contain pk, name and value\n            params.a = 1;\n            return params;\n        }\n\n        @property params \n        @type object|function\n        @default null\n        **/          \n        params:null,\n        /**\n        Name of field. Will be submitted on server. Can be taken from <code>id</code> attribute\n\n        @property name \n        @type string\n        @default null\n        **/         \n        name: null,\n        /**\n        Primary key of editable object (e.g. record id in database). For composite keys use object, e.g. <code>{id: 1, lang: 'en'}</code>.\n        Can be calculated dynamically via function.\n\n        @property pk \n        @type string|object|function\n        @default null\n        **/         \n        pk: null,\n        /**\n        Initial value. If not defined - will be taken from element's content.\n        For __select__ type should be defined (as it is ID of shown text).\n\n        @property value \n        @type string|object\n        @default null\n        **/        \n        value: null,\n        /**\n        Value that will be displayed in input if original field value is empty (`null|undefined|''`).\n\n        @property defaultValue \n        @type string|object\n        @default null\n        @since 1.4.6\n        **/        \n        defaultValue: null,\n        /**\n        Strategy for sending data on server. Can be `auto|always|never`.\n        When 'auto' data will be sent on server **only if pk and url defined**, otherwise new value will be stored locally.\n\n        @property send \n        @type string\n        @default 'auto'\n        **/          \n        send: 'auto', \n        /**\n        Function for client-side validation. If returns string - means validation not passed and string showed as error.\n        Since 1.5.1 you can modify submitted value by returning object from `validate`: \n        `{newValue: '...'}` or `{newValue: '...', msg: '...'}`\n\n        @property validate \n        @type function\n        @default null\n        @example\n        validate: function(value) {\n            if($.trim(value) == '') {\n                return 'This field is required';\n            }\n        }\n        **/         \n        validate: null,\n        /**\n        Success callback. Called when value successfully sent on server and **response status = 200**.  \n        Usefull to work with json response. For example, if your backend response can be <code>{success: true}</code>\n        or <code>{success: false, msg: \"server error\"}</code> you can check it inside this callback.  \n        If it returns **string** - means error occured and string is shown as error message.  \n        If it returns **object like** <code>{newValue: &lt;something&gt;}</code> - it overwrites value, submitted by user.  \n        Otherwise newValue simply rendered into element.\n        \n        @property success \n        @type function\n        @default null\n        @example\n        success: function(response, newValue) {\n            if(!response.success) return response.msg;\n        }\n        **/          \n        success: null,\n        /**\n        Error callback. Called when request failed (response status != 200).  \n        Usefull when you want to parse error response and display a custom message.\n        Must return **string** - the message to be displayed in the error block.\n                \n        @property error \n        @type function\n        @default null\n        @since 1.4.4\n        @example\n        error: function(response, newValue) {\n            if(response.status === 500) {\n                return 'Service unavailable. Please try later.';\n            } else {\n                return response.responseText;\n            }\n        }\n        **/          \n        error: null,\n        /**\n        Additional options for submit ajax request.\n        List of values: http://api.jquery.com/jQuery.ajax\n        \n        @property ajaxOptions \n        @type object\n        @default null\n        @since 1.1.1        \n        @example \n        ajaxOptions: {\n            type: 'put',\n            dataType: 'json'\n        }        \n        **/        \n        ajaxOptions: null,\n        /**\n        Where to show buttons: left(true)|bottom|false  \n        Form without buttons is auto-submitted.\n\n        @property showbuttons \n        @type boolean|string\n        @default true\n        @since 1.1.1\n        **/         \n        showbuttons: true,\n        /**\n        Scope for callback methods (success, validate).  \n        If <code>null</code> means editableform instance itself. \n\n        @property scope \n        @type DOMElement|object\n        @default null\n        @since 1.2.0\n        @private\n        **/            \n        scope: null,\n        /**\n        Whether to save or cancel value when it was not changed but form was submitted\n\n        @property savenochange \n        @type boolean\n        @default false\n        @since 1.2.0\n        **/\n        savenochange: false\n    };   \n\n    /*\n    Note: following params could redefined in engine: bootstrap or jqueryui:\n    Classes 'control-group' and 'editable-error-block' must always present!\n    */      \n    $.fn.editableform.template = '<form class=\"form-inline editableform\">'+\n    '<div class=\"control-group\">' + \n    '<div><div class=\"editable-input\"></div><div class=\"editable-buttons\"></div></div>'+\n    '<div class=\"editable-error-block\"></div>' + \n    '</div>' + \n    '</form>';\n\n    //loading div\n    $.fn.editableform.loading = '<div class=\"editableform-loading\"></div>';\n\n    //buttons\n    $.fn.editableform.buttons = '<button type=\"submit\" class=\"editable-submit\">ok</button>'+\n    '<button type=\"button\" class=\"editable-cancel\">cancel</button>';      \n\n    //error class attached to control-group\n    $.fn.editableform.errorGroupClass = null;  \n\n    //error class attached to editable-error-block\n    $.fn.editableform.errorBlockClass = 'editable-error';\n    \n    //engine\n    $.fn.editableform.engine = 'jquery';\n}(window.jQuery));\n\n/**\n* EditableForm utilites\n*/\n(function ($) {\n    \"use strict\";\n    \n    //utils\n    $.fn.editableutils = {\n        /**\n        * classic JS inheritance function\n        */  \n        inherit: function (Child, Parent) {\n            var F = function() { };\n            F.prototype = Parent.prototype;\n            Child.prototype = new F();\n            Child.prototype.constructor = Child;\n            Child.superclass = Parent.prototype;\n        },\n\n        /**\n        * set caret position in input\n        * see http://stackoverflow.com/questions/499126/jquery-set-cursor-position-in-text-area\n        */        \n        setCursorPosition: function(elem, pos) {\n            if (elem.setSelectionRange) {\n                elem.setSelectionRange(pos, pos);\n            } else if (elem.createTextRange) {\n                var range = elem.createTextRange();\n                range.collapse(true);\n                range.moveEnd('character', pos);\n                range.moveStart('character', pos);\n                range.select();\n            }\n        },\n\n        /**\n        * function to parse JSON in *single* quotes. (jquery automatically parse only double quotes)\n        * That allows such code as: <a data-source=\"{'a': 'b', 'c': 'd'}\">\n        * safe = true --> means no exception will be thrown\n        * for details see http://stackoverflow.com/questions/7410348/how-to-set-json-format-to-html5-data-attributes-in-the-jquery\n        */\n        tryParseJson: function(s, safe) {\n            if (typeof s === 'string' && s.length && s.match(/^[\\{\\[].*[\\}\\]]$/)) {\n                if (safe) {\n                    try {\n                        /*jslint evil: true*/\n                        s = (new Function('return ' + s))();\n                        /*jslint evil: false*/\n                    } catch (e) {} finally {\n                        return s;\n                    }\n                } else {\n                    /*jslint evil: true*/\n                    s = (new Function('return ' + s))();\n                    /*jslint evil: false*/\n                }\n            }\n            return s;\n        },\n\n        /**\n        * slice object by specified keys\n        */\n        sliceObj: function(obj, keys, caseSensitive /* default: false */) {\n            var key, keyLower, newObj = {};\n\n            if (!$.isArray(keys) || !keys.length) {\n                return newObj;\n            }\n\n            for (var i = 0; i < keys.length; i++) {\n                key = keys[i];\n                if (obj.hasOwnProperty(key)) {\n                    newObj[key] = obj[key];\n                }\n\n                if(caseSensitive === true) {\n                    continue;\n                }\n\n                //when getting data-* attributes via $.data() it's converted to lowercase.\n                //details: http://stackoverflow.com/questions/7602565/using-data-attributes-with-jquery\n                //workaround is code below.\n                keyLower = key.toLowerCase();\n                if (obj.hasOwnProperty(keyLower)) {\n                    newObj[key] = obj[keyLower];\n                }\n            }\n\n            return newObj;\n        },\n\n        /*\n        exclude complex objects from $.data() before pass to config\n        */\n        getConfigData: function($element) {\n            var data = {};\n            $.each($element.data(), function(k, v) {\n                if(typeof v !== 'object' || (v && typeof v === 'object' && (v.constructor === Object || v.constructor === Array))) {\n                    data[k] = v;\n                }\n            });\n            return data;\n        },\n\n        /*\n         returns keys of object\n        */\n        objectKeys: function(o) {\n            if (Object.keys) {\n                return Object.keys(o);  \n            } else {\n                if (o !== Object(o)) {\n                    throw new TypeError('Object.keys called on a non-object');\n                }\n                var k=[], p;\n                for (p in o) {\n                    if (Object.prototype.hasOwnProperty.call(o,p)) {\n                        k.push(p);\n                    }\n                }\n                return k;\n            }\n\n        },\n        \n       /**\n        method to escape html.\n       **/\n       escape: function(str) {\n           return $('<div>').text(str).html();\n       },\n       \n       /*\n        returns array items from sourceData having value property equal or inArray of 'value'\n       */\n       itemsByValue: function(value, sourceData, valueProp) {\n           if(!sourceData || value === null) {\n               return [];\n           }\n           \n           if (typeof(valueProp) !== \"function\") {\n               var idKey = valueProp || 'value';\n               valueProp = function (e) { return e[idKey]; };\n           }\n                      \n           var isValArray = $.isArray(value),\n           result = [], \n           that = this;\n\n           $.each(sourceData, function(i, o) {\n               if(o.children) {\n                   result = result.concat(that.itemsByValue(value, o.children, valueProp));\n               } else {\n                   /*jslint eqeq: true*/\n                   if(isValArray) {\n                       if($.grep(value, function(v){  return v == (o && typeof o === 'object' ? valueProp(o) : o); }).length) {\n                           result.push(o); \n                       }\n                   } else {\n                       var itemValue = (o && (typeof o === 'object')) ? valueProp(o) : o;\n                       if(value == itemValue) {\n                           result.push(o); \n                       }\n                   }\n                   /*jslint eqeq: false*/\n               }\n           });\n           \n           return result;\n       },\n       \n       /*\n       Returns input by options: type, mode. \n       */\n       createInput: function(options) {\n           var TypeConstructor, typeOptions, input,\n           type = options.type;\n\n           //`date` is some kind of virtual type that is transformed to one of exact types\n           //depending on mode and core lib\n           if(type === 'date') {\n               //inline\n               if(options.mode === 'inline') {\n                   if($.fn.editabletypes.datefield) {\n                       type = 'datefield';\n                   } else if($.fn.editabletypes.dateuifield) {\n                       type = 'dateuifield';\n                   }\n               //popup\n               } else {\n                   if($.fn.editabletypes.date) {\n                       type = 'date';\n                   } else if($.fn.editabletypes.dateui) {\n                       type = 'dateui';\n                   }\n               }\n               \n               //if type still `date` and not exist in types, replace with `combodate` that is base input\n               if(type === 'date' && !$.fn.editabletypes.date) {\n                   type = 'combodate';\n               } \n           }\n           \n           //`datetime` should be datetimefield in 'inline' mode\n           if(type === 'datetime' && options.mode === 'inline') {\n             type = 'datetimefield';  \n           }           \n\n           //change wysihtml5 to textarea for jquery UI and plain versions\n           if(type === 'wysihtml5' && !$.fn.editabletypes[type]) {\n               type = 'textarea';\n           }\n\n           //create input of specified type. Input will be used for converting value, not in form\n           if(typeof $.fn.editabletypes[type] === 'function') {\n               TypeConstructor = $.fn.editabletypes[type];\n               typeOptions = this.sliceObj(options, this.objectKeys(TypeConstructor.defaults));\n               input = new TypeConstructor(typeOptions);\n               return input;\n           } else {\n               $.error('Unknown type: '+ type);\n               return false; \n           }  \n       },\n       \n       //see http://stackoverflow.com/questions/7264899/detect-css-transitions-using-javascript-and-without-modernizr\n       supportsTransitions: function () {\n           var b = document.body || document.documentElement,\n               s = b.style,\n               p = 'transition',\n               v = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];\n               \n           if(typeof s[p] === 'string') {\n               return true; \n           }\n\n           // Tests for vendor specific prop\n           p = p.charAt(0).toUpperCase() + p.substr(1);\n           for(var i=0; i<v.length; i++) {\n               if(typeof s[v[i] + p] === 'string') { \n                   return true; \n               }\n           }\n           return false;\n       }            \n       \n    };      \n}(window.jQuery));\n\n/**\nAttaches stand-alone container with editable-form to HTML element. Element is used only for positioning, value is not stored anywhere.<br>\nThis method applied internally in <code>$().editable()</code>. You should subscribe on it's events (save / cancel) to get profit of it.<br>\nFinal realization can be different: bootstrap-popover, jqueryui-tooltip, poshytip, inline-div. It depends on which js file you include.<br>\nApplied as jQuery method.\n\n@class editableContainer\n@uses editableform\n**/\n(function ($) {\n    \"use strict\";\n\n    var Popup = function (element, options) {\n        this.init(element, options);\n    };\n    \n    var Inline = function (element, options) {\n        this.init(element, options);\n    };    \n\n    //methods\n    Popup.prototype = {\n        containerName: null, //method to call container on element\n        containerDataName: null, //object name in element's .data()\n        innerCss: null, //tbd in child class\n        containerClass: 'editable-container editable-popup', //css class applied to container element\n        defaults: {}, //container itself defaults\n        \n        init: function(element, options) {\n            this.$element = $(element);\n            //since 1.4.1 container do not use data-* directly as they already merged into options.\n            this.options = $.extend({}, $.fn.editableContainer.defaults, options);         \n            this.splitOptions();\n            \n            //set scope of form callbacks to element\n            this.formOptions.scope = this.$element[0]; \n            \n            this.initContainer();\n            \n            //flag to hide container, when saving value will finish\n            this.delayedHide = false;\n\n            //bind 'destroyed' listener to destroy container when element is removed from dom\n            this.$element.on('destroyed', $.proxy(function(){\n                this.destroy();\n            }, this)); \n            \n            //attach document handler to close containers on click / escape\n            if(!$(document).data('editable-handlers-attached')) {\n                //close all on escape\n                $(document).on('keyup.editable', function (e) {\n                    if (e.which === 27) {\n                        $('.editable-open').editableContainer('hide');\n                        //todo: return focus on element \n                    }\n                });\n\n                //close containers when click outside \n                //(mousedown could be better than click, it closes everything also on drag drop)\n                $(document).on('click.editable', function(e) {\n                    var $target = $(e.target), i,\n                        exclude_classes = ['.editable-container', \n                                           '.ui-datepicker-header', \n                                           '.datepicker', //in inline mode datepicker is rendered into body\n                                           '.modal-backdrop', \n                                           '.bootstrap-wysihtml5-insert-image-modal', \n                                           '.bootstrap-wysihtml5-insert-link-modal'\n                                           ];\n                    \n                    //check if element is detached. It occurs when clicking in bootstrap datepicker\n                    if (!$.contains(document.documentElement, e.target)) {\n                      return;\n                    }\n\n                    //for some reason FF 20 generates extra event (click) in select2 widget with e.target = document\n                    //we need to filter it via construction below. See https://github.com/vitalets/x-editable/issues/199\n                    //Possibly related to http://stackoverflow.com/questions/10119793/why-does-firefox-react-differently-from-webkit-and-ie-to-click-event-on-selec\n                    if($target.is(document)) {\n                       return; \n                    }\n                    \n                    //if click inside one of exclude classes --> no nothing\n                    for(i=0; i<exclude_classes.length; i++) {\n                         if($target.is(exclude_classes[i]) || $target.parents(exclude_classes[i]).length) {\n                             return;\n                         }\n                    }\n                      \n                    //close all open containers (except one - target)\n                    Popup.prototype.closeOthers(e.target);\n                });\n                \n                $(document).data('editable-handlers-attached', true);\n            }                        \n        },\n\n        //split options on containerOptions and formOptions\n        splitOptions: function() {\n            this.containerOptions = {};\n            this.formOptions = {};\n            \n            if(!$.fn[this.containerName]) {\n                throw new Error(this.containerName + ' not found. Have you included corresponding js file?');   \n            }\n            \n            //keys defined in container defaults go to container, others go to form\n            for(var k in this.options) {\n              if(k in this.defaults) {\n                 this.containerOptions[k] = this.options[k];\n              } else {\n                 this.formOptions[k] = this.options[k];\n              } \n            }\n        },\n        \n        /*\n        Returns jquery object of container\n        @method tip()\n        */         \n        tip: function() {\n            return this.container() ? this.container().$tip : null;\n        },\n\n        /* returns container object */\n        container: function() {\n            var container;\n            //first, try get it by `containerDataName`\n            if(this.containerDataName) {\n                if(container = this.$element.data(this.containerDataName)) {\n                    return container;\n                }\n            }\n            //second, try `containerName`\n            container = this.$element.data(this.containerName);\n            return container;\n        },\n\n        /* call native method of underlying container, e.g. this.$element.popover('method') */ \n        call: function() {\n            this.$element[this.containerName].apply(this.$element, arguments); \n        },        \n        \n        initContainer: function(){\n            this.call(this.containerOptions);\n        },\n\n        renderForm: function() {\n            this.$form\n            .editableform(this.formOptions)\n            .on({\n                save: $.proxy(this.save, this), //click on submit button (value changed)\n                nochange: $.proxy(function(){ this.hide('nochange'); }, this), //click on submit button (value NOT changed)                \n                cancel: $.proxy(function(){ this.hide('cancel'); }, this), //click on calcel button\n                show: $.proxy(function() {\n                    if(this.delayedHide) {\n                        this.hide(this.delayedHide.reason);\n                        this.delayedHide = false;\n                    } else {\n                        this.setPosition();\n                    }\n                }, this), //re-position container every time form is shown (occurs each time after loading state)\n                rendering: $.proxy(this.setPosition, this), //this allows to place container correctly when loading shown\n                resize: $.proxy(this.setPosition, this), //this allows to re-position container when form size is changed \n                rendered: $.proxy(function(){\n                    /**        \n                    Fired when container is shown and form is rendered (for select will wait for loading dropdown options).  \n                    **Note:** Bootstrap popover has own `shown` event that now cannot be separated from x-editable's one.\n                    The workaround is to check `arguments.length` that is always `2` for x-editable.                     \n                    \n                    @event shown \n                    @param {Object} event event object\n                    @example\n                    $('#username').on('shown', function(e, editable) {\n                        editable.input.$input.val('overwriting value of input..');\n                    });                     \n                    **/                      \n                    /*\n                     TODO: added second param mainly to distinguish from bootstrap's shown event. It's a hotfix that will be solved in future versions via namespaced events.  \n                    */\n                    this.$element.triggerHandler('shown', $(this.options.scope).data('editable')); \n                }, this) \n            })\n            .editableform('render');\n        },        \n\n        /**\n        Shows container with form\n        @method show()\n        @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.\n        **/\n        /* Note: poshytip owerwrites this method totally! */          \n        show: function (closeAll) {\n            this.$element.addClass('editable-open');\n            if(closeAll !== false) {\n                //close all open containers (except this)\n                this.closeOthers(this.$element[0]);  \n            }\n            \n            //show container itself\n            this.innerShow();\n            this.tip().addClass(this.containerClass);\n\n            /*\n            Currently, form is re-rendered on every show. \n            The main reason is that we dont know, what will container do with content when closed:\n            remove(), detach() or just hide() - it depends on container.\n            \n            Detaching form itself before hide and re-insert before show is good solution, \n            but visually it looks ugly --> container changes size before hide.  \n            */             \n            \n            //if form already exist - delete previous data \n            if(this.$form) {\n                //todo: destroy prev data!\n                //this.$form.destroy();\n            }\n\n            this.$form = $('<div>');\n            \n            //insert form into container body\n            if(this.tip().is(this.innerCss)) {\n                //for inline container\n                this.tip().append(this.$form); \n            } else {\n                this.tip().find(this.innerCss).append(this.$form);\n            } \n            \n            //render form\n            this.renderForm();\n        },\n\n        /**\n        Hides container with form\n        @method hide()\n        @param {string} reason Reason caused hiding. Can be <code>save|cancel|onblur|nochange|undefined (=manual)</code>\n        **/         \n        hide: function(reason) {  \n            if(!this.tip() || !this.tip().is(':visible') || !this.$element.hasClass('editable-open')) {\n                return;\n            }\n            \n            //if form is saving value, schedule hide\n            if(this.$form.data('editableform').isSaving) {\n                this.delayedHide = {reason: reason};\n                return;    \n            } else {\n                this.delayedHide = false;\n            }\n\n            this.$element.removeClass('editable-open');   \n            this.innerHide();\n\n            /**\n            Fired when container was hidden. It occurs on both save or cancel.  \n            **Note:** Bootstrap popover has own `hidden` event that now cannot be separated from x-editable's one.\n            The workaround is to check `arguments.length` that is always `2` for x-editable. \n\n            @event hidden \n            @param {object} event event object\n            @param {string} reason Reason caused hiding. Can be <code>save|cancel|onblur|nochange|manual</code>\n            @example\n            $('#username').on('hidden', function(e, reason) {\n                if(reason === 'save' || reason === 'cancel') {\n                    //auto-open next editable\n                    $(this).closest('tr').next().find('.editable').editable('show');\n                } \n            });\n            **/\n            this.$element.triggerHandler('hidden', reason || 'manual');   \n        },\n\n        /* internal show method. To be overwritten in child classes */\n        innerShow: function () {\n             \n        },        \n\n        /* internal hide method. To be overwritten in child classes */\n        innerHide: function () {\n\n        },\n        \n        /**\n        Toggles container visibility (show / hide)\n        @method toggle()\n        @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.\n        **/          \n        toggle: function(closeAll) {\n            if(this.container() && this.tip() && this.tip().is(':visible')) {\n                this.hide();\n            } else {\n                this.show(closeAll);\n            } \n        },\n\n        /*\n        Updates the position of container when content changed.\n        @method setPosition()\n        */       \n        setPosition: function() {\n            //tbd in child class\n        },\n\n        save: function(e, params) {\n            /**        \n            Fired when new value was submitted. You can use <code>$(this).data('editableContainer')</code> inside handler to access to editableContainer instance\n            \n            @event save \n            @param {Object} event event object\n            @param {Object} params additional params\n            @param {mixed} params.newValue submitted value\n            @param {Object} params.response ajax response\n            @example\n            $('#username').on('save', function(e, params) {\n                //assuming server response: '{success: true}'\n                var pk = $(this).data('editableContainer').options.pk;\n                if(params.response && params.response.success) {\n                    alert('value: ' + params.newValue + ' with pk: ' + pk + ' saved!');\n                } else {\n                    alert('error!'); \n                } \n            });\n            **/             \n            this.$element.triggerHandler('save', params);\n            \n            //hide must be after trigger, as saving value may require methods of plugin, applied to input\n            this.hide('save');\n        },\n\n        /**\n        Sets new option\n        \n        @method option(key, value)\n        @param {string} key \n        @param {mixed} value \n        **/         \n        option: function(key, value) {\n            this.options[key] = value;\n            if(key in this.containerOptions) {\n                this.containerOptions[key] = value;\n                this.setContainerOption(key, value); \n            } else {\n                this.formOptions[key] = value;\n                if(this.$form) {\n                    this.$form.editableform('option', key, value);  \n                }\n            }\n        },\n        \n        setContainerOption: function(key, value) {\n            this.call('option', key, value);\n        },\n\n        /**\n        Destroys the container instance\n        @method destroy()\n        **/        \n        destroy: function() {\n            this.hide();\n            this.innerDestroy();\n            this.$element.off('destroyed');\n            this.$element.removeData('editableContainer');\n        },\n        \n        /* to be overwritten in child classes */\n        innerDestroy: function() {\n            \n        }, \n        \n        /*\n        Closes other containers except one related to passed element. \n        Other containers can be cancelled or submitted (depends on onblur option)\n        */\n        closeOthers: function(element) {\n            $('.editable-open').each(function(i, el){\n                //do nothing with passed element and it's children\n                if(el === element || $(el).find(element).length) {\n                    return;\n                }\n\n                //otherwise cancel or submit all open containers \n                var $el = $(el),\n                ec = $el.data('editableContainer');\n\n                if(!ec) {\n                    return;  \n                }\n                \n                if(ec.options.onblur === 'cancel') {\n                    $el.data('editableContainer').hide('onblur');\n                } else if(ec.options.onblur === 'submit') {\n                    $el.data('editableContainer').tip().find('form').submit();\n                }\n            });\n\n        },\n        \n        /**\n        Activates input of visible container (e.g. set focus)\n        @method activate()\n        **/         \n        activate: function() {\n            if(this.tip && this.tip().is(':visible') && this.$form) {\n               this.$form.data('editableform').input.activate(); \n            }\n        } \n\n    };\n\n    /**\n    jQuery method to initialize editableContainer.\n    \n    @method $().editableContainer(options)\n    @params {Object} options\n    @example\n    $('#edit').editableContainer({\n        type: 'text',\n        url: '/post',\n        pk: 1,\n        value: 'hello'\n    });\n    **/  \n    $.fn.editableContainer = function (option) {\n        var args = arguments;\n        return this.each(function () {\n            var $this = $(this),\n            dataKey = 'editableContainer', \n            data = $this.data(dataKey),\n            options = typeof option === 'object' && option,\n            Constructor = (options.mode === 'inline') ? Inline : Popup;             \n\n            if (!data) {\n                $this.data(dataKey, (data = new Constructor(this, options)));\n            }\n\n            if (typeof option === 'string') { //call method \n                data[option].apply(data, Array.prototype.slice.call(args, 1));\n            }            \n        });\n    };     \n\n    //store constructors\n    $.fn.editableContainer.Popup = Popup;\n    $.fn.editableContainer.Inline = Inline;\n\n    //defaults\n    $.fn.editableContainer.defaults = {\n        /**\n        Initial value of form input\n\n        @property value \n        @type mixed\n        @default null\n        @private\n        **/        \n        value: null,\n        /**\n        Placement of container relative to element. Can be <code>top|right|bottom|left</code>. Not used for inline container.\n\n        @property placement \n        @type string\n        @default 'top'\n        **/        \n        placement: 'top',\n        /**\n        Whether to hide container on save/cancel.\n\n        @property autohide \n        @type boolean\n        @default true\n        @private \n        **/        \n        autohide: true,\n        /**\n        Action when user clicks outside the container. Can be <code>cancel|submit|ignore</code>.  \n        Setting <code>ignore</code> allows to have several containers open. \n\n        @property onblur \n        @type string\n        @default 'cancel'\n        @since 1.1.1\n        **/        \n        onblur: 'cancel',\n        \n        /**\n        Animation speed (inline mode only)\n        @property anim \n        @type string\n        @default false\n        **/        \n        anim: false,\n        \n        /**\n        Mode of editable, can be `popup` or `inline` \n        \n        @property mode \n        @type string         \n        @default 'popup'\n        @since 1.4.0        \n        **/        \n        mode: 'popup'        \n    };\n\n    /* \n    * workaround to have 'destroyed' event to destroy popover when element is destroyed\n    * see http://stackoverflow.com/questions/2200494/jquery-trigger-event-when-an-element-is-removed-from-the-dom\n    */\n    jQuery.event.special.destroyed = {\n        remove: function(o) {\n            if (o.handler) {\n                o.handler();\n            }\n        }\n    };    \n\n}(window.jQuery));\n\n/**\n* Editable Inline \n* ---------------------\n*/\n(function ($) {\n    \"use strict\";\n    \n    //copy prototype from EditableContainer\n    //extend methods\n    $.extend($.fn.editableContainer.Inline.prototype, $.fn.editableContainer.Popup.prototype, {\n        containerName: 'editableform',\n        innerCss: '.editable-inline',\n        containerClass: 'editable-container editable-inline', //css class applied to container element\n                 \n        initContainer: function(){\n            //container is <span> element\n            this.$tip = $('<span></span>');\n            \n            //convert anim to miliseconds (int)\n            if(!this.options.anim) {\n                this.options.anim = 0;\n            }         \n        },\n        \n        splitOptions: function() {\n            //all options are passed to form\n            this.containerOptions = {};\n            this.formOptions = this.options;\n        },\n        \n        tip: function() {\n           return this.$tip; \n        },\n        \n        innerShow: function () {\n            this.$element.hide();\n            this.tip().insertAfter(this.$element).show();\n        }, \n        \n        innerHide: function () {\n            this.$tip.hide(this.options.anim, $.proxy(function() {\n                this.$element.show();\n                this.innerDestroy();\n            }, this)); \n        },\n        \n        innerDestroy: function() {\n            if(this.tip()) {\n                this.tip().empty().remove();\n            }\n        } \n    });\n\n}(window.jQuery));\n/**\nMakes editable any HTML element on the page. Applied as jQuery method.\n\n@class editable\n@uses editableContainer\n**/\n(function ($) {\n    \"use strict\";\n\n    var Editable = function (element, options) {\n        this.$element = $(element);\n        //data-* has more priority over js options: because dynamically created elements may change data-* \n        this.options = $.extend({}, $.fn.editable.defaults, options, $.fn.editableutils.getConfigData(this.$element));  \n        if(this.options.selector) {\n            this.initLive();\n        } else {\n            this.init();\n        }\n        \n        //check for transition support\n        if(this.options.highlight && !$.fn.editableutils.supportsTransitions()) {\n            this.options.highlight = false;\n        }\n    };\n\n    Editable.prototype = {\n        constructor: Editable, \n        init: function () {\n            var isValueByText = false, \n                doAutotext, finalize;\n\n            //name\n            this.options.name = this.options.name || this.$element.attr('id');\n             \n            //create input of specified type. Input needed already here to convert value for initial display (e.g. show text by id for select)\n            //also we set scope option to have access to element inside input specific callbacks (e. g. source as function)\n            this.options.scope = this.$element[0]; \n            this.input = $.fn.editableutils.createInput(this.options);\n            if(!this.input) {\n                return; \n            }            \n\n            //set value from settings or by element's text\n            if (this.options.value === undefined || this.options.value === null) {\n                this.value = this.input.html2value($.trim(this.$element.html()));\n                isValueByText = true;\n            } else {\n                /*\n                  value can be string when received from 'data-value' attribute\n                  for complext objects value can be set as json string in data-value attribute, \n                  e.g. data-value=\"{city: 'Moscow', street: 'Lenina'}\"\n                */\n                this.options.value = $.fn.editableutils.tryParseJson(this.options.value, true); \n                if(typeof this.options.value === 'string') {\n                    this.value = this.input.str2value(this.options.value);\n                } else {\n                    this.value = this.options.value;\n                }\n            }\n            \n            //add 'editable' class to every editable element\n            this.$element.addClass('editable');\n            \n            //specifically for \"textarea\" add class .editable-pre-wrapped to keep linebreaks\n            if(this.input.type === 'textarea') {\n                this.$element.addClass('editable-pre-wrapped');\n            }\n            \n            //attach handler activating editable. In disabled mode it just prevent default action (useful for links)\n            if(this.options.toggle !== 'manual') {\n                this.$element.addClass('editable-click');\n                this.$element.on(this.options.toggle + '.editable', $.proxy(function(e){\n                    //prevent following link if editable enabled\n                    if(!this.options.disabled) {\n                        e.preventDefault();\n                    }\n                    \n                    //stop propagation not required because in document click handler it checks event target\n                    //e.stopPropagation();\n                    \n                    if(this.options.toggle === 'mouseenter') {\n                        //for hover only show container\n                        this.show();\n                    } else {\n                        //when toggle='click' we should not close all other containers as they will be closed automatically in document click listener\n                        var closeAll = (this.options.toggle !== 'click');\n                        this.toggle(closeAll);\n                    }\n                }, this));\n            } else {\n                this.$element.attr('tabindex', -1); //do not stop focus on element when toggled manually\n            }\n            \n            //if display is function it's far more convinient to have autotext = always to render correctly on init\n            //see https://github.com/vitalets/x-editable-yii/issues/34\n            if(typeof this.options.display === 'function') {\n                this.options.autotext = 'always';\n            }\n            \n            //check conditions for autotext:\n            switch(this.options.autotext) {\n              case 'always':\n               doAutotext = true;\n              break;\n              case 'auto':\n                //if element text is empty and value is defined and value not generated by text --> run autotext\n                doAutotext = !$.trim(this.$element.text()).length && this.value !== null && this.value !== undefined && !isValueByText;\n              break;\n              default:\n               doAutotext = false;\n            }\n\n            //depending on autotext run render() or just finilize init\n            $.when(doAutotext ? this.render() : true).then($.proxy(function() {\n                if(this.options.disabled) {\n                    this.disable();\n                } else {\n                    this.enable(); \n                }\n               /**        \n               Fired when element was initialized by `$().editable()` method. \n               Please note that you should setup `init` handler **before** applying `editable`. \n                              \n               @event init \n               @param {Object} event event object\n               @param {Object} editable editable instance (as here it cannot accessed via data('editable'))\n               @since 1.2.0\n               @example\n               $('#username').on('init', function(e, editable) {\n                   alert('initialized ' + editable.options.name);\n               });\n               $('#username').editable();\n               **/                  \n                this.$element.triggerHandler('init', this);\n            }, this));\n        },\n\n        /*\n         Initializes parent element for live editables \n        */\n        initLive: function() {\n           //store selector \n           var selector = this.options.selector;\n           //modify options for child elements\n           this.options.selector = false; \n           this.options.autotext = 'never';\n           //listen toggle events\n           this.$element.on(this.options.toggle + '.editable', selector, $.proxy(function(e){\n               var $target = $(e.target);\n               if(!$target.data('editable')) {\n                   //if delegated element initially empty, we need to clear it's text (that was manually set to `empty` by user)\n                   //see https://github.com/vitalets/x-editable/issues/137 \n                   if($target.hasClass(this.options.emptyclass)) {\n                      $target.empty();\n                   }\n                   $target.editable(this.options).trigger(e);\n               }\n           }, this)); \n        },\n        \n        /*\n        Renders value into element's text.\n        Can call custom display method from options.\n        Can return deferred object.\n        @method render()\n        @param {mixed} response server response (if exist) to pass into display function\n        */          \n        render: function(response) {\n            //do not display anything\n            if(this.options.display === false) {\n                return;\n            }\n            \n            //if input has `value2htmlFinal` method, we pass callback in third param to be called when source is loaded\n            if(this.input.value2htmlFinal) {\n                return this.input.value2html(this.value, this.$element[0], this.options.display, response); \n            //if display method defined --> use it    \n            } else if(typeof this.options.display === 'function') {\n                return this.options.display.call(this.$element[0], this.value, response);\n            //else use input's original value2html() method    \n            } else {\n                return this.input.value2html(this.value, this.$element[0]); \n            }\n        },\n        \n        /**\n        Enables editable\n        @method enable()\n        **/          \n        enable: function() {\n            this.options.disabled = false;\n            this.$element.removeClass('editable-disabled');\n            this.handleEmpty(this.isEmpty);\n            if(this.options.toggle !== 'manual') {\n                if(this.$element.attr('tabindex') === '-1') {    \n                    this.$element.removeAttr('tabindex');                                \n                }\n            }\n        },\n        \n        /**\n        Disables editable\n        @method disable()\n        **/         \n        disable: function() {\n            this.options.disabled = true; \n            this.hide();           \n            this.$element.addClass('editable-disabled');\n            this.handleEmpty(this.isEmpty);\n            //do not stop focus on this element\n            this.$element.attr('tabindex', -1);                \n        },\n        \n        /**\n        Toggles enabled / disabled state of editable element\n        @method toggleDisabled()\n        **/         \n        toggleDisabled: function() {\n            if(this.options.disabled) {\n                this.enable();\n            } else { \n                this.disable(); \n            }\n        },  \n        \n        /**\n        Sets new option\n        \n        @method option(key, value)\n        @param {string|object} key option name or object with several options\n        @param {mixed} value option new value\n        @example\n        $('.editable').editable('option', 'pk', 2);\n        **/          \n        option: function(key, value) {\n            //set option(s) by object\n            if(key && typeof key === 'object') {\n               $.each(key, $.proxy(function(k, v){\n                  this.option($.trim(k), v); \n               }, this)); \n               return;\n            }\n\n            //set option by string             \n            this.options[key] = value;                          \n            \n            //disabled\n            if(key === 'disabled') {\n               return value ? this.disable() : this.enable();\n            } \n            \n            //value\n            if(key === 'value') {\n                this.setValue(value);\n            }\n            \n            //transfer new option to container! \n            if(this.container) {\n                this.container.option(key, value);  \n            }\n             \n            //pass option to input directly (as it points to the same in form)\n            if(this.input.option) {\n                this.input.option(key, value);\n            }\n            \n        },              \n        \n        /*\n        * set emptytext if element is empty\n        */\n        handleEmpty: function (isEmpty) {\n            //do not handle empty if we do not display anything\n            if(this.options.display === false) {\n                return;\n            }\n\n            /* \n            isEmpty may be set directly as param of method.\n            It is required when we enable/disable field and can't rely on content \n            as node content is text: \"Empty\" that is not empty %)\n            */\n            if(isEmpty !== undefined) { \n                this.isEmpty = isEmpty;\n            } else {\n                //detect empty\n                //for some inputs we need more smart check\n                //e.g. wysihtml5 may have <br>, <p></p>, <img>\n                if(typeof(this.input.isEmpty) === 'function') {\n                    this.isEmpty = this.input.isEmpty(this.$element);                    \n                } else {\n                    this.isEmpty = $.trim(this.$element.html()) === '';\n                }\n            }           \n            \n            //emptytext shown only for enabled\n            if(!this.options.disabled) {\n                if (this.isEmpty) {\n                    this.$element.html(this.options.emptytext);\n                    if(this.options.emptyclass) {\n                        this.$element.addClass(this.options.emptyclass);\n                    }\n                } else if(this.options.emptyclass) {\n                    this.$element.removeClass(this.options.emptyclass);\n                }\n            } else {\n                //below required if element disable property was changed\n                if(this.isEmpty) {\n                    this.$element.empty();\n                    if(this.options.emptyclass) {\n                        this.$element.removeClass(this.options.emptyclass);\n                    }\n                }\n            }\n        },        \n        \n        /**\n        Shows container with form\n        @method show()\n        @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.\n        **/  \n        show: function (closeAll) {\n            if(this.options.disabled) {\n                return;\n            }\n            \n            //init editableContainer: popover, tooltip, inline, etc..\n            if(!this.container) {\n                var containerOptions = $.extend({}, this.options, {\n                    value: this.value,\n                    input: this.input //pass input to form (as it is already created)\n                });\n                this.$element.editableContainer(containerOptions);\n                //listen `save` event \n                this.$element.on(\"save.internal\", $.proxy(this.save, this));\n                this.container = this.$element.data('editableContainer'); \n            } else if(this.container.tip().is(':visible')) {\n                return;\n            }      \n            \n            //show container\n            this.container.show(closeAll);\n        },\n        \n        /**\n        Hides container with form\n        @method hide()\n        **/       \n        hide: function () {   \n            if(this.container) {  \n                this.container.hide();\n            }\n        },\n        \n        /**\n        Toggles container visibility (show / hide)\n        @method toggle()\n        @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.\n        **/  \n        toggle: function(closeAll) {\n            if(this.container && this.container.tip().is(':visible')) {\n                this.hide();\n            } else {\n                this.show(closeAll);\n            }\n        },\n        \n        /*\n        * called when form was submitted\n        */          \n        save: function(e, params) {\n            //mark element with unsaved class if needed\n            if(this.options.unsavedclass) {\n                /*\n                 Add unsaved css to element if:\n                  - url is not user's function \n                  - value was not sent to server\n                  - params.response === undefined, that means data was not sent\n                  - value changed \n                */\n                var sent = false;\n                sent = sent || typeof this.options.url === 'function';\n                sent = sent || this.options.display === false; \n                sent = sent || params.response !== undefined; \n                sent = sent || (this.options.savenochange && this.input.value2str(this.value) !== this.input.value2str(params.newValue)); \n                \n                if(sent) {\n                    this.$element.removeClass(this.options.unsavedclass); \n                } else {\n                    this.$element.addClass(this.options.unsavedclass);                    \n                }\n            }\n            \n            //highlight when saving\n            if(this.options.highlight) {\n                var $e = this.$element,\n                    bgColor = $e.css('background-color');\n                    \n                $e.css('background-color', this.options.highlight);\n                setTimeout(function(){\n                    if(bgColor === 'transparent') {\n                        bgColor = ''; \n                    }\n                    $e.css('background-color', bgColor);\n                    $e.addClass('editable-bg-transition');\n                    setTimeout(function(){\n                       $e.removeClass('editable-bg-transition');  \n                    }, 1700);\n                }, 10);\n            }\n            \n            //set new value\n            this.setValue(params.newValue, false, params.response);\n            \n            /**        \n            Fired when new value was submitted. You can use <code>$(this).data('editable')</code> to access to editable instance\n            \n            @event save \n            @param {Object} event event object\n            @param {Object} params additional params\n            @param {mixed} params.newValue submitted value\n            @param {Object} params.response ajax response\n            @example\n            $('#username').on('save', function(e, params) {\n                alert('Saved value: ' + params.newValue);\n            });\n            **/\n            //event itself is triggered by editableContainer. Description here is only for documentation              \n        },\n\n        validate: function () {\n            if (typeof this.options.validate === 'function') {\n                return this.options.validate.call(this, this.value);\n            }\n        },\n        \n        /**\n        Sets new value of editable\n        @method setValue(value, convertStr)\n        @param {mixed} value new value \n        @param {boolean} convertStr whether to convert value from string to internal format\n        **/         \n        setValue: function(value, convertStr, response) {\n            if(convertStr) {\n                this.value = this.input.str2value(value);\n            } else {\n                this.value = value;\n            }\n            if(this.container) {\n                this.container.option('value', this.value);\n            }\n            $.when(this.render(response))\n            .then($.proxy(function() {\n                this.handleEmpty();\n            }, this));\n        },\n        \n        /**\n        Activates input of visible container (e.g. set focus)\n        @method activate()\n        **/         \n        activate: function() {\n            if(this.container) {\n               this.container.activate(); \n            }\n        },\n        \n        /**\n        Removes editable feature from element\n        @method destroy()\n        **/        \n        destroy: function() {\n            this.disable();\n            \n            if(this.container) {\n               this.container.destroy(); \n            }\n            \n            this.input.destroy();\n\n            if(this.options.toggle !== 'manual') {\n                this.$element.removeClass('editable-click');\n                this.$element.off(this.options.toggle + '.editable');\n            } \n            \n            this.$element.off(\"save.internal\");\n            \n            this.$element.removeClass('editable editable-open editable-disabled');\n            this.$element.removeData('editable');\n        }        \n    };\n\n    /* EDITABLE PLUGIN DEFINITION\n    * ======================= */\n\n    /**\n    jQuery method to initialize editable element.\n    \n    @method $().editable(options)\n    @params {Object} options\n    @example\n    $('#username').editable({\n        type: 'text',\n        url: '/post',\n        pk: 1\n    });\n    **/\n    $.fn.editable = function (option) {\n        //special API methods returning non-jquery object\n        var result = {}, args = arguments, datakey = 'editable';\n        switch (option) {\n            /**\n            Runs client-side validation for all matched editables\n            \n            @method validate()\n            @returns {Object} validation errors map\n            @example\n            $('#username, #fullname').editable('validate');\n            // possible result:\n            {\n              username: \"username is required\",\n              fullname: \"fullname should be minimum 3 letters length\"\n            }\n            **/\n            case 'validate':\n                this.each(function () {\n                    var $this = $(this), data = $this.data(datakey), error;\n                    if (data && (error = data.validate())) {\n                        result[data.options.name] = error;\n                    }\n                });\n            return result;\n\n            /**\n            Returns current values of editable elements.   \n            Note that it returns an **object** with name-value pairs, not a value itself. It allows to get data from several elements.    \n            If value of some editable is `null` or `undefined` it is excluded from result object.\n            When param `isSingle` is set to **true** - it is supposed you have single element and will return value of editable instead of object.   \n             \n            @method getValue()\n            @param {bool} isSingle whether to return just value of single element\n            @returns {Object} object of element names and values\n            @example\n            $('#username, #fullname').editable('getValue');\n            //result:\n            {\n            username: \"superuser\",\n            fullname: \"John\"\n            }\n            //isSingle = true\n            $('#username').editable('getValue', true);\n            //result \"superuser\" \n            **/\n            case 'getValue':\n                if(arguments.length === 2 && arguments[1] === true) { //isSingle = true\n                    result = this.eq(0).data(datakey).value;\n                } else {\n                    this.each(function () {\n                        var $this = $(this), data = $this.data(datakey);\n                        if (data && data.value !== undefined && data.value !== null) {\n                            result[data.options.name] = data.input.value2submit(data.value);\n                        }\n                    });\n                }\n            return result;\n\n            /**\n            This method collects values from several editable elements and submit them all to server.   \n            Internally it runs client-side validation for all fields and submits only in case of success.  \n            See <a href=\"#newrecord\">creating new records</a> for details.  \n            Since 1.5.1 `submit` can be applied to single element to send data programmatically. In that case\n            `url`, `success` and `error` is taken from initial options and you can just call `$('#username').editable('submit')`. \n            \n            @method submit(options)\n            @param {object} options \n            @param {object} options.url url to submit data \n            @param {object} options.data additional data to submit\n            @param {object} options.ajaxOptions additional ajax options\n            @param {function} options.error(obj) error handler \n            @param {function} options.success(obj,config) success handler\n            @returns {Object} jQuery object\n            **/\n            case 'submit':  //collects value, validate and submit to server for creating new record\n                var config = arguments[1] || {},\n                $elems = this,\n                errors = this.editable('validate');\n\n                // validation ok\n                if($.isEmptyObject(errors)) {\n                    var ajaxOptions = {};\n                                                      \n                    // for single element use url, success etc from options\n                    if($elems.length === 1) {\n                        var editable = $elems.data('editable');\n                        //standard params\n                        var params = {\n                            name: editable.options.name || '',\n                            value: editable.input.value2submit(editable.value),\n                            pk: (typeof editable.options.pk === 'function') ? \n                                editable.options.pk.call(editable.options.scope) : \n                                editable.options.pk \n                        };\n\n                        //additional params\n                        if(typeof editable.options.params === 'function') {\n                            params = editable.options.params.call(editable.options.scope, params);  \n                        } else {\n                            //try parse json in single quotes (from data-params attribute)\n                            editable.options.params = $.fn.editableutils.tryParseJson(editable.options.params, true);   \n                            $.extend(params, editable.options.params);\n                        }\n\n                        ajaxOptions = {\n                            url: editable.options.url,\n                            data: params,\n                            type: 'POST'  \n                        };\n                        \n                        // use success / error from options \n                        config.success = config.success || editable.options.success;\n                        config.error = config.error || editable.options.error;\n                        \n                    // multiple elements\n                    } else {\n                        var values = this.editable('getValue'); \n                        \n                        ajaxOptions = {\n                            url: config.url,\n                            data: values, \n                            type: 'POST'\n                        };                        \n                    }                    \n\n                    // ajax success callabck (response 200 OK)\n                    ajaxOptions.success = typeof config.success === 'function' ? function(response) {\n                            config.success.call($elems, response, config);\n                        } : $.noop;\n                                  \n                    // ajax error callabck\n                    ajaxOptions.error = typeof config.error === 'function' ? function() {\n                             config.error.apply($elems, arguments);\n                        } : $.noop;\n                       \n                    // extend ajaxOptions    \n                    if(config.ajaxOptions) { \n                        $.extend(ajaxOptions, config.ajaxOptions);\n                    }\n                    \n                    // extra data \n                    if(config.data) {\n                        $.extend(ajaxOptions.data, config.data);\n                    }                     \n                    \n                    // perform ajax request\n                    $.ajax(ajaxOptions);\n                } else { //client-side validation error\n                    if(typeof config.error === 'function') {\n                        config.error.call($elems, errors);\n                    }\n                }\n            return this;\n        }\n\n        //return jquery object\n        return this.each(function () {\n            var $this = $(this), \n                data = $this.data(datakey), \n                options = typeof option === 'object' && option;\n\n            //for delegated targets do not store `editable` object for element\n            //it's allows several different selectors.\n            //see: https://github.com/vitalets/x-editable/issues/312    \n            if(options && options.selector) {\n                data = new Editable(this, options);\n                return; \n            }    \n            \n            if (!data) {\n                $this.data(datakey, (data = new Editable(this, options)));\n            }\n\n            if (typeof option === 'string') { //call method \n                data[option].apply(data, Array.prototype.slice.call(args, 1));\n            } \n        });\n    };    \n            \n\n    $.fn.editable.defaults = {\n        /**\n        Type of input. Can be <code>text|textarea|select|date|checklist</code> and more\n\n        @property type \n        @type string\n        @default 'text'\n        **/\n        type: 'text',        \n        /**\n        Sets disabled state of editable\n\n        @property disabled \n        @type boolean\n        @default false\n        **/         \n        disabled: false,\n        /**\n        How to toggle editable. Can be <code>click|dblclick|mouseenter|manual</code>.   \n        When set to <code>manual</code> you should manually call <code>show/hide</code> methods of editable.    \n        **Note**: if you call <code>show</code> or <code>toggle</code> inside **click** handler of some DOM element, \n        you need to apply <code>e.stopPropagation()</code> because containers are being closed on any click on document.\n        \n        @example\n        $('#edit-button').click(function(e) {\n            e.stopPropagation();\n            $('#username').editable('toggle');\n        });\n\n        @property toggle \n        @type string\n        @default 'click'\n        **/          \n        toggle: 'click',\n        /**\n        Text shown when element is empty.\n\n        @property emptytext \n        @type string\n        @default 'Empty'\n        **/         \n        emptytext: 'Empty',\n        /**\n        Allows to automatically set element's text based on it's value. Can be <code>auto|always|never</code>. Useful for select and date.\n        For example, if dropdown list is <code>{1: 'a', 2: 'b'}</code> and element's value set to <code>1</code>, it's html will be automatically set to <code>'a'</code>.  \n        <code>auto</code> - text will be automatically set only if element is empty.  \n        <code>always|never</code> - always(never) try to set element's text.\n\n        @property autotext \n        @type string\n        @default 'auto'\n        **/          \n        autotext: 'auto', \n        /**\n        Initial value of input. If not set, taken from element's text.  \n        Note, that if element's text is empty - text is automatically generated from value and can be customized (see `autotext` option).  \n        For example, to display currency sign:\n        @example\n        <a id=\"price\" data-type=\"text\" data-value=\"100\"></a>\n        <script>\n        $('#price').editable({\n            ...\n            display: function(value) {\n              $(this).text(value + '$');\n            } \n        }) \n        </script>\n                \n        @property value \n        @type mixed\n        @default element's text\n        **/\n        value: null,\n        /**\n        Callback to perform custom displaying of value in element's text.  \n        If `null`, default input's display used.  \n        If `false`, no displaying methods will be called, element's text will never change.  \n        Runs under element's scope.  \n        _**Parameters:**_  \n        \n        * `value` current value to be displayed\n        * `response` server response (if display called after ajax submit), since 1.4.0\n         \n        For _inputs with source_ (select, checklist) parameters are different:  \n          \n        * `value` current value to be displayed\n        * `sourceData` array of items for current input (e.g. dropdown items) \n        * `response` server response (if display called after ajax submit), since 1.4.0\n                  \n        To get currently selected items use `$.fn.editableutils.itemsByValue(value, sourceData)`.\n        \n        @property display \n        @type function|boolean\n        @default null\n        @since 1.2.0\n        @example\n        display: function(value, sourceData) {\n           //display checklist as comma-separated values\n           var html = [],\n               checked = $.fn.editableutils.itemsByValue(value, sourceData);\n               \n           if(checked.length) {\n               $.each(checked, function(i, v) { html.push($.fn.editableutils.escape(v.text)); });\n               $(this).html(html.join(', '));\n           } else {\n               $(this).empty(); \n           }\n        }\n        **/          \n        display: null,\n        /**\n        Css class applied when editable text is empty.\n\n        @property emptyclass \n        @type string\n        @since 1.4.1        \n        @default editable-empty\n        **/        \n        emptyclass: 'editable-empty',\n        /**\n        Css class applied when value was stored but not sent to server (`pk` is empty or `send = 'never'`).  \n        You may set it to `null` if you work with editables locally and submit them together.  \n\n        @property unsavedclass \n        @type string\n        @since 1.4.1        \n        @default editable-unsaved\n        **/        \n        unsavedclass: 'editable-unsaved',\n        /**\n        If selector is provided, editable will be delegated to the specified targets.  \n        Usefull for dynamically generated DOM elements.  \n        **Please note**, that delegated targets can't be initialized with `emptytext` and `autotext` options, \n        as they actually become editable only after first click.  \n        You should manually set class `editable-click` to these elements.  \n        Also, if element originally empty you should add class `editable-empty`, set `data-value=\"\"` and write emptytext into element:\n\n        @property selector \n        @type string\n        @since 1.4.1        \n        @default null\n        @example\n        <div id=\"user\">\n          <!-- empty -->\n          <a href=\"#\" data-name=\"username\" data-type=\"text\" class=\"editable-click editable-empty\" data-value=\"\" title=\"Username\">Empty</a>\n          <!-- non-empty -->\n          <a href=\"#\" data-name=\"group\" data-type=\"select\" data-source=\"/groups\" data-value=\"1\" class=\"editable-click\" title=\"Group\">Operator</a>\n        </div>     \n        \n        <script>\n        $('#user').editable({\n            selector: 'a',\n            url: '/post',\n            pk: 1\n        });\n        </script>\n        **/         \n        selector: null,\n        /**\n        Color used to highlight element after update. Implemented via CSS3 transition, works in modern browsers.\n        \n        @property highlight \n        @type string|boolean\n        @since 1.4.5        \n        @default #FFFF80 \n        **/\n        highlight: '#FFFF80'\n    };\n    \n}(window.jQuery));\n\n/**\nAbstractInput - base class for all editable inputs.\nIt defines interface to be implemented by any input type.\nTo create your own input you can inherit from this class.\n\n@class abstractinput\n**/\n(function ($) {\n    \"use strict\";\n\n    //types\n    $.fn.editabletypes = {};\n\n    var AbstractInput = function () { };\n\n    AbstractInput.prototype = {\n       /**\n        Initializes input\n\n        @method init() \n        **/\n       init: function(type, options, defaults) {\n           this.type = type;\n           this.options = $.extend({}, defaults, options);\n       },\n\n       /*\n       this method called before render to init $tpl that is inserted in DOM\n       */\n       prerender: function() {\n           this.$tpl = $(this.options.tpl); //whole tpl as jquery object    \n           this.$input = this.$tpl;         //control itself, can be changed in render method\n           this.$clear = null;              //clear button\n           this.error = null;               //error message, if input cannot be rendered           \n       },\n       \n       /**\n        Renders input from tpl. Can return jQuery deferred object.\n        Can be overwritten in child objects\n\n        @method render()\n       **/\n       render: function() {\n\n       }, \n\n       /**\n        Sets element's html by value. \n\n        @method value2html(value, element)\n        @param {mixed} value\n        @param {DOMElement} element\n       **/\n       value2html: function(value, element) {\n           $(element)[this.options.escape ? 'text' : 'html']($.trim(value));\n       },\n\n       /**\n        Converts element's html to value\n\n        @method html2value(html)\n        @param {string} html\n        @returns {mixed}\n       **/\n       html2value: function(html) {\n           return $('<div>').html(html).text();\n       },\n\n       /**\n        Converts value to string (for internal compare). For submitting to server used value2submit().\n\n        @method value2str(value) \n        @param {mixed} value\n        @returns {string}\n       **/\n       value2str: function(value) {\n           return value;\n       }, \n\n       /**\n        Converts string received from server into value. Usually from `data-value` attribute.\n\n        @method str2value(str)\n        @param {string} str\n        @returns {mixed}\n       **/\n       str2value: function(str) {\n           return str;\n       }, \n       \n       /**\n        Converts value for submitting to server. Result can be string or object.\n\n        @method value2submit(value) \n        @param {mixed} value\n        @returns {mixed}\n       **/\n       value2submit: function(value) {\n           return value;\n       },\n\n       /**\n        Sets value of input.\n\n        @method value2input(value) \n        @param {mixed} value\n       **/\n       value2input: function(value) {\n           this.$input.val(value);\n       },\n\n       /**\n        Returns value of input. Value can be object (e.g. datepicker)\n\n        @method input2value() \n       **/\n       input2value: function() { \n           return this.$input.val();\n       }, \n\n       /**\n        Activates input. For text it sets focus.\n\n        @method activate() \n       **/\n       activate: function() {\n           if(this.$input.is(':visible')) {\n               this.$input.focus();\n           }\n       },\n\n       /**\n        Creates input.\n\n        @method clear() \n       **/        \n       clear: function() {\n           this.$input.val(null);\n       },\n\n       /**\n        method to escape html.\n       **/\n       escape: function(str) {\n           return $('<div>').text(str).html();\n       },\n       \n       /**\n        attach handler to automatically submit form when value changed (useful when buttons not shown)\n       **/\n       autosubmit: function() {\n        \n       },\n       \n       /**\n       Additional actions when destroying element \n       **/\n       destroy: function() {\n       },\n\n       // -------- helper functions --------\n       setClass: function() {          \n           if(this.options.inputclass) {\n               this.$input.addClass(this.options.inputclass); \n           } \n       },\n\n       setAttr: function(attr) {\n           if (this.options[attr] !== undefined && this.options[attr] !== null) {\n               this.$input.attr(attr, this.options[attr]);\n           } \n       },\n       \n       option: function(key, value) {\n            this.options[key] = value;\n       }\n       \n    };\n        \n    AbstractInput.defaults = {  \n        /**\n        HTML template of input. Normally you should not change it.\n\n        @property tpl \n        @type string\n        @default ''\n        **/   \n        tpl: '',\n        /**\n        CSS class automatically applied to input\n        \n        @property inputclass \n        @type string\n        @default null\n        **/         \n        inputclass: null,\n        \n        /**\n        If `true` - html will be escaped in content of element via $.text() method.  \n        If `false` - html will not be escaped, $.html() used.  \n        When you use own `display` function, this option obviosly has no effect.\n        \n        @property escape \n        @type boolean\n        @since 1.5.0\n        @default true\n        **/         \n        escape: true,\n                \n        //scope for external methods (e.g. source defined as function)\n        //for internal use only\n        scope: null,\n        \n        //need to re-declare showbuttons here to get it's value from common config (passed only options existing in defaults)\n        showbuttons: true \n    };\n    \n    $.extend($.fn.editabletypes, {abstractinput: AbstractInput});\n        \n}(window.jQuery));\n\n/**\nList - abstract class for inputs that have source option loaded from js array or via ajax\n\n@class list\n@extends abstractinput\n**/\n(function ($) {\n    \"use strict\";\n    \n    var List = function (options) {\n       \n    };\n\n    $.fn.editableutils.inherit(List, $.fn.editabletypes.abstractinput);\n\n    $.extend(List.prototype, {\n        render: function () {\n            var deferred = $.Deferred();\n\n            this.error = null;\n            this.onSourceReady(function () {\n                this.renderList();\n                deferred.resolve();\n            }, function () {\n                this.error = this.options.sourceError;\n                deferred.resolve();\n            });\n\n            return deferred.promise();\n        },\n\n        html2value: function (html) {\n            return null; //can't set value by text\n        },\n        \n        value2html: function (value, element, display, response) {\n            var deferred = $.Deferred(),\n                success = function () {\n                    if(typeof display === 'function') {\n                        //custom display method\n                        display.call(element, value, this.sourceData, response); \n                    } else {\n                        this.value2htmlFinal(value, element);\n                    }\n                    deferred.resolve();\n               };\n            \n            //for null value just call success without loading source\n            if(value === null) {\n               success.call(this);   \n            } else {\n               this.onSourceReady(success, function () { deferred.resolve(); });\n            }\n\n            return deferred.promise();\n        },  \n\n        // ------------- additional functions ------------\n\n        onSourceReady: function (success, error) {\n            //run source if it function\n            var source;\n            if ($.isFunction(this.options.source)) {\n                source = this.options.source.call(this.options.scope);\n                this.sourceData = null;\n                //note: if function returns the same source as URL - sourceData will be taken from cahce and no extra request performed\n            } else {\n                source = this.options.source;\n            }            \n            \n            //if allready loaded just call success\n            if(this.options.sourceCache && $.isArray(this.sourceData)) {\n                success.call(this);\n                return; \n            }\n\n            //try parse json in single quotes (for double quotes jquery does automatically)\n            try {\n                source = $.fn.editableutils.tryParseJson(source, false);\n            } catch (e) {\n                error.call(this);\n                return;\n            }\n\n            //loading from url\n            if (typeof source === 'string') {\n                //try to get sourceData from cache\n                if(this.options.sourceCache) {\n                    var cacheID = source,\n                    cache;\n\n                    if (!$(document).data(cacheID)) {\n                        $(document).data(cacheID, {});\n                    }\n                    cache = $(document).data(cacheID);\n\n                    //check for cached data\n                    if (cache.loading === false && cache.sourceData) { //take source from cache\n                        this.sourceData = cache.sourceData;\n                        this.doPrepend();\n                        success.call(this);\n                        return;\n                    } else if (cache.loading === true) { //cache is loading, put callback in stack to be called later\n                        cache.callbacks.push($.proxy(function () {\n                            this.sourceData = cache.sourceData;\n                            this.doPrepend();\n                            success.call(this);\n                        }, this));\n\n                        //also collecting error callbacks\n                        cache.err_callbacks.push($.proxy(error, this));\n                        return;\n                    } else { //no cache yet, activate it\n                        cache.loading = true;\n                        cache.callbacks = [];\n                        cache.err_callbacks = [];\n                    }\n                }\n                \n                //ajaxOptions for source. Can be overwritten bt options.sourceOptions\n                var ajaxOptions = $.extend({\n                    url: source,\n                    type: 'get',\n                    cache: false,\n                    dataType: 'json',\n                    success: $.proxy(function (data) {\n                        if(cache) {\n                            cache.loading = false;\n                        }\n                        this.sourceData = this.makeArray(data);\n                        if($.isArray(this.sourceData)) {\n                            if(cache) {\n                                //store result in cache\n                                cache.sourceData = this.sourceData;\n                                //run success callbacks for other fields waiting for this source\n                                $.each(cache.callbacks, function () { this.call(); }); \n                            }\n                            this.doPrepend();\n                            success.call(this);\n                        } else {\n                            error.call(this);\n                            if(cache) {\n                                //run error callbacks for other fields waiting for this source\n                                $.each(cache.err_callbacks, function () { this.call(); }); \n                            }\n                        }\n                    }, this),\n                    error: $.proxy(function () {\n                        error.call(this);\n                        if(cache) {\n                             cache.loading = false;\n                             //run error callbacks for other fields\n                             $.each(cache.err_callbacks, function () { this.call(); }); \n                        }\n                    }, this)\n                }, this.options.sourceOptions);\n                \n                //loading sourceData from server\n                $.ajax(ajaxOptions);\n                \n            } else { //options as json/array\n                this.sourceData = this.makeArray(source);\n                    \n                if($.isArray(this.sourceData)) {\n                    this.doPrepend();\n                    success.call(this);   \n                } else {\n                    error.call(this);\n                }\n            }\n        },\n\n        doPrepend: function () {\n            if(this.options.prepend === null || this.options.prepend === undefined) {\n                return;  \n            }\n            \n            if(!$.isArray(this.prependData)) {\n                //run prepend if it is function (once)\n                if ($.isFunction(this.options.prepend)) {\n                    this.options.prepend = this.options.prepend.call(this.options.scope);\n                }\n              \n                //try parse json in single quotes\n                this.options.prepend = $.fn.editableutils.tryParseJson(this.options.prepend, true);\n                \n                //convert prepend from string to object\n                if (typeof this.options.prepend === 'string') {\n                    this.options.prepend = {'': this.options.prepend};\n                }\n                \n                this.prependData = this.makeArray(this.options.prepend);\n            }\n\n            if($.isArray(this.prependData) && $.isArray(this.sourceData)) {\n                this.sourceData = this.prependData.concat(this.sourceData);\n            }\n        },\n\n        /*\n         renders input list\n        */\n        renderList: function() {\n            // this method should be overwritten in child class\n        },\n       \n         /*\n         set element's html by value\n        */\n        value2htmlFinal: function(value, element) {\n            // this method should be overwritten in child class\n        },        \n\n        /**\n        * convert data to array suitable for sourceData, e.g. [{value: 1, text: 'abc'}, {...}]\n        */\n        makeArray: function(data) {\n            var count, obj, result = [], item, iterateItem;\n            if(!data || typeof data === 'string') {\n                return null; \n            }\n\n            if($.isArray(data)) { //array\n                /* \n                   function to iterate inside item of array if item is object.\n                   Caclulates count of keys in item and store in obj. \n                */\n                iterateItem = function (k, v) {\n                    obj = {value: k, text: v};\n                    if(count++ >= 2) {\n                        return false;// exit from `each` if item has more than one key.\n                    }\n                };\n            \n                for(var i = 0; i < data.length; i++) {\n                    item = data[i]; \n                    if(typeof item === 'object') {\n                        count = 0; //count of keys inside item\n                        $.each(item, iterateItem);\n                        //case: [{val1: 'text1'}, {val2: 'text2} ...]\n                        if(count === 1) { \n                            result.push(obj); \n                            //case: [{value: 1, text: 'text1'}, {value: 2, text: 'text2'}, ...]\n                        } else if(count > 1) {\n                            //removed check of existance: item.hasOwnProperty('value') && item.hasOwnProperty('text')\n                            if(item.children) {\n                                item.children = this.makeArray(item.children);   \n                            }\n                            result.push(item);\n                        }\n                    } else {\n                        //case: ['text1', 'text2' ...]\n                        result.push({value: item, text: item}); \n                    }\n                }\n            } else {  //case: {val1: 'text1', val2: 'text2, ...}\n                $.each(data, function (k, v) {\n                    result.push({value: k, text: v});\n                });  \n            }\n            return result;\n        },\n        \n        option: function(key, value) {\n            this.options[key] = value;\n            if(key === 'source') {\n                this.sourceData = null;\n            }\n            if(key === 'prepend') {\n                this.prependData = null;\n            }            \n        }        \n\n    });      \n\n    List.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        Source data for list.  \n        If **array** - it should be in format: `[{value: 1, text: \"text1\"}, {value: 2, text: \"text2\"}, ...]`  \n        For compability, object format is also supported: `{\"1\": \"text1\", \"2\": \"text2\" ...}` but it does not guarantee elements order.\n        \n        If **string** - considered ajax url to load items. In that case results will be cached for fields with the same source and name. See also `sourceCache` option.\n          \n        If **function**, it should return data in format above (since 1.4.0).\n        \n        Since 1.4.1 key `children` supported to render OPTGROUP (for **select** input only).  \n        `[{text: \"group1\", children: [{value: 1, text: \"text1\"}, {value: 2, text: \"text2\"}]}, ...]` \n\n\t\t\n        @property source \n        @type string | array | object | function\n        @default null\n        **/         \n        source: null, \n        /**\n        Data automatically prepended to the beginning of dropdown list.\n        \n        @property prepend \n        @type string | array | object | function\n        @default false\n        **/         \n        prepend: false,\n        /**\n        Error message when list cannot be loaded (e.g. ajax error)\n        \n        @property sourceError \n        @type string\n        @default Error when loading list\n        **/          \n        sourceError: 'Error when loading list',\n        /**\n        if <code>true</code> and source is **string url** - results will be cached for fields with the same source.    \n        Usefull for editable column in grid to prevent extra requests.\n        \n        @property sourceCache \n        @type boolean\n        @default true\n        @since 1.2.0\n        **/        \n        sourceCache: true,\n        /**\n        Additional ajax options to be used in $.ajax() when loading list from server.\n        Useful to send extra parameters (`data` key) or change request method (`type` key).\n        \n        @property sourceOptions \n        @type object|function\n        @default null\n        @since 1.5.0\n        **/        \n        sourceOptions: null\n    });\n\n    $.fn.editabletypes.list = List;      \n\n}(window.jQuery));\n\n/**\nText input\n\n@class text\n@extends abstractinput\n@final\n@example\n<a href=\"#\" id=\"username\" data-type=\"text\" data-pk=\"1\">awesome</a>\n<script>\n$(function(){\n    $('#username').editable({\n        url: '/post',\n        title: 'Enter username'\n    });\n});\n</script>\n**/\n(function ($) {\n    \"use strict\";\n    \n    var Text = function (options) {\n        this.init('text', options, Text.defaults);\n    };\n\n    $.fn.editableutils.inherit(Text, $.fn.editabletypes.abstractinput);\n\n    $.extend(Text.prototype, {\n        render: function() {\n           this.renderClear();\n           this.setClass();\n           this.setAttr('placeholder');\n        },\n        \n        activate: function() {\n            if(this.$input.is(':visible')) {\n                this.$input.focus();\n                $.fn.editableutils.setCursorPosition(this.$input.get(0), this.$input.val().length);\n                if(this.toggleClear) {\n                    this.toggleClear();\n                }\n            }\n        },\n        \n        //render clear button\n        renderClear:  function() {\n           if (this.options.clear) {\n               this.$clear = $('<span class=\"editable-clear-x\"></span>');\n               this.$input.after(this.$clear)\n                          .css('padding-right', 24)\n                          .keyup($.proxy(function(e) {\n                              //arrows, enter, tab, etc\n                              if(~$.inArray(e.keyCode, [40,38,9,13,27])) {\n                                return;\n                              }                            \n\n                              clearTimeout(this.t);\n                              var that = this;\n                              this.t = setTimeout(function() {\n                                that.toggleClear(e);\n                              }, 100);\n                              \n                          }, this))\n                          .parent().css('position', 'relative');\n                          \n               this.$clear.click($.proxy(this.clear, this));                       \n           }            \n        },\n        \n        postrender: function() {\n            /*\n            //now `clear` is positioned via css\n            if(this.$clear) {\n                //can position clear button only here, when form is shown and height can be calculated\n//                var h = this.$input.outerHeight(true) || 20,\n                var h = this.$clear.parent().height(),\n                    delta = (h - this.$clear.height()) / 2;\n                    \n                //this.$clear.css({bottom: delta, right: delta});\n            }\n            */ \n        },\n        \n        //show / hide clear button\n        toggleClear: function(e) {\n            if(!this.$clear) {\n                return;\n            }\n            \n            var len = this.$input.val().length,\n                visible = this.$clear.is(':visible');\n                 \n            if(len && !visible) {\n                this.$clear.show();\n            } \n            \n            if(!len && visible) {\n                this.$clear.hide();\n            } \n        },\n        \n        clear: function() {\n           this.$clear.hide();\n           this.$input.val('').focus();\n        }          \n    });\n\n    Text.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <input type=\"text\">\n        **/         \n        tpl: '<input type=\"text\">',\n        /**\n        Placeholder attribute of input. Shown when input is empty.\n\n        @property placeholder \n        @type string\n        @default null\n        **/             \n        placeholder: null,\n        \n        /**\n        Whether to show `clear` button \n        \n        @property clear \n        @type boolean\n        @default true        \n        **/\n        clear: true\n    });\n\n    $.fn.editabletypes.text = Text;\n\n}(window.jQuery));\n\n/**\nTextarea input\n\n@class textarea\n@extends abstractinput\n@final\n@example\n<a href=\"#\" id=\"comments\" data-type=\"textarea\" data-pk=\"1\">awesome comment!</a>\n<script>\n$(function(){\n    $('#comments').editable({\n        url: '/post',\n        title: 'Enter comments',\n        rows: 10\n    });\n});\n</script>\n**/\n(function ($) {\n    \"use strict\";\n    \n    var Textarea = function (options) {\n        this.init('textarea', options, Textarea.defaults);\n    };\n\n    $.fn.editableutils.inherit(Textarea, $.fn.editabletypes.abstractinput);\n\n    $.extend(Textarea.prototype, {\n        render: function () {\n            this.setClass();\n            this.setAttr('placeholder');\n            this.setAttr('rows');                        \n            \n            //ctrl + enter\n            this.$input.keydown(function (e) {\n                if (e.ctrlKey && e.which === 13) {\n                    $(this).closest('form').submit();\n                }\n            });\n        },\n        \n       //using `white-space: pre-wrap` solves \\n  <--> BR conversion very elegant!\n       /* \n       value2html: function(value, element) {\n            var html = '', lines;\n            if(value) {\n                lines = value.split(\"\\n\");\n                for (var i = 0; i < lines.length; i++) {\n                    lines[i] = $('<div>').text(lines[i]).html();\n                }\n                html = lines.join('<br>');\n            }\n            $(element).html(html);\n        },\n       \n        html2value: function(html) {\n            if(!html) {\n                return '';\n            }\n\n            var regex = new RegExp(String.fromCharCode(10), 'g');\n            var lines = html.split(/<br\\s*\\/?>/i);\n            for (var i = 0; i < lines.length; i++) {\n                var text = $('<div>').html(lines[i]).text();\n\n                // Remove newline characters (\\n) to avoid them being converted by value2html() method\n                // thus adding extra <br> tags\n                text = text.replace(regex, '');\n\n                lines[i] = text;\n            }\n            return lines.join(\"\\n\");\n        },\n         */\n        activate: function() {\n            $.fn.editabletypes.text.prototype.activate.call(this);\n        }\n    });\n\n    Textarea.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl\n        @default <textarea></textarea>\n        **/\n        tpl:'<textarea></textarea>',\n        /**\n        @property inputclass\n        @default input-large\n        **/\n        inputclass: 'input-large',\n        /**\n        Placeholder attribute of input. Shown when input is empty.\n\n        @property placeholder\n        @type string\n        @default null\n        **/\n        placeholder: null,\n        /**\n        Number of rows in textarea\n\n        @property rows\n        @type integer\n        @default 7\n        **/        \n        rows: 7        \n    });\n\n    $.fn.editabletypes.textarea = Textarea;\n\n}(window.jQuery));\n\n/**\nSelect (dropdown)\n\n@class select\n@extends list\n@final\n@example\n<a href=\"#\" id=\"status\" data-type=\"select\" data-pk=\"1\" data-url=\"/post\" data-title=\"Select status\"></a>\n<script>\n$(function(){\n    $('#status').editable({\n        value: 2,    \n        source: [\n              {value: 1, text: 'Active'},\n              {value: 2, text: 'Blocked'},\n              {value: 3, text: 'Deleted'}\n           ]\n    });\n});\n</script>\n**/\n(function ($) {\n    \"use strict\";\n    \n    var Select = function (options) {\n        this.init('select', options, Select.defaults);\n    };\n\n    $.fn.editableutils.inherit(Select, $.fn.editabletypes.list);\n\n    $.extend(Select.prototype, {\n        renderList: function() {\n            this.$input.empty();\n\n            var fillItems = function($el, data) {\n                var attr;\n                if($.isArray(data)) {\n                    for(var i=0; i<data.length; i++) {\n                        attr = {};\n                        if(data[i].children) {\n                            attr.label = data[i].text;\n                            $el.append(fillItems($('<optgroup>', attr), data[i].children)); \n                        } else {\n                            attr.value = data[i].value;\n                            if(data[i].disabled) {\n                                attr.disabled = true;\n                            }\n                            $el.append($('<option>', attr).text(data[i].text)); \n                        }\n                    }\n                }\n                return $el;\n            };        \n\n            fillItems(this.$input, this.sourceData);\n            \n            this.setClass();\n            \n            //enter submit\n            this.$input.on('keydown.editable', function (e) {\n                if (e.which === 13) {\n                    $(this).closest('form').submit();\n                }\n            });            \n        },\n       \n        value2htmlFinal: function(value, element) {\n            var text = '', \n                items = $.fn.editableutils.itemsByValue(value, this.sourceData);\n                \n            if(items.length) {\n                text = items[0].text;\n            }\n            \n            //$(element).text(text);\n            $.fn.editabletypes.abstractinput.prototype.value2html.call(this, text, element);\n        },\n        \n        autosubmit: function() {\n            this.$input.off('keydown.editable').on('change.editable', function(){\n                $(this).closest('form').submit();\n            });\n        }\n    });      \n\n    Select.defaults = $.extend({}, $.fn.editabletypes.list.defaults, {\n        /**\n        @property tpl \n        @default <select></select>\n        **/         \n        tpl:'<select></select>'\n    });\n\n    $.fn.editabletypes.select = Select;      \n\n}(window.jQuery));\n\n/**\nList of checkboxes. \nInternally value stored as javascript array of values.\n\n@class checklist\n@extends list\n@final\n@example\n<a href=\"#\" id=\"options\" data-type=\"checklist\" data-pk=\"1\" data-url=\"/post\" data-title=\"Select options\"></a>\n<script>\n$(function(){\n    $('#options').editable({\n        value: [2, 3],    \n        source: [\n              {value: 1, text: 'option1'},\n              {value: 2, text: 'option2'},\n              {value: 3, text: 'option3'}\n           ]\n    });\n});\n</script>\n**/\n(function ($) {\n    \"use strict\";\n    \n    var Checklist = function (options) {\n        this.init('checklist', options, Checklist.defaults);\n    };\n\n    $.fn.editableutils.inherit(Checklist, $.fn.editabletypes.list);\n\n    $.extend(Checklist.prototype, {\n        renderList: function() {\n            var $label, $div;\n            \n            this.$tpl.empty();\n            \n            if(!$.isArray(this.sourceData)) {\n                return;\n            }\n\n            for(var i=0; i<this.sourceData.length; i++) {\n                $label = $('<label>').append($('<input>', {\n                                           type: 'checkbox',\n                                           value: this.sourceData[i].value \n                                     }))\n                                     .append($('<span>').text(' '+this.sourceData[i].text));\n                \n                $('<div>').append($label).appendTo(this.$tpl);\n            }\n            \n            this.$input = this.$tpl.find('input[type=\"checkbox\"]');\n            this.setClass();\n        },\n       \n       value2str: function(value) {\n           return $.isArray(value) ? value.sort().join($.trim(this.options.separator)) : '';\n       },  \n       \n       //parse separated string\n        str2value: function(str) {\n           var reg, value = null;\n           if(typeof str === 'string' && str.length) {\n               reg = new RegExp('\\\\s*'+$.trim(this.options.separator)+'\\\\s*');\n               value = str.split(reg);\n           } else if($.isArray(str)) {\n               value = str; \n           } else {\n               value = [str];\n           }\n           return value;\n        },       \n       \n       //set checked on required checkboxes\n       value2input: function(value) {\n            this.$input.prop('checked', false);\n            if($.isArray(value) && value.length) {\n               this.$input.each(function(i, el) {\n                   var $el = $(el);\n                   // cannot use $.inArray as it performs strict comparison\n                   $.each(value, function(j, val){\n                       /*jslint eqeq: true*/\n                       if($el.val() == val) {\n                       /*jslint eqeq: false*/                           \n                           $el.prop('checked', true);\n                       }\n                   });\n               }); \n            }  \n        },  \n        \n       input2value: function() { \n           var checked = [];\n           this.$input.filter(':checked').each(function(i, el) {\n               checked.push($(el).val());\n           });\n           return checked;\n       },            \n          \n       //collect text of checked boxes\n        value2htmlFinal: function(value, element) {\n           var html = [],\n               checked = $.fn.editableutils.itemsByValue(value, this.sourceData),\n               escape = this.options.escape;\n               \n           if(checked.length) {\n               $.each(checked, function(i, v) {\n                   var text = escape ? $.fn.editableutils.escape(v.text) : v.text; \n                   html.push(text); \n               });\n               $(element).html(html.join('<br>'));\n           } else {\n               $(element).empty(); \n           }\n        },\n        \n       activate: function() {\n           this.$input.first().focus();\n       },\n       \n       autosubmit: function() {\n           this.$input.on('keydown', function(e){\n               if (e.which === 13) {\n                   $(this).closest('form').submit();\n               }\n           });\n       }\n    });      \n\n    Checklist.defaults = $.extend({}, $.fn.editabletypes.list.defaults, {\n        /**\n        @property tpl \n        @default <div></div>\n        **/         \n        tpl:'<div class=\"editable-checklist\"></div>',\n        \n        /**\n        @property inputclass \n        @type string\n        @default null\n        **/         \n        inputclass: null,        \n        \n        /**\n        Separator of values when reading from `data-value` attribute\n\n        @property separator \n        @type string\n        @default ','\n        **/         \n        separator: ','\n    });\n\n    $.fn.editabletypes.checklist = Checklist;      \n\n}(window.jQuery));\n\n/**\nHTML5 input types.\nFollowing types are supported:\n\n* password\n* email\n* url\n* tel\n* number\n* range\n* time\n\nLearn more about html5 inputs:  \nhttp://www.w3.org/wiki/HTML5_form_additions  \nTo check browser compatibility please see:  \nhttps://developer.mozilla.org/en-US/docs/HTML/Element/Input\n            \n@class html5types \n@extends text\n@final\n@since 1.3.0\n@example\n<a href=\"#\" id=\"email\" data-type=\"email\" data-pk=\"1\">admin@example.com</a>\n<script>\n$(function(){\n    $('#email').editable({\n        url: '/post',\n        title: 'Enter email'\n    });\n});\n</script>\n**/\n\n/**\n@property tpl \n@default depends on type\n**/ \n\n/*\nPassword\n*/\n(function ($) {\n    \"use strict\";\n    \n    var Password = function (options) {\n        this.init('password', options, Password.defaults);\n    };\n    $.fn.editableutils.inherit(Password, $.fn.editabletypes.text);\n    $.extend(Password.prototype, {\n       //do not display password, show '[hidden]' instead\n       value2html: function(value, element) {\n           if(value) {\n               $(element).text('[hidden]');\n           } else {\n               $(element).empty(); \n           }\n       },\n       //as password not displayed, should not set value by html\n       html2value: function(html) {\n           return null;\n       }       \n    });    \n    Password.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"password\">'\n    });\n    $.fn.editabletypes.password = Password;\n}(window.jQuery));\n\n\n/*\nEmail\n*/\n(function ($) {\n    \"use strict\";\n    \n    var Email = function (options) {\n        this.init('email', options, Email.defaults);\n    };\n    $.fn.editableutils.inherit(Email, $.fn.editabletypes.text);\n    Email.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"email\">'\n    });\n    $.fn.editabletypes.email = Email;\n}(window.jQuery));\n\n\n/*\nUrl\n*/\n(function ($) {\n    \"use strict\";\n    \n    var Url = function (options) {\n        this.init('url', options, Url.defaults);\n    };\n    $.fn.editableutils.inherit(Url, $.fn.editabletypes.text);\n    Url.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"url\">'\n    });\n    $.fn.editabletypes.url = Url;\n}(window.jQuery));\n\n\n/*\nTel\n*/\n(function ($) {\n    \"use strict\";\n    \n    var Tel = function (options) {\n        this.init('tel', options, Tel.defaults);\n    };\n    $.fn.editableutils.inherit(Tel, $.fn.editabletypes.text);\n    Tel.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"tel\">'\n    });\n    $.fn.editabletypes.tel = Tel;\n}(window.jQuery));\n\n\n/*\nNumber\n*/\n(function ($) {\n    \"use strict\";\n    \n    var NumberInput = function (options) {\n        this.init('number', options, NumberInput.defaults);\n    };\n    $.fn.editableutils.inherit(NumberInput, $.fn.editabletypes.text);\n    $.extend(NumberInput.prototype, {\n         render: function () {\n            NumberInput.superclass.render.call(this);\n            this.setAttr('min');\n            this.setAttr('max');\n            this.setAttr('step');\n        },\n        postrender: function() {\n            if(this.$clear) {\n                //increase right ffset  for up/down arrows\n                this.$clear.css({right: 24});\n                /*\n                //can position clear button only here, when form is shown and height can be calculated\n                var h = this.$input.outerHeight(true) || 20,\n                    delta = (h - this.$clear.height()) / 2;\n                \n                //add 12px to offset right for up/down arrows    \n                this.$clear.css({top: delta, right: delta + 16});\n                */\n            } \n        }        \n    });     \n    NumberInput.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"number\">',\n        inputclass: 'input-mini',\n        min: null,\n        max: null,\n        step: null\n    });\n    $.fn.editabletypes.number = NumberInput;\n}(window.jQuery));\n\n\n/*\nRange (inherit from number)\n*/\n(function ($) {\n    \"use strict\";\n    \n    var Range = function (options) {\n        this.init('range', options, Range.defaults);\n    };\n    $.fn.editableutils.inherit(Range, $.fn.editabletypes.number);\n    $.extend(Range.prototype, {\n        render: function () {\n            this.$input = this.$tpl.filter('input');\n            \n            this.setClass();\n            this.setAttr('min');\n            this.setAttr('max');\n            this.setAttr('step');           \n            \n            this.$input.on('input', function(){\n                $(this).siblings('output').text($(this).val()); \n            });  \n        },\n        activate: function() {\n            this.$input.focus();\n        }         \n    });\n    Range.defaults = $.extend({}, $.fn.editabletypes.number.defaults, {\n        tpl: '<input type=\"range\"><output style=\"width: 30px; display: inline-block\"></output>',\n        inputclass: 'input-medium'\n    });\n    $.fn.editabletypes.range = Range;\n}(window.jQuery));\n\n/*\nTime\n*/\n(function ($) {\n    \"use strict\";\n\n    var Time = function (options) {\n        this.init('time', options, Time.defaults);\n    };\n    //inherit from abstract, as inheritance from text gives selection error.\n    $.fn.editableutils.inherit(Time, $.fn.editabletypes.abstractinput);\n    $.extend(Time.prototype, {\n        render: function() {\n           this.setClass();\n        }        \n    });\n    Time.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        tpl: '<input type=\"time\">'\n    });\n    $.fn.editabletypes.time = Time;\n}(window.jQuery));\n\n/**\nSelect2 input. Based on amazing work of Igor Vaynberg https://github.com/ivaynberg/select2.  \nPlease see [original select2 docs](http://ivaynberg.github.com/select2) for detailed description and options.  \n \nYou should manually download and include select2 distributive:  \n\n    <link href=\"select2/select2.css\" rel=\"stylesheet\" type=\"text/css\"></link>  \n    <script src=\"select2/select2.js\"></script>  \n    \nTo make it **bootstrap-styled** you can use css from [here](https://github.com/t0m/select2-bootstrap-css): \n\n    <link href=\"select2-bootstrap.css\" rel=\"stylesheet\" type=\"text/css\"></link>    \n    \n**Note:** currently `autotext` feature does not work for select2 with `ajax` remote source.    \nYou need initially put both `data-value` and element's text youself:    \n\n    <a href=\"#\" data-type=\"select2\" data-value=\"1\">Text1</a>\n    \n    \n@class select2\n@extends abstractinput\n@since 1.4.1\n@final\n@example\n<a href=\"#\" id=\"country\" data-type=\"select2\" data-pk=\"1\" data-value=\"ru\" data-url=\"/post\" data-title=\"Select country\"></a>\n<script>\n$(function(){\n    //local source\n    $('#country').editable({\n        source: [\n              {id: 'gb', text: 'Great Britain'},\n              {id: 'us', text: 'United States'},\n              {id: 'ru', text: 'Russia'}\n           ],\n        select2: {\n           multiple: true\n        }\n    });\n    //remote source (simple)\n    $('#country').editable({\n        source: '/getCountries',\n        select2: {\n            placeholder: 'Select Country',\n            minimumInputLength: 1\n        }\n    });\n    //remote source (advanced)\n    $('#country').editable({\n        select2: {\n            placeholder: 'Select Country',\n            allowClear: true,\n            minimumInputLength: 3,\n            id: function (item) {\n                return item.CountryId;\n            },\n            ajax: {\n                url: '/getCountries',\n                dataType: 'json',\n                data: function (term, page) {\n                    return { query: term };\n                },\n                results: function (data, page) {\n                    return { results: data };\n                }\n            },\n            formatResult: function (item) {\n                return item.CountryName;\n            },\n            formatSelection: function (item) {\n                return item.CountryName;\n            },\n            initSelection: function (element, callback) {\n                return $.get('/getCountryById', { query: element.val() }, function (data) {\n                    callback(data);\n                });\n            } \n        }  \n    });\n});\n</script>\n**/\n(function ($) {\n    \"use strict\";\n    \n    var Constructor = function (options) {\n        this.init('select2', options, Constructor.defaults);\n\n        options.select2 = options.select2 || {};\n\n        this.sourceData = null;\n        \n        //placeholder\n        if(options.placeholder) {\n            options.select2.placeholder = options.placeholder;\n        }\n       \n        //if not `tags` mode, use source\n        if(!options.select2.tags && options.source) {\n            var source = options.source;\n            //if source is function, call it (once!)\n            if ($.isFunction(options.source)) {\n                source = options.source.call(options.scope);\n            }               \n\n            if (typeof source === 'string') {\n                options.select2.ajax = options.select2.ajax || {};\n                //some default ajax params\n                if(!options.select2.ajax.data) {\n                    options.select2.ajax.data = function(term) {return { query:term };};\n                }\n                if(!options.select2.ajax.results) {\n                    options.select2.ajax.results = function(data) { return {results:data };};\n                }\n                options.select2.ajax.url = source;\n            } else {\n                //check format and convert x-editable format to select2 format (if needed)\n                this.sourceData = this.convertSource(source);\n                options.select2.data = this.sourceData;\n            }\n        } \n\n        //overriding objects in config (as by default jQuery extend() is not recursive)\n        this.options.select2 = $.extend({}, Constructor.defaults.select2, options.select2);\n\n        //detect whether it is multi-valued\n        this.isMultiple = this.options.select2.tags || this.options.select2.multiple;\n        this.isRemote = ('ajax' in this.options.select2);\n\n        //store function returning ID of item\n        //should be here as used inautotext for local source\n        this.idFunc = this.options.select2.id;\n        if (typeof(this.idFunc) !== \"function\") {\n            var idKey = this.idFunc || 'id';\n            this.idFunc = function (e) { return e[idKey]; };\n        }\n\n        //store function that renders text in select2\n        this.formatSelection = this.options.select2.formatSelection;\n        if (typeof(this.formatSelection) !== \"function\") {\n            this.formatSelection = function (e) { return e.text; };\n        }\n    };\n\n    $.fn.editableutils.inherit(Constructor, $.fn.editabletypes.abstractinput);\n\n    $.extend(Constructor.prototype, {\n        render: function() {\n            this.setClass();\n\n            //can not apply select2 here as it calls initSelection \n            //over input that does not have correct value yet.\n            //apply select2 only in value2input\n            //this.$input.select2(this.options.select2);\n\n            //when data is loaded via ajax, we need to know when it's done to populate listData\n            if(this.isRemote) {\n                //listen to loaded event to populate data\n                this.$input.on('select2-loaded', $.proxy(function(e) {\n                    this.sourceData = e.items.results;\n                }, this));\n            }\n\n            //trigger resize of editableform to re-position container in multi-valued mode\n            if(this.isMultiple) {\n               this.$input.on('change', function() {\n                   $(this).closest('form').parent().triggerHandler('resize');\n               });\n            }\n       },\n\n       value2html: function(value, element) {\n           var text = '', data,\n               that = this;\n\n           if(this.options.select2.tags) { //in tags mode just assign value\n              data = value; \n              //data = $.fn.editableutils.itemsByValue(value, this.options.select2.tags, this.idFunc);\n           } else if(this.sourceData) {\n              data = $.fn.editableutils.itemsByValue(value, this.sourceData, this.idFunc); \n           } else {\n              //can not get list of possible values \n              //(e.g. autotext for select2 with ajax source)\n           }\n\n           //data may be array (when multiple values allowed)\n           if($.isArray(data)) {\n               //collect selected data and show with separator\n               text = [];\n               $.each(data, function(k, v){\n                   text.push(v && typeof v === 'object' ? that.formatSelection(v) : v);\n               });\n           } else if(data) {\n               text = that.formatSelection(data);\n           }\n\n           text = $.isArray(text) ? text.join(this.options.viewseparator) : text;\n\n           //$(element).text(text);\n           Constructor.superclass.value2html.call(this, text, element); \n       },\n\n       html2value: function(html) {\n           return this.options.select2.tags ? this.str2value(html, this.options.viewseparator) : null;\n       },\n\n       value2input: function(value) {\n           // if value array => join it anyway\n           if($.isArray(value)) {\n              value = value.join(this.getSeparator());\n           }\n\n           //for remote source just set value, text is updated by initSelection\n           if(!this.$input.data('select2')) {\n               this.$input.val(value);\n               this.$input.select2(this.options.select2);\n           } else {\n               //second argument needed to separate initial change from user's click (for autosubmit)   \n               this.$input.val(value).trigger('change', true); \n\n               //Uncaught Error: cannot call val() if initSelection() is not defined\n               //this.$input.select2('val', value);\n           }\n\n           // if defined remote source AND no multiple mode AND no user's initSelection provided --> \n           // we should somehow get text for provided id.\n           // The solution is to use element's text as text for that id (exclude empty)\n           if(this.isRemote && !this.isMultiple && !this.options.select2.initSelection) {\n               // customId and customText are methods to extract `id` and `text` from data object\n               // we can use this workaround only if user did not define these methods\n               // otherwise we cant construct data object\n               var customId = this.options.select2.id,\n                   customText = this.options.select2.formatSelection;\n\n               if(!customId && !customText) {\n                   var $el = $(this.options.scope);\n                   if (!$el.data('editable').isEmpty) {\n                       var data = {id: value, text: $el.text()};\n                       this.$input.select2('data', data); \n                   }\n               }\n           }\n       },\n       \n       input2value: function() { \n           return this.$input.select2('val');\n       },\n\n       str2value: function(str, separator) {\n            if(typeof str !== 'string' || !this.isMultiple) {\n                return str;\n            }\n\n            separator = separator || this.getSeparator();\n\n            var val, i, l;\n\n            if (str === null || str.length < 1) {\n                return null;\n            }\n            val = str.split(separator);\n            for (i = 0, l = val.length; i < l; i = i + 1) {\n                val[i] = $.trim(val[i]);\n            }\n\n            return val;\n       },\n\n        autosubmit: function() {\n            this.$input.on('change', function(e, isInitial){\n                if(!isInitial) {\n                  $(this).closest('form').submit();\n                }\n            });\n        },\n\n        getSeparator: function() {\n            return this.options.select2.separator || $.fn.select2.defaults.separator;\n        },\n\n        /*\n        Converts source from x-editable format: {value: 1, text: \"1\"} to\n        select2 format: {id: 1, text: \"1\"}\n        */\n        convertSource: function(source) {\n            if($.isArray(source) && source.length && source[0].value !== undefined) {\n                for(var i = 0; i<source.length; i++) {\n                    if(source[i].value !== undefined) {\n                        source[i].id = source[i].value;\n                        delete source[i].value;\n                    }\n                }\n            }\n            return source;\n        },\n        \n        destroy: function() {\n            if(this.$input.data('select2')) {\n                this.$input.select2('destroy');\n            }\n        }\n        \n    });\n\n    Constructor.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <input type=\"hidden\">\n        **/\n        tpl:'<input type=\"hidden\">',\n        /**\n        Configuration of select2. [Full list of options](http://ivaynberg.github.com/select2).\n\n        @property select2 \n        @type object\n        @default null\n        **/\n        select2: null,\n        /**\n        Placeholder attribute of select\n\n        @property placeholder \n        @type string\n        @default null\n        **/\n        placeholder: null,\n        /**\n        Source data for select. It will be assigned to select2 `data` property and kept here just for convenience.\n        Please note, that format is different from simple `select` input: use 'id' instead of 'value'.\n        E.g. `[{id: 1, text: \"text1\"}, {id: 2, text: \"text2\"}, ...]`.\n\n        @property source \n        @type array|string|function\n        @default null        \n        **/\n        source: null,\n        /**\n        Separator used to display tags.\n\n        @property viewseparator \n        @type string\n        @default ', '        \n        **/\n        viewseparator: ', '\n    });\n\n    $.fn.editabletypes.select2 = Constructor;\n\n}(window.jQuery));\n\n/**\n* Combodate - 1.0.5\n* Dropdown date and time picker.\n* Converts text input into dropdowns to pick day, month, year, hour, minute and second.\n* Uses momentjs as datetime library http://momentjs.com.\n* For i18n include corresponding file from https://github.com/timrwood/moment/tree/master/lang \n*\n* Confusion at noon and midnight - see http://en.wikipedia.org/wiki/12-hour_clock#Confusion_at_noon_and_midnight\n* In combodate: \n* 12:00 pm --> 12:00 (24-h format, midday)\n* 12:00 am --> 00:00 (24-h format, midnight, start of day)\n* \n* Differs from momentjs parse rules:\n* 00:00 pm, 12:00 pm --> 12:00 (24-h format, day not change)\n* 00:00 am, 12:00 am --> 00:00 (24-h format, day not change)\n* \n* \n* Author: Vitaliy Potapov\n* Project page: http://github.com/vitalets/combodate\n* Copyright (c) 2012 Vitaliy Potapov. Released under MIT License.\n**/\n(function ($) {\n\n    var Combodate = function (element, options) {\n        this.$element = $(element);\n        if(!this.$element.is('input')) {\n            $.error('Combodate should be applied to INPUT element');\n            return;\n        }\n        this.options = $.extend({}, $.fn.combodate.defaults, options, this.$element.data());\n        this.init();  \n     };\n\n    Combodate.prototype = {\n        constructor: Combodate, \n        init: function () {\n            this.map = {\n                //key   regexp    moment.method\n                day:    ['D',    'date'], \n                month:  ['M',    'month'], \n                year:   ['Y',    'year'], \n                hour:   ['[Hh]', 'hours'],\n                minute: ['m',    'minutes'], \n                second: ['s',    'seconds'],\n                ampm:   ['[Aa]', ''] \n            };\n            \n            this.$widget = $('<span class=\"combodate\"></span>').html(this.getTemplate());\n                      \n            this.initCombos();\n            \n            //update original input on change \n            this.$widget.on('change', 'select', $.proxy(function(e) {\n                this.$element.val(this.getValue()).change();\n                // update days count if month or year changes\n                if (this.options.smartDays) {\n                    if ($(e.target).is('.month') || $(e.target).is('.year')) {\n                        this.fillCombo('day');\n                    }\n                }\n            }, this));\n            \n            this.$widget.find('select').css('width', 'auto');\n                                       \n            // hide original input and insert widget                                       \n            this.$element.hide().after(this.$widget);\n            \n            // set initial value\n            this.setValue(this.$element.val() || this.options.value);\n        },\n        \n        /*\n         Replace tokens in template with <select> elements \n        */         \n        getTemplate: function() {\n            var tpl = this.options.template;\n\n            //first pass\n            $.each(this.map, function(k, v) {\n                v = v[0]; \n                var r = new RegExp(v+'+'),\n                    token = v.length > 1 ? v.substring(1, 2) : v;\n                    \n                tpl = tpl.replace(r, '{'+token+'}');\n            });\n\n            //replace spaces with &nbsp;\n            tpl = tpl.replace(/ /g, '&nbsp;');\n\n            //second pass\n            $.each(this.map, function(k, v) {\n                v = v[0];\n                var token = v.length > 1 ? v.substring(1, 2) : v;\n                    \n                tpl = tpl.replace('{'+token+'}', '<select class=\"'+k+'\"></select>');\n            });   \n\n            return tpl;\n        },\n        \n        /*\n         Initialize combos that presents in template \n        */        \n        initCombos: function() {\n            for (var k in this.map) {\n                var $c = this.$widget.find('.'+k);\n                // set properties like this.$day, this.$month etc.\n                this['$'+k] = $c.length ? $c : null;\n                // fill with items\n                this.fillCombo(k);\n            }\n        },\n\n        /*\n         Fill combo with items \n        */        \n        fillCombo: function(k) {\n            var $combo = this['$'+k];\n            if (!$combo) {\n                return;\n            }\n\n            // define method name to fill items, e.g `fillDays`\n            var f = 'fill' + k.charAt(0).toUpperCase() + k.slice(1); \n            var items = this[f]();\n            var value = $combo.val();\n\n            $combo.empty();\n            for(var i=0; i<items.length; i++) {\n                $combo.append('<option value=\"'+items[i][0]+'\">'+items[i][1]+'</option>');\n            }\n\n            $combo.val(value);\n        },\n\n        /*\n         Initialize items of combos. Handles `firstItem` option \n        */\n        fillCommon: function(key) {\n            var values = [],\n                relTime;\n                \n            if(this.options.firstItem === 'name') {\n                //need both to support moment ver < 2 and  >= 2\n                relTime = moment.relativeTime || moment.langData()._relativeTime; \n                var header = typeof relTime[key] === 'function' ? relTime[key](1, true, key, false) : relTime[key];\n                //take last entry (see momentjs lang files structure) \n                header = header.split(' ').reverse()[0];                \n                values.push(['', header]);\n            } else if(this.options.firstItem === 'empty') {\n                values.push(['', '']);\n            }\n            return values;\n        },  \n\n\n        /*\n        fill day\n        */\n        fillDay: function() {\n            var items = this.fillCommon('d'), name, i,\n                twoDigit = this.options.template.indexOf('DD') !== -1,\n                daysCount = 31;\n\n            // detect days count (depends on month and year)\n            // originally https://github.com/vitalets/combodate/pull/7\n            if (this.options.smartDays && this.$month && this.$year) {\n                var month = parseInt(this.$month.val(), 10);\n                var year = parseInt(this.$year.val(), 10);\n\n                if (!isNaN(month) && !isNaN(year)) {\n                    daysCount = moment([year, month]).daysInMonth();\n                }\n            }\n\n            for (i = 1; i <= daysCount; i++) {\n                name = twoDigit ? this.leadZero(i) : i;\n                items.push([i, name]);\n            }\n            return items;        \n        },\n        \n        /*\n        fill month\n        */\n        fillMonth: function() {\n            var items = this.fillCommon('M'), name, i, \n                longNames = this.options.template.indexOf('MMMM') !== -1,\n                shortNames = this.options.template.indexOf('MMM') !== -1,\n                twoDigit = this.options.template.indexOf('MM') !== -1;\n                \n            for(i=0; i<=11; i++) {\n                if(longNames) {\n                    //see https://github.com/timrwood/momentjs.com/pull/36\n                    name = moment().date(1).month(i).format('MMMM');\n                } else if(shortNames) {\n                    name = moment().date(1).month(i).format('MMM');\n                } else if(twoDigit) {\n                    name = this.leadZero(i+1);\n                } else {\n                    name = i+1;\n                }\n                items.push([i, name]);\n            } \n            return items;\n        },  \n        \n        /*\n        fill year\n        */\n        fillYear: function() {\n            var items = [], name, i, \n                longNames = this.options.template.indexOf('YYYY') !== -1;\n           \n            for(i=this.options.maxYear; i>=this.options.minYear; i--) {\n                name = longNames ? i : (i+'').substring(2);\n                items[this.options.yearDescending ? 'push' : 'unshift']([i, name]);\n            }\n            \n            items = this.fillCommon('y').concat(items);\n            \n            return items;              \n        },    \n        \n        /*\n        fill hour\n        */\n        fillHour: function() {\n            var items = this.fillCommon('h'), name, i,\n                h12 = this.options.template.indexOf('h') !== -1,\n                h24 = this.options.template.indexOf('H') !== -1,\n                twoDigit = this.options.template.toLowerCase().indexOf('hh') !== -1,\n                min = h12 ? 1 : 0, \n                max = h12 ? 12 : 23;\n                \n            for(i=min; i<=max; i++) {\n                name = twoDigit ? this.leadZero(i) : i;\n                items.push([i, name]);\n            } \n            return items;                 \n        },    \n        \n        /*\n        fill minute\n        */\n        fillMinute: function() {\n            var items = this.fillCommon('m'), name, i,\n                twoDigit = this.options.template.indexOf('mm') !== -1;\n\n            for(i=0; i<=59; i+= this.options.minuteStep) {\n                name = twoDigit ? this.leadZero(i) : i;\n                items.push([i, name]);\n            }    \n            return items;              \n        },  \n        \n        /*\n        fill second\n        */\n        fillSecond: function() {\n            var items = this.fillCommon('s'), name, i,\n                twoDigit = this.options.template.indexOf('ss') !== -1;\n\n            for(i=0; i<=59; i+= this.options.secondStep) {\n                name = twoDigit ? this.leadZero(i) : i;\n                items.push([i, name]);\n            }    \n            return items;              \n        },  \n        \n        /*\n        fill ampm\n        */\n        fillAmpm: function() {\n            var ampmL = this.options.template.indexOf('a') !== -1,\n                ampmU = this.options.template.indexOf('A') !== -1,            \n                items = [\n                    ['am', ampmL ? 'am' : 'AM'],\n                    ['pm', ampmL ? 'pm' : 'PM']\n                ];\n            return items;                              \n        },                                       \n\n        /*\n         Returns current date value from combos. \n         If format not specified - `options.format` used.\n         If format = `null` - Moment object returned.\n        */\n        getValue: function(format) {\n            var dt, values = {}, \n                that = this,\n                notSelected = false;\n                \n            //getting selected values    \n            $.each(this.map, function(k, v) {\n                if(k === 'ampm') {\n                    return;\n                }\n                var def = k === 'day' ? 1 : 0;\n                  \n                values[k] = that['$'+k] ? parseInt(that['$'+k].val(), 10) : def; \n                \n                if(isNaN(values[k])) {\n                   notSelected = true;\n                   return false; \n                }\n            });\n            \n            //if at least one visible combo not selected - return empty string\n            if(notSelected) {\n               return '';\n            }\n            \n            //convert hours 12h --> 24h \n            if(this.$ampm) {\n                //12:00 pm --> 12:00 (24-h format, midday), 12:00 am --> 00:00 (24-h format, midnight, start of day)\n                if(values.hour === 12) {\n                    values.hour = this.$ampm.val() === 'am' ? 0 : 12;                    \n                } else {\n                    values.hour = this.$ampm.val() === 'am' ? values.hour : values.hour+12;\n                }\n            }    \n            \n            dt = moment([values.year, values.month, values.day, values.hour, values.minute, values.second]);\n            \n            //highlight invalid date\n            this.highlight(dt);\n                              \n            format = format === undefined ? this.options.format : format;\n            if(format === null) {\n               return dt.isValid() ? dt : null; \n            } else {\n               return dt.isValid() ? dt.format(format) : ''; \n            }           \n        },\n        \n        setValue: function(value) {\n            if(!value) {\n                return;\n            }\n            \n            var dt = typeof value === 'string' ? moment(value, this.options.format) : moment(value),\n                that = this,\n                values = {};\n            \n            //function to find nearest value in select options\n            function getNearest($select, value) {\n                var delta = {};\n                $select.children('option').each(function(i, opt){\n                    var optValue = $(opt).attr('value'),\n                    distance;\n\n                    if(optValue === '') return;\n                    distance = Math.abs(optValue - value); \n                    if(typeof delta.distance === 'undefined' || distance < delta.distance) {\n                        delta = {value: optValue, distance: distance};\n                    } \n                }); \n                return delta.value;\n            }             \n            \n            if(dt.isValid()) {\n                //read values from date object\n                $.each(this.map, function(k, v) {\n                    if(k === 'ampm') {\n                       return; \n                    }\n                    values[k] = dt[v[1]]();\n                });\n               \n                if(this.$ampm) {\n                    //12:00 pm --> 12:00 (24-h format, midday), 12:00 am --> 00:00 (24-h format, midnight, start of day)\n                    if(values.hour >= 12) {\n                        values.ampm = 'pm';\n                        if(values.hour > 12) {\n                            values.hour -= 12;\n                        }\n                    } else {\n                        values.ampm = 'am';\n                        if(values.hour === 0) {\n                            values.hour = 12;\n                        }\n                    } \n                }\n               \n                $.each(values, function(k, v) {\n                    //call val() for each existing combo, e.g. this.$hour.val()\n                    if(that['$'+k]) {\n                       \n                        if(k === 'minute' && that.options.minuteStep > 1 && that.options.roundTime) {\n                           v = getNearest(that['$'+k], v);\n                        }\n                       \n                        if(k === 'second' && that.options.secondStep > 1 && that.options.roundTime) {\n                           v = getNearest(that['$'+k], v);\n                        }                       \n                       \n                        that['$'+k].val(v);\n                    }\n                });\n\n                // update days count\n                if (this.options.smartDays) {\n                    this.fillCombo('day');\n                }\n               \n               this.$element.val(dt.format(this.options.format)).change();\n            }\n        },\n        \n        /*\n         highlight combos if date is invalid\n        */\n        highlight: function(dt) {\n            if(!dt.isValid()) {\n                if(this.options.errorClass) {\n                    this.$widget.addClass(this.options.errorClass);\n                } else {\n                    //store original border color\n                    if(!this.borderColor) {\n                        this.borderColor = this.$widget.find('select').css('border-color'); \n                    }\n                    this.$widget.find('select').css('border-color', 'red');\n                } \n            } else {\n                if(this.options.errorClass) {\n                    this.$widget.removeClass(this.options.errorClass);\n                } else {\n                    this.$widget.find('select').css('border-color', this.borderColor);\n                }  \n            }\n        },\n        \n        leadZero: function(v) {\n            return v <= 9 ? '0' + v : v; \n        },\n        \n        destroy: function() {\n            this.$widget.remove();\n            this.$element.removeData('combodate').show();\n        }\n        \n        //todo: clear method        \n    };\n\n    $.fn.combodate = function ( option ) {\n        var d, args = Array.apply(null, arguments);\n        args.shift();\n\n        //getValue returns date as string / object (not jQuery object)\n        if(option === 'getValue' && this.length && (d = this.eq(0).data('combodate'))) {\n          return d.getValue.apply(d, args);\n        }        \n        \n        return this.each(function () {\n            var $this = $(this),\n            data = $this.data('combodate'),\n            options = typeof option == 'object' && option;\n            if (!data) {\n                $this.data('combodate', (data = new Combodate(this, options)));\n            }\n            if (typeof option == 'string' && typeof data[option] == 'function') {\n                data[option].apply(data, args);\n            }\n        });\n    };  \n    \n    $.fn.combodate.defaults = {\n         //in this format value stored in original input\n        format: 'DD-MM-YYYY HH:mm',      \n        //in this format items in dropdowns are displayed\n        template: 'D / MMM / YYYY   H : mm',\n        //initial value, can be `new Date()`    \n        value: null,                       \n        minYear: 1970,\n        maxYear: 2015,\n        yearDescending: true,\n        minuteStep: 5,\n        secondStep: 1,\n        firstItem: 'empty', //'name', 'empty', 'none'\n        errorClass: null,\n        roundTime: true, // whether to round minutes and seconds if step > 1\n        smartDays: false // whether days in combo depend on selected month: 31, 30, 28\n    };\n\n}(window.jQuery));\n/**\nCombodate input - dropdown date and time picker.    \nBased on [combodate](http://vitalets.github.com/combodate) plugin (included). To use it you should manually include [momentjs](http://momentjs.com).\n\n    <script src=\"js/moment.min.js\"></script>\n   \nAllows to input:\n\n* only date\n* only time \n* both date and time  \n\nPlease note, that format is taken from momentjs and **not compatible** with bootstrap-datepicker / jquery UI datepicker.  \nInternally value stored as `momentjs` object. \n\n@class combodate\n@extends abstractinput\n@final\n@since 1.4.0\n@example\n<a href=\"#\" id=\"dob\" data-type=\"combodate\" data-pk=\"1\" data-url=\"/post\" data-value=\"1984-05-15\" data-title=\"Select date\"></a>\n<script>\n$(function(){\n    $('#dob').editable({\n        format: 'YYYY-MM-DD',    \n        viewformat: 'DD.MM.YYYY',    \n        template: 'D / MMMM / YYYY',    \n        combodate: {\n                minYear: 2000,\n                maxYear: 2015,\n                minuteStep: 1\n           }\n        }\n    });\n});\n</script>\n**/\n\n/*global moment*/\n\n(function ($) {\n    \"use strict\";\n    \n    var Constructor = function (options) {\n        this.init('combodate', options, Constructor.defaults);\n        \n        //by default viewformat equals to format\n        if(!this.options.viewformat) {\n            this.options.viewformat = this.options.format;\n        }        \n        \n        //try parse combodate config defined as json string in data-combodate\n        options.combodate = $.fn.editableutils.tryParseJson(options.combodate, true);\n\n        //overriding combodate config (as by default jQuery extend() is not recursive)\n        this.options.combodate = $.extend({}, Constructor.defaults.combodate, options.combodate, {\n            format: this.options.format,\n            template: this.options.template\n        });\n    };\n\n    $.fn.editableutils.inherit(Constructor, $.fn.editabletypes.abstractinput);    \n    \n    $.extend(Constructor.prototype, {\n        render: function () {\n            this.$input.combodate(this.options.combodate);\n                    \n            if($.fn.editableform.engine === 'bs3') {\n                this.$input.siblings().find('select').addClass('form-control');\n            }\n            \n            if(this.options.inputclass) {\n                this.$input.siblings().find('select').addClass(this.options.inputclass);\n            }            \n            //\"clear\" link\n            /*\n            if(this.options.clear) {\n                this.$clear = $('<a href=\"#\"></a>').html(this.options.clear).click($.proxy(function(e){\n                    e.preventDefault();\n                    e.stopPropagation();\n                    this.clear();\n                }, this));\n                \n                this.$tpl.parent().append($('<div class=\"editable-clear\">').append(this.$clear));  \n            } \n            */               \n        },\n        \n        value2html: function(value, element) {\n            var text = value ? value.format(this.options.viewformat) : '';\n            //$(element).text(text);\n            Constructor.superclass.value2html.call(this, text, element);  \n        },\n\n        html2value: function(html) {\n            return html ? moment(html, this.options.viewformat) : null;\n        },   \n        \n        value2str: function(value) {\n            return value ? value.format(this.options.format) : '';\n       }, \n       \n       str2value: function(str) {\n           return str ? moment(str, this.options.format) : null;\n       }, \n       \n       value2submit: function(value) {\n           return this.value2str(value);\n       },                    \n\n       value2input: function(value) {\n           this.$input.combodate('setValue', value);\n       },\n        \n       input2value: function() { \n           return this.$input.combodate('getValue', null);\n       },       \n       \n       activate: function() {\n           this.$input.siblings('.combodate').find('select').eq(0).focus();\n       },\n       \n       /*\n       clear:  function() {\n          this.$input.data('datepicker').date = null;\n          this.$input.find('.active').removeClass('active');\n       },\n       */\n       \n       autosubmit: function() {\n           \n       }\n\n    });\n    \n    Constructor.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <input type=\"text\">\n        **/         \n        tpl:'<input type=\"text\">',\n        /**\n        @property inputclass \n        @default null\n        **/         \n        inputclass: null,\n        /**\n        Format used for sending value to server. Also applied when converting date from <code>data-value</code> attribute.<br>\n        See list of tokens in [momentjs docs](http://momentjs.com/docs/#/parsing/string-format)  \n        \n        @property format \n        @type string\n        @default YYYY-MM-DD\n        **/         \n        format:'YYYY-MM-DD',\n        /**\n        Format used for displaying date. Also applied when converting date from element's text on init.   \n        If not specified equals to `format`.\n        \n        @property viewformat \n        @type string\n        @default null\n        **/          \n        viewformat: null,        \n        /**\n        Template used for displaying dropdowns.\n        \n        @property template \n        @type string\n        @default D / MMM / YYYY\n        **/          \n        template: 'D / MMM / YYYY',  \n        /**\n        Configuration of combodate.\n        Full list of options: http://vitalets.github.com/combodate/#docs\n        \n        @property combodate \n        @type object\n        @default null\n        **/\n        combodate: null\n        \n        /*\n        (not implemented yet)\n        Text shown as clear date button. \n        If <code>false</code> clear button will not be rendered.\n        \n        @property clear \n        @type boolean|string\n        @default 'x clear'         \n        */\n        //clear: '&times; clear'\n    });   \n\n    $.fn.editabletypes.combodate = Constructor;\n\n}(window.jQuery));\n\n/*\nEditableform based on Twitter Bootstrap 3\n*/\n(function ($) {\n    \"use strict\";\n    \n    //store parent methods\n    var pInitInput = $.fn.editableform.Constructor.prototype.initInput;\n    \n    $.extend($.fn.editableform.Constructor.prototype, {\n        initTemplate: function() {\n            this.$form = $($.fn.editableform.template); \n            this.$form.find('.control-group').addClass('form-group');\n            this.$form.find('.editable-error-block').addClass('help-block');\n        },\n        initInput: function() {  \n            pInitInput.apply(this);\n\n            //for bs3 set default class `input-sm` to standard inputs\n            var emptyInputClass = this.input.options.inputclass === null || this.input.options.inputclass === false;\n            var defaultClass = 'input-sm';\n            \n            //bs3 add `form-control` class to standard inputs\n            var stdtypes = 'text,select,textarea,password,email,url,tel,number,range,time,typeaheadjs'.split(','); \n            if(~$.inArray(this.input.type, stdtypes)) {\n                this.input.$input.addClass('form-control');\n                if(emptyInputClass) {\n                    this.input.options.inputclass = defaultClass;\n                    this.input.$input.addClass(defaultClass);\n                }\n            }             \n        \n            //apply bs3 size class also to buttons (to fit size of control)\n            var $btn = this.$form.find('.editable-buttons');\n            var classes = emptyInputClass ? [defaultClass] : this.input.options.inputclass.split(' ');\n            for(var i=0; i<classes.length; i++) {\n                // `btn-sm` is default now\n                /*\n                if(classes[i].toLowerCase() === 'input-sm') { \n                    $btn.find('button').addClass('btn-sm');  \n                }\n                */\n                if(classes[i].toLowerCase() === 'input-lg') {\n                    $btn.find('button').removeClass('btn-sm').addClass('btn-lg'); \n                }\n            }\n        }\n    });    \n    \n    //buttons\n    $.fn.editableform.buttons = \n      '<button type=\"submit\" class=\"btn btn-primary btn-sm editable-submit\">'+\n        '<i class=\"glyphicon glyphicon-ok\"></i>'+\n      '</button>'+\n      '<button type=\"button\" class=\"btn btn-default btn-sm editable-cancel\">'+\n        '<i class=\"glyphicon glyphicon-remove\"></i>'+\n      '</button>';         \n    \n    //error classes\n    $.fn.editableform.errorGroupClass = 'has-error';\n    $.fn.editableform.errorBlockClass = null;  \n    //engine\n    $.fn.editableform.engine = 'bs3';  \n}(window.jQuery));\n/**\n* Editable Popover3 (for Bootstrap 3) \n* ---------------------\n* requires bootstrap-popover.js\n*/\n(function ($) {\n    \"use strict\";\n\n    //extend methods\n    $.extend($.fn.editableContainer.Popup.prototype, {\n        containerName: 'popover',\n        containerDataName: 'bs.popover',\n        innerCss: '.popover-content',\n        defaults: $.fn.popover.Constructor.DEFAULTS,\n\n        initContainer: function(){\n            $.extend(this.containerOptions, {\n                trigger: 'manual',\n                selector: false,\n                content: ' ',\n                template: this.defaults.template\n            });\n            \n            //as template property is used in inputs, hide it from popover\n            var t;\n            if(this.$element.data('template')) {\n               t = this.$element.data('template');\n               this.$element.removeData('template');  \n            } \n            \n            this.call(this.containerOptions);\n            \n            if(t) {\n               //restore data('template')\n               this.$element.data('template', t); \n            }\n        }, \n        \n        /* show */\n        innerShow: function () {\n            this.call('show');                \n        },  \n        \n        /* hide */\n        innerHide: function () {\n            this.call('hide');       \n        }, \n        \n        /* destroy */\n        innerDestroy: function() {\n            this.call('destroy');\n        },                               \n        \n        setContainerOption: function(key, value) {\n            this.container().options[key] = value; \n        },               \n\n        /**\n        * move popover to new position. This function mainly copied from bootstrap-popover.\n        */\n        /*jshint laxcomma: true, eqeqeq: false*/\n        setPosition: function () { \n\n            (function() {\n            /*    \n                var $tip = this.tip()\n                , inside\n                , pos\n                , actualWidth\n                , actualHeight\n                , placement\n                , tp\n                , tpt\n                , tpb\n                , tpl\n                , tpr;\n\n                placement = typeof this.options.placement === 'function' ?\n                this.options.placement.call(this, $tip[0], this.$element[0]) :\n                this.options.placement;\n\n                inside = /in/.test(placement);\n               \n                $tip\n              //  .detach()\n              //vitalets: remove any placement class because otherwise they dont influence on re-positioning of visible popover\n                .removeClass('top right bottom left')\n                .css({ top: 0, left: 0, display: 'block' });\n              //  .insertAfter(this.$element);\n               \n                pos = this.getPosition(inside);\n\n                actualWidth = $tip[0].offsetWidth;\n                actualHeight = $tip[0].offsetHeight;\n\n                placement = inside ? placement.split(' ')[1] : placement;\n\n                tpb = {top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2};\n                tpt = {top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2};\n                tpl = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth};\n                tpr = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width};\n\n                switch (placement) {\n                    case 'bottom':\n                        if ((tpb.top + actualHeight) > ($(window).scrollTop() + $(window).height())) {\n                            if (tpt.top > $(window).scrollTop()) {\n                                placement = 'top';\n                            } else if ((tpr.left + actualWidth) < ($(window).scrollLeft() + $(window).width())) {\n                                placement = 'right';\n                            } else if (tpl.left > $(window).scrollLeft()) {\n                                placement = 'left';\n                            } else {\n                                placement = 'right';\n                            }\n                        }\n                        break;\n                    case 'top':\n                        if (tpt.top < $(window).scrollTop()) {\n                            if ((tpb.top + actualHeight) < ($(window).scrollTop() + $(window).height())) {\n                                placement = 'bottom';\n                            } else if ((tpr.left + actualWidth) < ($(window).scrollLeft() + $(window).width())) {\n                                placement = 'right';\n                            } else if (tpl.left > $(window).scrollLeft()) {\n                                placement = 'left';\n                            } else {\n                                placement = 'right';\n                            }\n                        }\n                        break;\n                    case 'left':\n                        if (tpl.left < $(window).scrollLeft()) {\n                            if ((tpr.left + actualWidth) < ($(window).scrollLeft() + $(window).width())) {\n                                placement = 'right';\n                            } else if (tpt.top > $(window).scrollTop()) {\n                                placement = 'top';\n                            } else if (tpt.top > $(window).scrollTop()) {\n                                placement = 'bottom';\n                            } else {\n                                placement = 'right';\n                            }\n                        }\n                        break;\n                    case 'right':\n                        if ((tpr.left + actualWidth) > ($(window).scrollLeft() + $(window).width())) {\n                            if (tpl.left > $(window).scrollLeft()) {\n                                placement = 'left';\n                            } else if (tpt.top > $(window).scrollTop()) {\n                                placement = 'top';\n                            } else if (tpt.top > $(window).scrollTop()) {\n                                placement = 'bottom';\n                            }\n                        }\n                        break;\n                }\n\n                switch (placement) {\n                    case 'bottom':\n                        tp = tpb;\n                        break;\n                    case 'top':\n                        tp = tpt;\n                        break;\n                    case 'left':\n                        tp = tpl;\n                        break;\n                    case 'right':\n                        tp = tpr;\n                        break;\n                }\n\n                $tip\n                .offset(tp)\n                .addClass(placement)\n                .addClass('in');\n           */\n                     \n           \n            var $tip = this.tip();\n            \n            var placement = typeof this.options.placement == 'function' ?\n                this.options.placement.call(this, $tip[0], this.$element[0]) :\n                this.options.placement;            \n\n            var autoToken = /\\s?auto?\\s?/i;\n            var autoPlace = autoToken.test(placement);\n            if (autoPlace) {\n                placement = placement.replace(autoToken, '') || 'top';\n            }\n            \n            \n            var pos = this.getPosition();\n            var actualWidth = $tip[0].offsetWidth;\n            var actualHeight = $tip[0].offsetHeight;\n\n            if (autoPlace) {\n                var $parent = this.$element.parent();\n\n                var orgPlacement = placement;\n                var docScroll    = document.documentElement.scrollTop || document.body.scrollTop;\n                var parentWidth  = this.options.container == 'body' ? window.innerWidth  : $parent.outerWidth();\n                var parentHeight = this.options.container == 'body' ? window.innerHeight : $parent.outerHeight();\n                var parentLeft   = this.options.container == 'body' ? 0 : $parent.offset().left;\n\n                placement = placement == 'bottom' && pos.top   + pos.height  + actualHeight - docScroll > parentHeight  ? 'top'    :\n                            placement == 'top'    && pos.top   - docScroll   - actualHeight < 0                         ? 'bottom' :\n                            placement == 'right'  && pos.right + actualWidth > parentWidth                              ? 'left'   :\n                            placement == 'left'   && pos.left  - actualWidth < parentLeft                               ? 'right'  :\n                            placement;\n\n                $tip\n                  .removeClass(orgPlacement)\n                  .addClass(placement);\n            }\n\n\n            var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);\n\n            this.applyPlacement(calculatedOffset, placement);            \n                     \n                \n            }).call(this.container());\n          /*jshint laxcomma: false, eqeqeq: true*/  \n        }            \n    });\n\n}(window.jQuery));\n\n/* =========================================================\n * bootstrap-datepicker.js\n * http://www.eyecon.ro/bootstrap-datepicker\n * =========================================================\n * Copyright 2012 Stefan Petre\n * Improvements by Andrew Rowls\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ========================================================= */\n\n(function( $ ) {\n\n\tfunction UTCDate(){\n\t\treturn new Date(Date.UTC.apply(Date, arguments));\n\t}\n\tfunction UTCToday(){\n\t\tvar today = new Date();\n\t\treturn UTCDate(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate());\n\t}\n\n\t// Picker object\n\n\tvar Datepicker = function(element, options) {\n\t\tvar that = this;\n\n\t\tthis._process_options(options);\n\n\t\tthis.element = $(element);\n\t\tthis.isInline = false;\n\t\tthis.isInput = this.element.is('input');\n\t\tthis.component = this.element.is('.date') ? this.element.find('.add-on, .btn') : false;\n\t\tthis.hasInput = this.component && this.element.find('input').length;\n\t\tif(this.component && this.component.length === 0)\n\t\t\tthis.component = false;\n\n\t\tthis.picker = $(DPGlobal.template);\n\t\tthis._buildEvents();\n\t\tthis._attachEvents();\n\n\t\tif(this.isInline) {\n\t\t\tthis.picker.addClass('datepicker-inline').appendTo(this.element);\n\t\t} else {\n\t\t\tthis.picker.addClass('datepicker-dropdown dropdown-menu');\n\t\t}\n\n\t\tif (this.o.rtl){\n\t\t\tthis.picker.addClass('datepicker-rtl');\n\t\t\tthis.picker.find('.prev i, .next i')\n\t\t\t\t\t\t.toggleClass('icon-arrow-left icon-arrow-right');\n\t\t}\n\n\n\t\tthis.viewMode = this.o.startView;\n\n\t\tif (this.o.calendarWeeks)\n\t\t\tthis.picker.find('tfoot th.today')\n\t\t\t\t\t\t.attr('colspan', function(i, val){\n\t\t\t\t\t\t\treturn parseInt(val) + 1;\n\t\t\t\t\t\t});\n\n\t\tthis._allow_update = false;\n\n\t\tthis.setStartDate(this.o.startDate);\n\t\tthis.setEndDate(this.o.endDate);\n\t\tthis.setDaysOfWeekDisabled(this.o.daysOfWeekDisabled);\n\n\t\tthis.fillDow();\n\t\tthis.fillMonths();\n\n\t\tthis._allow_update = true;\n\n\t\tthis.update();\n\t\tthis.showMode();\n\n\t\tif(this.isInline) {\n\t\t\tthis.show();\n\t\t}\n\t};\n\n\tDatepicker.prototype = {\n\t\tconstructor: Datepicker,\n\n\t\t_process_options: function(opts){\n\t\t\t// Store raw options for reference\n\t\t\tthis._o = $.extend({}, this._o, opts);\n\t\t\t// Processed options\n\t\t\tvar o = this.o = $.extend({}, this._o);\n\n\t\t\t// Check if \"de-DE\" style date is available, if not language should\n\t\t\t// fallback to 2 letter code eg \"de\"\n\t\t\tvar lang = o.language;\n\t\t\tif (!dates[lang]) {\n\t\t\t\tlang = lang.split('-')[0];\n\t\t\t\tif (!dates[lang])\n\t\t\t\t\tlang = defaults.language;\n\t\t\t}\n\t\t\to.language = lang;\n\n\t\t\tswitch(o.startView){\n\t\t\t\tcase 2:\n\t\t\t\tcase 'decade':\n\t\t\t\t\to.startView = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\tcase 'year':\n\t\t\t\t\to.startView = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\to.startView = 0;\n\t\t\t}\n\n\t\t\tswitch (o.minViewMode) {\n\t\t\t\tcase 1:\n\t\t\t\tcase 'months':\n\t\t\t\t\to.minViewMode = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tcase 'years':\n\t\t\t\t\to.minViewMode = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\to.minViewMode = 0;\n\t\t\t}\n\n\t\t\to.startView = Math.max(o.startView, o.minViewMode);\n\n\t\t\to.weekStart %= 7;\n\t\t\to.weekEnd = ((o.weekStart + 6) % 7);\n\n\t\t\tvar format = DPGlobal.parseFormat(o.format)\n\t\t\tif (o.startDate !== -Infinity) {\n\t\t\t\to.startDate = DPGlobal.parseDate(o.startDate, format, o.language);\n\t\t\t}\n\t\t\tif (o.endDate !== Infinity) {\n\t\t\t\to.endDate = DPGlobal.parseDate(o.endDate, format, o.language);\n\t\t\t}\n\n\t\t\to.daysOfWeekDisabled = o.daysOfWeekDisabled||[];\n\t\t\tif (!$.isArray(o.daysOfWeekDisabled))\n\t\t\t\to.daysOfWeekDisabled = o.daysOfWeekDisabled.split(/[,\\s]*/);\n\t\t\to.daysOfWeekDisabled = $.map(o.daysOfWeekDisabled, function (d) {\n\t\t\t\treturn parseInt(d, 10);\n\t\t\t});\n\t\t},\n\t\t_events: [],\n\t\t_secondaryEvents: [],\n\t\t_applyEvents: function(evs){\n\t\t\tfor (var i=0, el, ev; i<evs.length; i++){\n\t\t\t\tel = evs[i][0];\n\t\t\t\tev = evs[i][1];\n\t\t\t\tel.on(ev);\n\t\t\t}\n\t\t},\n\t\t_unapplyEvents: function(evs){\n\t\t\tfor (var i=0, el, ev; i<evs.length; i++){\n\t\t\t\tel = evs[i][0];\n\t\t\t\tev = evs[i][1];\n\t\t\t\tel.off(ev);\n\t\t\t}\n\t\t},\n\t\t_buildEvents: function(){\n\t\t\tif (this.isInput) { // single input\n\t\t\t\tthis._events = [\n\t\t\t\t\t[this.element, {\n\t\t\t\t\t\tfocus: $.proxy(this.show, this),\n\t\t\t\t\t\tkeyup: $.proxy(this.update, this),\n\t\t\t\t\t\tkeydown: $.proxy(this.keydown, this)\n\t\t\t\t\t}]\n\t\t\t\t];\n\t\t\t}\n\t\t\telse if (this.component && this.hasInput){ // component: input + button\n\t\t\t\tthis._events = [\n\t\t\t\t\t// For components that are not readonly, allow keyboard nav\n\t\t\t\t\t[this.element.find('input'), {\n\t\t\t\t\t\tfocus: $.proxy(this.show, this),\n\t\t\t\t\t\tkeyup: $.proxy(this.update, this),\n\t\t\t\t\t\tkeydown: $.proxy(this.keydown, this)\n\t\t\t\t\t}],\n\t\t\t\t\t[this.component, {\n\t\t\t\t\t\tclick: $.proxy(this.show, this)\n\t\t\t\t\t}]\n\t\t\t\t];\n\t\t\t}\n\t\t\telse if (this.element.is('div')) {  // inline datepicker\n\t\t\t\tthis.isInline = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis._events = [\n\t\t\t\t\t[this.element, {\n\t\t\t\t\t\tclick: $.proxy(this.show, this)\n\t\t\t\t\t}]\n\t\t\t\t];\n\t\t\t}\n\n\t\t\tthis._secondaryEvents = [\n\t\t\t\t[this.picker, {\n\t\t\t\t\tclick: $.proxy(this.click, this)\n\t\t\t\t}],\n\t\t\t\t[$(window), {\n\t\t\t\t\tresize: $.proxy(this.place, this)\n\t\t\t\t}],\n\t\t\t\t[$(document), {\n\t\t\t\t\tmousedown: $.proxy(function (e) {\n\t\t\t\t\t\t// Clicked outside the datepicker, hide it\n\t\t\t\t\t\tif (!(\n\t\t\t\t\t\t\tthis.element.is(e.target) ||\n\t\t\t\t\t\t\tthis.element.find(e.target).size() ||\n\t\t\t\t\t\t\tthis.picker.is(e.target) ||\n\t\t\t\t\t\t\tthis.picker.find(e.target).size()\n\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\tthis.hide();\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this)\n\t\t\t\t}]\n\t\t\t];\n\t\t},\n\t\t_attachEvents: function(){\n\t\t\tthis._detachEvents();\n\t\t\tthis._applyEvents(this._events);\n\t\t},\n\t\t_detachEvents: function(){\n\t\t\tthis._unapplyEvents(this._events);\n\t\t},\n\t\t_attachSecondaryEvents: function(){\n\t\t\tthis._detachSecondaryEvents();\n\t\t\tthis._applyEvents(this._secondaryEvents);\n\t\t},\n\t\t_detachSecondaryEvents: function(){\n\t\t\tthis._unapplyEvents(this._secondaryEvents);\n\t\t},\n\t\t_trigger: function(event, altdate){\n\t\t\tvar date = altdate || this.date,\n\t\t\t\tlocal_date = new Date(date.getTime() + (date.getTimezoneOffset()*60000));\n\n\t\t\tthis.element.trigger({\n\t\t\t\ttype: event,\n\t\t\t\tdate: local_date,\n\t\t\t\tformat: $.proxy(function(altformat){\n\t\t\t\t\tvar format = altformat || this.o.format;\n\t\t\t\t\treturn DPGlobal.formatDate(date, format, this.o.language);\n\t\t\t\t}, this)\n\t\t\t});\n\t\t},\n\n\t\tshow: function(e) {\n\t\t\tif (!this.isInline)\n\t\t\t\tthis.picker.appendTo('body');\n\t\t\tthis.picker.show();\n\t\t\tthis.height = this.component ? this.component.outerHeight() : this.element.outerHeight();\n\t\t\tthis.place();\n\t\t\tthis._attachSecondaryEvents();\n\t\t\tif (e) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t\tthis._trigger('show');\n\t\t},\n\n\t\thide: function(e){\n\t\t\tif(this.isInline) return;\n\t\t\tif (!this.picker.is(':visible')) return;\n\t\t\tthis.picker.hide().detach();\n\t\t\tthis._detachSecondaryEvents();\n\t\t\tthis.viewMode = this.o.startView;\n\t\t\tthis.showMode();\n\n\t\t\tif (\n\t\t\t\tthis.o.forceParse &&\n\t\t\t\t(\n\t\t\t\t\tthis.isInput && this.element.val() ||\n\t\t\t\t\tthis.hasInput && this.element.find('input').val()\n\t\t\t\t)\n\t\t\t)\n\t\t\t\tthis.setValue();\n\t\t\tthis._trigger('hide');\n\t\t},\n\n\t\tremove: function() {\n\t\t\tthis.hide();\n\t\t\tthis._detachEvents();\n\t\t\tthis._detachSecondaryEvents();\n\t\t\tthis.picker.remove();\n\t\t\tdelete this.element.data().datepicker;\n\t\t\tif (!this.isInput) {\n\t\t\t\tdelete this.element.data().date;\n\t\t\t}\n\t\t},\n\n\t\tgetDate: function() {\n\t\t\tvar d = this.getUTCDate();\n\t\t\treturn new Date(d.getTime() + (d.getTimezoneOffset()*60000));\n\t\t},\n\n\t\tgetUTCDate: function() {\n\t\t\treturn this.date;\n\t\t},\n\n\t\tsetDate: function(d) {\n\t\t\tthis.setUTCDate(new Date(d.getTime() - (d.getTimezoneOffset()*60000)));\n\t\t},\n\n\t\tsetUTCDate: function(d) {\n\t\t\tthis.date = d;\n\t\t\tthis.setValue();\n\t\t},\n\n\t\tsetValue: function() {\n\t\t\tvar formatted = this.getFormattedDate();\n\t\t\tif (!this.isInput) {\n\t\t\t\tif (this.component){\n\t\t\t\t\tthis.element.find('input').val(formatted);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.element.val(formatted);\n\t\t\t}\n\t\t},\n\n\t\tgetFormattedDate: function(format) {\n\t\t\tif (format === undefined)\n\t\t\t\tformat = this.o.format;\n\t\t\treturn DPGlobal.formatDate(this.date, format, this.o.language);\n\t\t},\n\n\t\tsetStartDate: function(startDate){\n\t\t\tthis._process_options({startDate: startDate});\n\t\t\tthis.update();\n\t\t\tthis.updateNavArrows();\n\t\t},\n\n\t\tsetEndDate: function(endDate){\n\t\t\tthis._process_options({endDate: endDate});\n\t\t\tthis.update();\n\t\t\tthis.updateNavArrows();\n\t\t},\n\n\t\tsetDaysOfWeekDisabled: function(daysOfWeekDisabled){\n\t\t\tthis._process_options({daysOfWeekDisabled: daysOfWeekDisabled});\n\t\t\tthis.update();\n\t\t\tthis.updateNavArrows();\n\t\t},\n\n\t\tplace: function(){\n\t\t\t\t\t\tif(this.isInline) return;\n\t\t\tvar zIndex = parseInt(this.element.parents().filter(function() {\n\t\t\t\t\t\t\treturn $(this).css('z-index') != 'auto';\n\t\t\t\t\t\t}).first().css('z-index'))+10;\n\t\t\tvar offset = this.component ? this.component.parent().offset() : this.element.offset();\n\t\t\tvar height = this.component ? this.component.outerHeight(true) : this.element.outerHeight(true);\n\t\t\tthis.picker.css({\n\t\t\t\ttop: offset.top + height,\n\t\t\t\tleft: offset.left,\n\t\t\t\tzIndex: zIndex\n\t\t\t});\n\t\t},\n\n\t\t_allow_update: true,\n\t\tupdate: function(){\n\t\t\tif (!this._allow_update) return;\n\n\t\t\tvar date, fromArgs = false;\n\t\t\tif(arguments && arguments.length && (typeof arguments[0] === 'string' || arguments[0] instanceof Date)) {\n\t\t\t\tdate = arguments[0];\n\t\t\t\tfromArgs = true;\n\t\t\t} else {\n\t\t\t\tdate = this.isInput ? this.element.val() : this.element.data('date') || this.element.find('input').val();\n\t\t\t\tdelete this.element.data().date;\n\t\t\t}\n\n\t\t\tthis.date = DPGlobal.parseDate(date, this.o.format, this.o.language);\n\n\t\t\tif(fromArgs) this.setValue();\n\n\t\t\tif (this.date < this.o.startDate) {\n\t\t\t\tthis.viewDate = new Date(this.o.startDate);\n\t\t\t} else if (this.date > this.o.endDate) {\n\t\t\t\tthis.viewDate = new Date(this.o.endDate);\n\t\t\t} else {\n\t\t\t\tthis.viewDate = new Date(this.date);\n\t\t\t}\n\t\t\tthis.fill();\n\t\t},\n\n\t\tfillDow: function(){\n\t\t\tvar dowCnt = this.o.weekStart,\n\t\t\thtml = '<tr>';\n\t\t\tif(this.o.calendarWeeks){\n\t\t\t\tvar cell = '<th class=\"cw\">&nbsp;</th>';\n\t\t\t\thtml += cell;\n\t\t\t\tthis.picker.find('.datepicker-days thead tr:first-child').prepend(cell);\n\t\t\t}\n\t\t\twhile (dowCnt < this.o.weekStart + 7) {\n\t\t\t\thtml += '<th class=\"dow\">'+dates[this.o.language].daysMin[(dowCnt++)%7]+'</th>';\n\t\t\t}\n\t\t\thtml += '</tr>';\n\t\t\tthis.picker.find('.datepicker-days thead').append(html);\n\t\t},\n\n\t\tfillMonths: function(){\n\t\t\tvar html = '',\n\t\t\ti = 0;\n\t\t\twhile (i < 12) {\n\t\t\t\thtml += '<span class=\"month\">'+dates[this.o.language].monthsShort[i++]+'</span>';\n\t\t\t}\n\t\t\tthis.picker.find('.datepicker-months td').html(html);\n\t\t},\n\n\t\tsetRange: function(range){\n\t\t\tif (!range || !range.length)\n\t\t\t\tdelete this.range;\n\t\t\telse\n\t\t\t\tthis.range = $.map(range, function(d){ return d.valueOf(); });\n\t\t\tthis.fill();\n\t\t},\n\n\t\tgetClassNames: function(date){\n\t\t\tvar cls = [],\n\t\t\t\tyear = this.viewDate.getUTCFullYear(),\n\t\t\t\tmonth = this.viewDate.getUTCMonth(),\n\t\t\t\tcurrentDate = this.date.valueOf(),\n\t\t\t\ttoday = new Date();\n\t\t\tif (date.getUTCFullYear() < year || (date.getUTCFullYear() == year && date.getUTCMonth() < month)) {\n\t\t\t\tcls.push('old');\n\t\t\t} else if (date.getUTCFullYear() > year || (date.getUTCFullYear() == year && date.getUTCMonth() > month)) {\n\t\t\t\tcls.push('new');\n\t\t\t}\n\t\t\t// Compare internal UTC date with local today, not UTC today\n\t\t\tif (this.o.todayHighlight &&\n\t\t\t\tdate.getUTCFullYear() == today.getFullYear() &&\n\t\t\t\tdate.getUTCMonth() == today.getMonth() &&\n\t\t\t\tdate.getUTCDate() == today.getDate()) {\n\t\t\t\tcls.push('today');\n\t\t\t}\n\t\t\tif (currentDate && date.valueOf() == currentDate) {\n\t\t\t\tcls.push('active');\n\t\t\t}\n\t\t\tif (date.valueOf() < this.o.startDate || date.valueOf() > this.o.endDate ||\n\t\t\t\t$.inArray(date.getUTCDay(), this.o.daysOfWeekDisabled) !== -1) {\n\t\t\t\tcls.push('disabled');\n\t\t\t}\n\t\t\tif (this.range){\n\t\t\t\tif (date > this.range[0] && date < this.range[this.range.length-1]){\n\t\t\t\t\tcls.push('range');\n\t\t\t\t}\n\t\t\t\tif ($.inArray(date.valueOf(), this.range) != -1){\n\t\t\t\t\tcls.push('selected');\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cls;\n\t\t},\n\n\t\tfill: function() {\n\t\t\tvar d = new Date(this.viewDate),\n\t\t\t\tyear = d.getUTCFullYear(),\n\t\t\t\tmonth = d.getUTCMonth(),\n\t\t\t\tstartYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,\n\t\t\t\tstartMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,\n\t\t\t\tendYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,\n\t\t\t\tendMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,\n\t\t\t\tcurrentDate = this.date && this.date.valueOf(),\n\t\t\t\ttooltip;\n\t\t\tthis.picker.find('.datepicker-days thead th.datepicker-switch')\n\t\t\t\t\t\t.text(dates[this.o.language].months[month]+' '+year);\n\t\t\tthis.picker.find('tfoot th.today')\n\t\t\t\t\t\t.text(dates[this.o.language].today)\n\t\t\t\t\t\t.toggle(this.o.todayBtn !== false);\n\t\t\tthis.picker.find('tfoot th.clear')\n\t\t\t\t\t\t.text(dates[this.o.language].clear)\n\t\t\t\t\t\t.toggle(this.o.clearBtn !== false);\n\t\t\tthis.updateNavArrows();\n\t\t\tthis.fillMonths();\n\t\t\tvar prevMonth = UTCDate(year, month-1, 28,0,0,0,0),\n\t\t\t\tday = DPGlobal.getDaysInMonth(prevMonth.getUTCFullYear(), prevMonth.getUTCMonth());\n\t\t\tprevMonth.setUTCDate(day);\n\t\t\tprevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.o.weekStart + 7)%7);\n\t\t\tvar nextMonth = new Date(prevMonth);\n\t\t\tnextMonth.setUTCDate(nextMonth.getUTCDate() + 42);\n\t\t\tnextMonth = nextMonth.valueOf();\n\t\t\tvar html = [];\n\t\t\tvar clsName;\n\t\t\twhile(prevMonth.valueOf() < nextMonth) {\n\t\t\t\tif (prevMonth.getUTCDay() == this.o.weekStart) {\n\t\t\t\t\thtml.push('<tr>');\n\t\t\t\t\tif(this.o.calendarWeeks){\n\t\t\t\t\t\t// ISO 8601: First week contains first thursday.\n\t\t\t\t\t\t// ISO also states week starts on Monday, but we can be more abstract here.\n\t\t\t\t\t\tvar\n\t\t\t\t\t\t\t// Start of current week: based on weekstart/current date\n\t\t\t\t\t\t\tws = new Date(+prevMonth + (this.o.weekStart - prevMonth.getUTCDay() - 7) % 7 * 864e5),\n\t\t\t\t\t\t\t// Thursday of this week\n\t\t\t\t\t\t\tth = new Date(+ws + (7 + 4 - ws.getUTCDay()) % 7 * 864e5),\n\t\t\t\t\t\t\t// First Thursday of year, year from thursday\n\t\t\t\t\t\t\tyth = new Date(+(yth = UTCDate(th.getUTCFullYear(), 0, 1)) + (7 + 4 - yth.getUTCDay())%7*864e5),\n\t\t\t\t\t\t\t// Calendar week: ms between thursdays, div ms per day, div 7 days\n\t\t\t\t\t\t\tcalWeek =  (th - yth) / 864e5 / 7 + 1;\n\t\t\t\t\t\thtml.push('<td class=\"cw\">'+ calWeek +'</td>');\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclsName = this.getClassNames(prevMonth);\n\t\t\t\tclsName.push('day');\n\n\t\t\t\tvar before = this.o.beforeShowDay(prevMonth);\n\t\t\t\tif (before === undefined)\n\t\t\t\t\tbefore = {};\n\t\t\t\telse if (typeof(before) === 'boolean')\n\t\t\t\t\tbefore = {enabled: before};\n\t\t\t\telse if (typeof(before) === 'string')\n\t\t\t\t\tbefore = {classes: before};\n\t\t\t\tif (before.enabled === false)\n\t\t\t\t\tclsName.push('disabled');\n\t\t\t\tif (before.classes)\n\t\t\t\t\tclsName = clsName.concat(before.classes.split(/\\s+/));\n\t\t\t\tif (before.tooltip)\n\t\t\t\t\ttooltip = before.tooltip;\n\n\t\t\t\tclsName = $.unique(clsName);\n\t\t\t\thtml.push('<td class=\"'+clsName.join(' ')+'\"' + (tooltip ? ' title=\"'+tooltip+'\"' : '') + '>'+prevMonth.getUTCDate() + '</td>');\n\t\t\t\tif (prevMonth.getUTCDay() == this.o.weekEnd) {\n\t\t\t\t\thtml.push('</tr>');\n\t\t\t\t}\n\t\t\t\tprevMonth.setUTCDate(prevMonth.getUTCDate()+1);\n\t\t\t}\n\t\t\tthis.picker.find('.datepicker-days tbody').empty().append(html.join(''));\n\t\t\tvar currentYear = this.date && this.date.getUTCFullYear();\n\n\t\t\tvar months = this.picker.find('.datepicker-months')\n\t\t\t\t\t\t.find('th:eq(1)')\n\t\t\t\t\t\t\t.text(year)\n\t\t\t\t\t\t\t.end()\n\t\t\t\t\t\t.find('span').removeClass('active');\n\t\t\tif (currentYear && currentYear == year) {\n\t\t\t\tmonths.eq(this.date.getUTCMonth()).addClass('active');\n\t\t\t}\n\t\t\tif (year < startYear || year > endYear) {\n\t\t\t\tmonths.addClass('disabled');\n\t\t\t}\n\t\t\tif (year == startYear) {\n\t\t\t\tmonths.slice(0, startMonth).addClass('disabled');\n\t\t\t}\n\t\t\tif (year == endYear) {\n\t\t\t\tmonths.slice(endMonth+1).addClass('disabled');\n\t\t\t}\n\n\t\t\thtml = '';\n\t\t\tyear = parseInt(year/10, 10) * 10;\n\t\t\tvar yearCont = this.picker.find('.datepicker-years')\n\t\t\t\t\t\t\t\t.find('th:eq(1)')\n\t\t\t\t\t\t\t\t\t.text(year + '-' + (year + 9))\n\t\t\t\t\t\t\t\t\t.end()\n\t\t\t\t\t\t\t\t.find('td');\n\t\t\tyear -= 1;\n\t\t\tfor (var i = -1; i < 11; i++) {\n\t\t\t\thtml += '<span class=\"year'+(i == -1 ? ' old' : i == 10 ? ' new' : '')+(currentYear == year ? ' active' : '')+(year < startYear || year > endYear ? ' disabled' : '')+'\">'+year+'</span>';\n\t\t\t\tyear += 1;\n\t\t\t}\n\t\t\tyearCont.html(html);\n\t\t},\n\n\t\tupdateNavArrows: function() {\n\t\t\tif (!this._allow_update) return;\n\n\t\t\tvar d = new Date(this.viewDate),\n\t\t\t\tyear = d.getUTCFullYear(),\n\t\t\t\tmonth = d.getUTCMonth();\n\t\t\tswitch (this.viewMode) {\n\t\t\t\tcase 0:\n\t\t\t\t\tif (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear() && month <= this.o.startDate.getUTCMonth()) {\n\t\t\t\t\t\tthis.picker.find('.prev').css({visibility: 'hidden'});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.picker.find('.prev').css({visibility: 'visible'});\n\t\t\t\t\t}\n\t\t\t\t\tif (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear() && month >= this.o.endDate.getUTCMonth()) {\n\t\t\t\t\t\tthis.picker.find('.next').css({visibility: 'hidden'});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.picker.find('.next').css({visibility: 'visible'});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\tcase 2:\n\t\t\t\t\tif (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear()) {\n\t\t\t\t\t\tthis.picker.find('.prev').css({visibility: 'hidden'});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.picker.find('.prev').css({visibility: 'visible'});\n\t\t\t\t\t}\n\t\t\t\t\tif (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear()) {\n\t\t\t\t\t\tthis.picker.find('.next').css({visibility: 'hidden'});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.picker.find('.next').css({visibility: 'visible'});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t},\n\n\t\tclick: function(e) {\n\t\t\te.preventDefault();\n\t\t\tvar target = $(e.target).closest('span, td, th');\n\t\t\tif (target.length == 1) {\n\t\t\t\tswitch(target[0].nodeName.toLowerCase()) {\n\t\t\t\t\tcase 'th':\n\t\t\t\t\t\tswitch(target[0].className) {\n\t\t\t\t\t\t\tcase 'datepicker-switch':\n\t\t\t\t\t\t\t\tthis.showMode(1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'prev':\n\t\t\t\t\t\t\tcase 'next':\n\t\t\t\t\t\t\t\tvar dir = DPGlobal.modes[this.viewMode].navStep * (target[0].className == 'prev' ? -1 : 1);\n\t\t\t\t\t\t\t\tswitch(this.viewMode){\n\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\tthis.viewDate = this.moveMonth(this.viewDate, dir);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\tthis.viewDate = this.moveYear(this.viewDate, dir);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.fill();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'today':\n\t\t\t\t\t\t\t\tvar date = new Date();\n\t\t\t\t\t\t\t\tdate = UTCDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);\n\n\t\t\t\t\t\t\t\tthis.showMode(-2);\n\t\t\t\t\t\t\t\tvar which = this.o.todayBtn == 'linked' ? null : 'view';\n\t\t\t\t\t\t\t\tthis._setDate(date, which);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'clear':\n\t\t\t\t\t\t\t\tvar element;\n\t\t\t\t\t\t\t\tif (this.isInput)\n\t\t\t\t\t\t\t\t\telement = this.element;\n\t\t\t\t\t\t\t\telse if (this.component)\n\t\t\t\t\t\t\t\t\telement = this.element.find('input');\n\t\t\t\t\t\t\t\tif (element)\n\t\t\t\t\t\t\t\t\telement.val(\"\").change();\n\t\t\t\t\t\t\t\tthis._trigger('changeDate');\n\t\t\t\t\t\t\t\tthis.update();\n\t\t\t\t\t\t\t\tif (this.o.autoclose)\n\t\t\t\t\t\t\t\t\tthis.hide();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'span':\n\t\t\t\t\t\tif (!target.is('.disabled')) {\n\t\t\t\t\t\t\tthis.viewDate.setUTCDate(1);\n\t\t\t\t\t\t\tif (target.is('.month')) {\n\t\t\t\t\t\t\t\tvar day = 1;\n\t\t\t\t\t\t\t\tvar month = target.parent().find('span').index(target);\n\t\t\t\t\t\t\t\tvar year = this.viewDate.getUTCFullYear();\n\t\t\t\t\t\t\t\tthis.viewDate.setUTCMonth(month);\n\t\t\t\t\t\t\t\tthis._trigger('changeMonth', this.viewDate);\n\t\t\t\t\t\t\t\tif (this.o.minViewMode === 1) {\n\t\t\t\t\t\t\t\t\tthis._setDate(UTCDate(year, month, day,0,0,0,0));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvar year = parseInt(target.text(), 10)||0;\n\t\t\t\t\t\t\t\tvar day = 1;\n\t\t\t\t\t\t\t\tvar month = 0;\n\t\t\t\t\t\t\t\tthis.viewDate.setUTCFullYear(year);\n\t\t\t\t\t\t\t\tthis._trigger('changeYear', this.viewDate);\n\t\t\t\t\t\t\t\tif (this.o.minViewMode === 2) {\n\t\t\t\t\t\t\t\t\tthis._setDate(UTCDate(year, month, day,0,0,0,0));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.showMode(-1);\n\t\t\t\t\t\t\tthis.fill();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'td':\n\t\t\t\t\t\tif (target.is('.day') && !target.is('.disabled')){\n\t\t\t\t\t\t\tvar day = parseInt(target.text(), 10)||1;\n\t\t\t\t\t\t\tvar year = this.viewDate.getUTCFullYear(),\n\t\t\t\t\t\t\t\tmonth = this.viewDate.getUTCMonth();\n\t\t\t\t\t\t\tif (target.is('.old')) {\n\t\t\t\t\t\t\t\tif (month === 0) {\n\t\t\t\t\t\t\t\t\tmonth = 11;\n\t\t\t\t\t\t\t\t\tyear -= 1;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmonth -= 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (target.is('.new')) {\n\t\t\t\t\t\t\t\tif (month == 11) {\n\t\t\t\t\t\t\t\t\tmonth = 0;\n\t\t\t\t\t\t\t\t\tyear += 1;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmonth += 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis._setDate(UTCDate(year, month, day,0,0,0,0));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_setDate: function(date, which){\n\t\t\tif (!which || which == 'date')\n\t\t\t\tthis.date = new Date(date);\n\t\t\tif (!which || which  == 'view')\n\t\t\t\tthis.viewDate = new Date(date);\n\t\t\tthis.fill();\n\t\t\tthis.setValue();\n\t\t\tthis._trigger('changeDate');\n\t\t\tvar element;\n\t\t\tif (this.isInput) {\n\t\t\t\telement = this.element;\n\t\t\t} else if (this.component){\n\t\t\t\telement = this.element.find('input');\n\t\t\t}\n\t\t\tif (element) {\n\t\t\t\telement.change();\n\t\t\t\tif (this.o.autoclose && (!which || which == 'date')) {\n\t\t\t\t\tthis.hide();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tmoveMonth: function(date, dir){\n\t\t\tif (!dir) return date;\n\t\t\tvar new_date = new Date(date.valueOf()),\n\t\t\t\tday = new_date.getUTCDate(),\n\t\t\t\tmonth = new_date.getUTCMonth(),\n\t\t\t\tmag = Math.abs(dir),\n\t\t\t\tnew_month, test;\n\t\t\tdir = dir > 0 ? 1 : -1;\n\t\t\tif (mag == 1){\n\t\t\t\ttest = dir == -1\n\t\t\t\t\t// If going back one month, make sure month is not current month\n\t\t\t\t\t// (eg, Mar 31 -> Feb 31 == Feb 28, not Mar 02)\n\t\t\t\t\t? function(){ return new_date.getUTCMonth() == month; }\n\t\t\t\t\t// If going forward one month, make sure month is as expected\n\t\t\t\t\t// (eg, Jan 31 -> Feb 31 == Feb 28, not Mar 02)\n\t\t\t\t\t: function(){ return new_date.getUTCMonth() != new_month; };\n\t\t\t\tnew_month = month + dir;\n\t\t\t\tnew_date.setUTCMonth(new_month);\n\t\t\t\t// Dec -> Jan (12) or Jan -> Dec (-1) -- limit expected date to 0-11\n\t\t\t\tif (new_month < 0 || new_month > 11)\n\t\t\t\t\tnew_month = (new_month + 12) % 12;\n\t\t\t} else {\n\t\t\t\t// For magnitudes >1, move one month at a time...\n\t\t\t\tfor (var i=0; i<mag; i++)\n\t\t\t\t\t// ...which might decrease the day (eg, Jan 31 to Feb 28, etc)...\n\t\t\t\t\tnew_date = this.moveMonth(new_date, dir);\n\t\t\t\t// ...then reset the day, keeping it in the new month\n\t\t\t\tnew_month = new_date.getUTCMonth();\n\t\t\t\tnew_date.setUTCDate(day);\n\t\t\t\ttest = function(){ return new_month != new_date.getUTCMonth(); };\n\t\t\t}\n\t\t\t// Common date-resetting loop -- if date is beyond end of month, make it\n\t\t\t// end of month\n\t\t\twhile (test()){\n\t\t\t\tnew_date.setUTCDate(--day);\n\t\t\t\tnew_date.setUTCMonth(new_month);\n\t\t\t}\n\t\t\treturn new_date;\n\t\t},\n\n\t\tmoveYear: function(date, dir){\n\t\t\treturn this.moveMonth(date, dir*12);\n\t\t},\n\n\t\tdateWithinRange: function(date){\n\t\t\treturn date >= this.o.startDate && date <= this.o.endDate;\n\t\t},\n\n\t\tkeydown: function(e){\n\t\t\tif (this.picker.is(':not(:visible)')){\n\t\t\t\tif (e.keyCode == 27) // allow escape to hide and re-show picker\n\t\t\t\t\tthis.show();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar dateChanged = false,\n\t\t\t\tdir, day, month,\n\t\t\t\tnewDate, newViewDate;\n\t\t\tswitch(e.keyCode){\n\t\t\t\tcase 27: // escape\n\t\t\t\t\tthis.hide();\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 37: // left\n\t\t\t\tcase 39: // right\n\t\t\t\t\tif (!this.o.keyboardNavigation) break;\n\t\t\t\t\tdir = e.keyCode == 37 ? -1 : 1;\n\t\t\t\t\tif (e.ctrlKey){\n\t\t\t\t\t\tnewDate = this.moveYear(this.date, dir);\n\t\t\t\t\t\tnewViewDate = this.moveYear(this.viewDate, dir);\n\t\t\t\t\t} else if (e.shiftKey){\n\t\t\t\t\t\tnewDate = this.moveMonth(this.date, dir);\n\t\t\t\t\t\tnewViewDate = this.moveMonth(this.viewDate, dir);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewDate = new Date(this.date);\n\t\t\t\t\t\tnewDate.setUTCDate(this.date.getUTCDate() + dir);\n\t\t\t\t\t\tnewViewDate = new Date(this.viewDate);\n\t\t\t\t\t\tnewViewDate.setUTCDate(this.viewDate.getUTCDate() + dir);\n\t\t\t\t\t}\n\t\t\t\t\tif (this.dateWithinRange(newDate)){\n\t\t\t\t\t\tthis.date = newDate;\n\t\t\t\t\t\tthis.viewDate = newViewDate;\n\t\t\t\t\t\tthis.setValue();\n\t\t\t\t\t\tthis.update();\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\tdateChanged = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 38: // up\n\t\t\t\tcase 40: // down\n\t\t\t\t\tif (!this.o.keyboardNavigation) break;\n\t\t\t\t\tdir = e.keyCode == 38 ? -1 : 1;\n\t\t\t\t\tif (e.ctrlKey){\n\t\t\t\t\t\tnewDate = this.moveYear(this.date, dir);\n\t\t\t\t\t\tnewViewDate = this.moveYear(this.viewDate, dir);\n\t\t\t\t\t} else if (e.shiftKey){\n\t\t\t\t\t\tnewDate = this.moveMonth(this.date, dir);\n\t\t\t\t\t\tnewViewDate = this.moveMonth(this.viewDate, dir);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewDate = new Date(this.date);\n\t\t\t\t\t\tnewDate.setUTCDate(this.date.getUTCDate() + dir * 7);\n\t\t\t\t\t\tnewViewDate = new Date(this.viewDate);\n\t\t\t\t\t\tnewViewDate.setUTCDate(this.viewDate.getUTCDate() + dir * 7);\n\t\t\t\t\t}\n\t\t\t\t\tif (this.dateWithinRange(newDate)){\n\t\t\t\t\t\tthis.date = newDate;\n\t\t\t\t\t\tthis.viewDate = newViewDate;\n\t\t\t\t\t\tthis.setValue();\n\t\t\t\t\t\tthis.update();\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\tdateChanged = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 13: // enter\n\t\t\t\t\tthis.hide();\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9: // tab\n\t\t\t\t\tthis.hide();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (dateChanged){\n\t\t\t\tthis._trigger('changeDate');\n\t\t\t\tvar element;\n\t\t\t\tif (this.isInput) {\n\t\t\t\t\telement = this.element;\n\t\t\t\t} else if (this.component){\n\t\t\t\t\telement = this.element.find('input');\n\t\t\t\t}\n\t\t\t\tif (element) {\n\t\t\t\t\telement.change();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tshowMode: function(dir) {\n\t\t\tif (dir) {\n\t\t\t\tthis.viewMode = Math.max(this.o.minViewMode, Math.min(2, this.viewMode + dir));\n\t\t\t}\n\t\t\t/*\n\t\t\t\tvitalets: fixing bug of very special conditions:\n\t\t\t\tjquery 1.7.1 + webkit + show inline datepicker in bootstrap popover.\n\t\t\t\tMethod show() does not set display css correctly and datepicker is not shown.\n\t\t\t\tChanged to .css('display', 'block') solve the problem.\n\t\t\t\tSee https://github.com/vitalets/x-editable/issues/37\n\n\t\t\t\tIn jquery 1.7.2+ everything works fine.\n\t\t\t*/\n\t\t\t//this.picker.find('>div').hide().filter('.datepicker-'+DPGlobal.modes[this.viewMode].clsName).show();\n\t\t\tthis.picker.find('>div').hide().filter('.datepicker-'+DPGlobal.modes[this.viewMode].clsName).css('display', 'block');\n\t\t\tthis.updateNavArrows();\n\t\t}\n\t};\n\n\tvar DateRangePicker = function(element, options){\n\t\tthis.element = $(element);\n\t\tthis.inputs = $.map(options.inputs, function(i){ return i.jquery ? i[0] : i; });\n\t\tdelete options.inputs;\n\n\t\t$(this.inputs)\n\t\t\t.datepicker(options)\n\t\t\t.bind('changeDate', $.proxy(this.dateUpdated, this));\n\n\t\tthis.pickers = $.map(this.inputs, function(i){ return $(i).data('datepicker'); });\n\t\tthis.updateDates();\n\t};\n\tDateRangePicker.prototype = {\n\t\tupdateDates: function(){\n\t\t\tthis.dates = $.map(this.pickers, function(i){ return i.date; });\n\t\t\tthis.updateRanges();\n\t\t},\n\t\tupdateRanges: function(){\n\t\t\tvar range = $.map(this.dates, function(d){ return d.valueOf(); });\n\t\t\t$.each(this.pickers, function(i, p){\n\t\t\t\tp.setRange(range);\n\t\t\t});\n\t\t},\n\t\tdateUpdated: function(e){\n\t\t\tvar dp = $(e.target).data('datepicker'),\n\t\t\t\tnew_date = dp.getUTCDate(),\n\t\t\t\ti = $.inArray(e.target, this.inputs),\n\t\t\t\tl = this.inputs.length;\n\t\t\tif (i == -1) return;\n\n\t\t\tif (new_date < this.dates[i]){\n\t\t\t\t// Date being moved earlier/left\n\t\t\t\twhile (i>=0 && new_date < this.dates[i]){\n\t\t\t\t\tthis.pickers[i--].setUTCDate(new_date);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (new_date > this.dates[i]){\n\t\t\t\t// Date being moved later/right\n\t\t\t\twhile (i<l && new_date > this.dates[i]){\n\t\t\t\t\tthis.pickers[i++].setUTCDate(new_date);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.updateDates();\n\t\t},\n\t\tremove: function(){\n\t\t\t$.map(this.pickers, function(p){ p.remove(); });\n\t\t\tdelete this.element.data().datepicker;\n\t\t}\n\t};\n\n\tfunction opts_from_el(el, prefix){\n\t\t// Derive options from element data-attrs\n\t\tvar data = $(el).data(),\n\t\t\tout = {}, inkey,\n\t\t\treplace = new RegExp('^' + prefix.toLowerCase() + '([A-Z])'),\n\t\t\tprefix = new RegExp('^' + prefix.toLowerCase());\n\t\tfor (var key in data)\n\t\t\tif (prefix.test(key)){\n\t\t\t\tinkey = key.replace(replace, function(_,a){ return a.toLowerCase(); });\n\t\t\t\tout[inkey] = data[key];\n\t\t\t}\n\t\treturn out;\n\t}\n\n\tfunction opts_from_locale(lang){\n\t\t// Derive options from locale plugins\n\t\tvar out = {};\n\t\t// Check if \"de-DE\" style date is available, if not language should\n\t\t// fallback to 2 letter code eg \"de\"\n\t\tif (!dates[lang]) {\n\t\t\tlang = lang.split('-')[0]\n\t\t\tif (!dates[lang])\n\t\t\t\treturn;\n\t\t}\n\t\tvar d = dates[lang];\n\t\t$.each(locale_opts, function(i,k){\n\t\t\tif (k in d)\n\t\t\t\tout[k] = d[k];\n\t\t});\n\t\treturn out;\n\t}\n\n\tvar old = $.fn.datepicker;\n\tvar datepicker = $.fn.datepicker = function ( option ) {\n\t\tvar args = Array.apply(null, arguments);\n\t\targs.shift();\n\t\tvar internal_return,\n\t\t\tthis_return;\n\t\tthis.each(function () {\n\t\t\tvar $this = $(this),\n\t\t\t\tdata = $this.data('datepicker'),\n\t\t\t\toptions = typeof option == 'object' && option;\n\t\t\tif (!data) {\n\t\t\t\tvar elopts = opts_from_el(this, 'date'),\n\t\t\t\t\t// Preliminary otions\n\t\t\t\t\txopts = $.extend({}, defaults, elopts, options),\n\t\t\t\t\tlocopts = opts_from_locale(xopts.language),\n\t\t\t\t\t// Options priority: js args, data-attrs, locales, defaults\n\t\t\t\t\topts = $.extend({}, defaults, locopts, elopts, options);\n\t\t\t\tif ($this.is('.input-daterange') || opts.inputs){\n\t\t\t\t\tvar ropts = {\n\t\t\t\t\t\tinputs: opts.inputs || $this.find('input').toArray()\n\t\t\t\t\t};\n\t\t\t\t\t$this.data('datepicker', (data = new DateRangePicker(this, $.extend(opts, ropts))));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t$this.data('datepicker', (data = new Datepicker(this, opts)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (typeof option == 'string' && typeof data[option] == 'function') {\n\t\t\t\tinternal_return = data[option].apply(data, args);\n\t\t\t\tif (internal_return !== undefined)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\tif (internal_return !== undefined)\n\t\t\treturn internal_return;\n\t\telse\n\t\t\treturn this;\n\t};\n\n\tvar defaults = $.fn.datepicker.defaults = {\n\t\tautoclose: false,\n\t\tbeforeShowDay: $.noop,\n\t\tcalendarWeeks: false,\n\t\tclearBtn: false,\n\t\tdaysOfWeekDisabled: [],\n\t\tendDate: Infinity,\n\t\tforceParse: true,\n\t\tformat: 'mm/dd/yyyy',\n\t\tkeyboardNavigation: true,\n\t\tlanguage: 'en',\n\t\tminViewMode: 0,\n\t\trtl: false,\n\t\tstartDate: -Infinity,\n\t\tstartView: 0,\n\t\ttodayBtn: false,\n\t\ttodayHighlight: false,\n\t\tweekStart: 0\n\t};\n\tvar locale_opts = $.fn.datepicker.locale_opts = [\n\t\t'format',\n\t\t'rtl',\n\t\t'weekStart'\n\t];\n\t$.fn.datepicker.Constructor = Datepicker;\n\tvar dates = $.fn.datepicker.dates = {\n\t\ten: {\n\t\t\tdays: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"],\n\t\t\tdaysShort: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"],\n\t\t\tdaysMin: [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\", \"Su\"],\n\t\t\tmonths: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n\t\t\tmonthsShort: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n\t\t\ttoday: \"Today\",\n\t\t\tclear: \"Clear\"\n\t\t}\n\t};\n\n\tvar DPGlobal = {\n\t\tmodes: [\n\t\t\t{\n\t\t\t\tclsName: 'days',\n\t\t\t\tnavFnc: 'Month',\n\t\t\t\tnavStep: 1\n\t\t\t},\n\t\t\t{\n\t\t\t\tclsName: 'months',\n\t\t\t\tnavFnc: 'FullYear',\n\t\t\t\tnavStep: 1\n\t\t\t},\n\t\t\t{\n\t\t\t\tclsName: 'years',\n\t\t\t\tnavFnc: 'FullYear',\n\t\t\t\tnavStep: 10\n\t\t}],\n\t\tisLeapYear: function (year) {\n\t\t\treturn (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0));\n\t\t},\n\t\tgetDaysInMonth: function (year, month) {\n\t\t\treturn [31, (DPGlobal.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];\n\t\t},\n\t\tvalidParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g,\n\t\tnonpunctuation: /[^ -\\/:-@\\[\\u3400-\\u9fff-`{-~\\t\\n\\r]+/g,\n\t\tparseFormat: function(format){\n\t\t\t// IE treats \\0 as a string end in inputs (truncating the value),\n\t\t\t// so it's a bad format delimiter, anyway\n\t\t\tvar separators = format.replace(this.validParts, '\\0').split('\\0'),\n\t\t\t\tparts = format.match(this.validParts);\n\t\t\tif (!separators || !separators.length || !parts || parts.length === 0){\n\t\t\t\tthrow new Error(\"Invalid date format.\");\n\t\t\t}\n\t\t\treturn {separators: separators, parts: parts};\n\t\t},\n\t\tparseDate: function(date, format, language) {\n\t\t\tif (date instanceof Date) return date;\n\t\t\tif (typeof format === 'string')\n\t\t\t\tformat = DPGlobal.parseFormat(format);\n\t\t\tif (/^[\\-+]\\d+[dmwy]([\\s,]+[\\-+]\\d+[dmwy])*$/.test(date)) {\n\t\t\t\tvar part_re = /([\\-+]\\d+)([dmwy])/,\n\t\t\t\t\tparts = date.match(/([\\-+]\\d+)([dmwy])/g),\n\t\t\t\t\tpart, dir;\n\t\t\t\tdate = new Date();\n\t\t\t\tfor (var i=0; i<parts.length; i++) {\n\t\t\t\t\tpart = part_re.exec(parts[i]);\n\t\t\t\t\tdir = parseInt(part[1]);\n\t\t\t\t\tswitch(part[2]){\n\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\tdate.setUTCDate(date.getUTCDate() + dir);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'm':\n\t\t\t\t\t\t\tdate = Datepicker.prototype.moveMonth.call(Datepicker.prototype, date, dir);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'w':\n\t\t\t\t\t\t\tdate.setUTCDate(date.getUTCDate() + dir * 7);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'y':\n\t\t\t\t\t\t\tdate = Datepicker.prototype.moveYear.call(Datepicker.prototype, date, dir);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn UTCDate(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0);\n\t\t\t}\n\t\t\tvar parts = date && date.match(this.nonpunctuation) || [],\n\t\t\t\tdate = new Date(),\n\t\t\t\tparsed = {},\n\t\t\t\tsetters_order = ['yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'd', 'dd'],\n\t\t\t\tsetters_map = {\n\t\t\t\t\tyyyy: function(d,v){ return d.setUTCFullYear(v); },\n\t\t\t\t\tyy: function(d,v){ return d.setUTCFullYear(2000+v); },\n\t\t\t\t\tm: function(d,v){\n\t\t\t\t\t\tv -= 1;\n\t\t\t\t\t\twhile (v<0) v += 12;\n\t\t\t\t\t\tv %= 12;\n\t\t\t\t\t\td.setUTCMonth(v);\n\t\t\t\t\t\twhile (d.getUTCMonth() != v)\n\t\t\t\t\t\t\td.setUTCDate(d.getUTCDate()-1);\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t},\n\t\t\t\t\td: function(d,v){ return d.setUTCDate(v); }\n\t\t\t\t},\n\t\t\t\tval, filtered, part;\n\t\t\tsetters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];\n\t\t\tsetters_map['dd'] = setters_map['d'];\n\t\t\tdate = UTCDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);\n\t\t\tvar fparts = format.parts.slice();\n\t\t\t// Remove noop parts\n\t\t\tif (parts.length != fparts.length) {\n\t\t\t\tfparts = $(fparts).filter(function(i,p){\n\t\t\t\t\treturn $.inArray(p, setters_order) !== -1;\n\t\t\t\t}).toArray();\n\t\t\t}\n\t\t\t// Process remainder\n\t\t\tif (parts.length == fparts.length) {\n\t\t\t\tfor (var i=0, cnt = fparts.length; i < cnt; i++) {\n\t\t\t\t\tval = parseInt(parts[i], 10);\n\t\t\t\t\tpart = fparts[i];\n\t\t\t\t\tif (isNaN(val)) {\n\t\t\t\t\t\tswitch(part) {\n\t\t\t\t\t\t\tcase 'MM':\n\t\t\t\t\t\t\t\tfiltered = $(dates[language].months).filter(function(){\n\t\t\t\t\t\t\t\t\tvar m = this.slice(0, parts[i].length),\n\t\t\t\t\t\t\t\t\t\tp = parts[i].slice(0, m.length);\n\t\t\t\t\t\t\t\t\treturn m == p;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tval = $.inArray(filtered[0], dates[language].months) + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'M':\n\t\t\t\t\t\t\t\tfiltered = $(dates[language].monthsShort).filter(function(){\n\t\t\t\t\t\t\t\t\tvar m = this.slice(0, parts[i].length),\n\t\t\t\t\t\t\t\t\t\tp = parts[i].slice(0, m.length);\n\t\t\t\t\t\t\t\t\treturn m == p;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tval = $.inArray(filtered[0], dates[language].monthsShort) + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tparsed[part] = val;\n\t\t\t\t}\n\t\t\t\tfor (var i=0, s; i<setters_order.length; i++){\n\t\t\t\t\ts = setters_order[i];\n\t\t\t\t\tif (s in parsed && !isNaN(parsed[s]))\n\t\t\t\t\t\tsetters_map[s](date, parsed[s]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn date;\n\t\t},\n\t\tformatDate: function(date, format, language){\n\t\t\tif (typeof format === 'string')\n\t\t\t\tformat = DPGlobal.parseFormat(format);\n\t\t\tvar val = {\n\t\t\t\td: date.getUTCDate(),\n\t\t\t\tD: dates[language].daysShort[date.getUTCDay()],\n\t\t\t\tDD: dates[language].days[date.getUTCDay()],\n\t\t\t\tm: date.getUTCMonth() + 1,\n\t\t\t\tM: dates[language].monthsShort[date.getUTCMonth()],\n\t\t\t\tMM: dates[language].months[date.getUTCMonth()],\n\t\t\t\tyy: date.getUTCFullYear().toString().substring(2),\n\t\t\t\tyyyy: date.getUTCFullYear()\n\t\t\t};\n\t\t\tval.dd = (val.d < 10 ? '0' : '') + val.d;\n\t\t\tval.mm = (val.m < 10 ? '0' : '') + val.m;\n\t\t\tvar date = [],\n\t\t\t\tseps = $.extend([], format.separators);\n\t\t\tfor (var i=0, cnt = format.parts.length; i <= cnt; i++) {\n\t\t\t\tif (seps.length)\n\t\t\t\t\tdate.push(seps.shift());\n\t\t\t\tdate.push(val[format.parts[i]]);\n\t\t\t}\n\t\t\treturn date.join('');\n\t\t},\n\t\theadTemplate: '<thead>'+\n\t\t\t\t\t\t\t'<tr>'+\n\t\t\t\t\t\t\t\t'<th class=\"prev\"><i class=\"icon-arrow-left\"/></th>'+\n\t\t\t\t\t\t\t\t'<th colspan=\"5\" class=\"datepicker-switch\"></th>'+\n\t\t\t\t\t\t\t\t'<th class=\"next\"><i class=\"icon-arrow-right\"/></th>'+\n\t\t\t\t\t\t\t'</tr>'+\n\t\t\t\t\t\t'</thead>',\n\t\tcontTemplate: '<tbody><tr><td colspan=\"7\"></td></tr></tbody>',\n\t\tfootTemplate: '<tfoot><tr><th colspan=\"7\" class=\"today\"></th></tr><tr><th colspan=\"7\" class=\"clear\"></th></tr></tfoot>'\n\t};\n\tDPGlobal.template = '<div class=\"datepicker\">'+\n\t\t\t\t\t\t\t'<div class=\"datepicker-days\">'+\n\t\t\t\t\t\t\t\t'<table class=\" table-condensed\">'+\n\t\t\t\t\t\t\t\t\tDPGlobal.headTemplate+\n\t\t\t\t\t\t\t\t\t'<tbody></tbody>'+\n\t\t\t\t\t\t\t\t\tDPGlobal.footTemplate+\n\t\t\t\t\t\t\t\t'</table>'+\n\t\t\t\t\t\t\t'</div>'+\n\t\t\t\t\t\t\t'<div class=\"datepicker-months\">'+\n\t\t\t\t\t\t\t\t'<table class=\"table-condensed\">'+\n\t\t\t\t\t\t\t\t\tDPGlobal.headTemplate+\n\t\t\t\t\t\t\t\t\tDPGlobal.contTemplate+\n\t\t\t\t\t\t\t\t\tDPGlobal.footTemplate+\n\t\t\t\t\t\t\t\t'</table>'+\n\t\t\t\t\t\t\t'</div>'+\n\t\t\t\t\t\t\t'<div class=\"datepicker-years\">'+\n\t\t\t\t\t\t\t\t'<table class=\"table-condensed\">'+\n\t\t\t\t\t\t\t\t\tDPGlobal.headTemplate+\n\t\t\t\t\t\t\t\t\tDPGlobal.contTemplate+\n\t\t\t\t\t\t\t\t\tDPGlobal.footTemplate+\n\t\t\t\t\t\t\t\t'</table>'+\n\t\t\t\t\t\t\t'</div>'+\n\t\t\t\t\t\t'</div>';\n\n\t$.fn.datepicker.DPGlobal = DPGlobal;\n\n\n\t/* DATEPICKER NO CONFLICT\n\t* =================== */\n\n\t$.fn.datepicker.noConflict = function(){\n\t\t$.fn.datepicker = old;\n\t\treturn this;\n\t};\n\n\n\t/* DATEPICKER DATA-API\n\t* ================== */\n\n\t$(document).on(\n\t\t'focus.datepicker.data-api click.datepicker.data-api',\n\t\t'[data-provide=\"datepicker\"]',\n\t\tfunction(e){\n\t\t\tvar $this = $(this);\n\t\t\tif ($this.data('datepicker')) return;\n\t\t\te.preventDefault();\n\t\t\t// component click requires us to explicitly show it\n\t\t\tdatepicker.call($this, 'show');\n\t\t}\n\t);\n\t$(function(){\n\t\t//$('[data-provide=\"datepicker-inline\"]').datepicker();\n        //vit: changed to support noConflict()\n        datepicker.call($('[data-provide=\"datepicker-inline\"]'));\n\t});\n\n}( window.jQuery ));\n\n/**\nBootstrap-datepicker.  \nDescription and examples: https://github.com/eternicode/bootstrap-datepicker.  \nFor **i18n** you should include js file from here: https://github.com/eternicode/bootstrap-datepicker/tree/master/js/locales\nand set `language` option.  \nSince 1.4.0 date has different appearance in **popup** and **inline** modes. \n\n@class date\n@extends abstractinput\n@final\n@example\n<a href=\"#\" id=\"dob\" data-type=\"date\" data-pk=\"1\" data-url=\"/post\" data-title=\"Select date\">15/05/1984</a>\n<script>\n$(function(){\n    $('#dob').editable({\n        format: 'yyyy-mm-dd',    \n        viewformat: 'dd/mm/yyyy',    \n        datepicker: {\n                weekStart: 1\n           }\n        }\n    });\n});\n</script>\n**/\n(function ($) {\n    \"use strict\";\n    \n    //store bootstrap-datepicker as bdateicker to exclude conflict with jQuery UI one\n    $.fn.bdatepicker = $.fn.datepicker.noConflict();\n    if(!$.fn.datepicker) { //if there were no other datepickers, keep also original name\n        $.fn.datepicker = $.fn.bdatepicker;    \n    }    \n    \n    var Date = function (options) {\n        this.init('date', options, Date.defaults);\n        this.initPicker(options, Date.defaults);\n    };\n\n    $.fn.editableutils.inherit(Date, $.fn.editabletypes.abstractinput);    \n    \n    $.extend(Date.prototype, {\n        initPicker: function(options, defaults) {\n            //'format' is set directly from settings or data-* attributes\n\n            //by default viewformat equals to format\n            if(!this.options.viewformat) {\n                this.options.viewformat = this.options.format;\n            }\n            \n            //try parse datepicker config defined as json string in data-datepicker\n            options.datepicker = $.fn.editableutils.tryParseJson(options.datepicker, true);\n            \n            //overriding datepicker config (as by default jQuery extend() is not recursive)\n            //since 1.4 datepicker internally uses viewformat instead of format. Format is for submit only\n            this.options.datepicker = $.extend({}, defaults.datepicker, options.datepicker, {\n                format: this.options.viewformat\n            });\n            \n            //language\n            this.options.datepicker.language = this.options.datepicker.language || 'en'; \n\n            //store DPglobal\n            this.dpg = $.fn.bdatepicker.DPGlobal; \n\n            //store parsed formats\n            this.parsedFormat = this.dpg.parseFormat(this.options.format);\n            this.parsedViewFormat = this.dpg.parseFormat(this.options.viewformat);            \n        },\n        \n        render: function () {\n            this.$input.bdatepicker(this.options.datepicker);\n            \n            //\"clear\" link\n            if(this.options.clear) {\n                this.$clear = $('<a href=\"#\"></a>').html(this.options.clear).click($.proxy(function(e){\n                    e.preventDefault();\n                    e.stopPropagation();\n                    this.clear();\n                }, this));\n                \n                this.$tpl.parent().append($('<div class=\"editable-clear\">').append(this.$clear));  \n            }                \n        },\n        \n        value2html: function(value, element) {\n           var text = value ? this.dpg.formatDate(value, this.parsedViewFormat, this.options.datepicker.language) : '';\n           Date.superclass.value2html.call(this, text, element); \n        },\n\n        html2value: function(html) {\n            return this.parseDate(html, this.parsedViewFormat);\n        },   \n\n        value2str: function(value) {\n            return value ? this.dpg.formatDate(value, this.parsedFormat, this.options.datepicker.language) : '';\n        }, \n\n        str2value: function(str) {\n            return this.parseDate(str, this.parsedFormat);\n        }, \n\n        value2submit: function(value) {\n            return this.value2str(value);\n        },                    \n\n        value2input: function(value) {\n            this.$input.bdatepicker('update', value);\n        },\n\n        input2value: function() { \n            return this.$input.data('datepicker').date;\n        },       \n\n        activate: function() {\n        },\n\n        clear:  function() {\n            this.$input.data('datepicker').date = null;\n            this.$input.find('.active').removeClass('active');\n            if(!this.options.showbuttons) {\n                this.$input.closest('form').submit(); \n            }\n        },\n\n        autosubmit: function() {\n            this.$input.on('mouseup', '.day', function(e){\n                if($(e.currentTarget).is('.old') || $(e.currentTarget).is('.new')) {\n                    return;\n                }\n                var $form = $(this).closest('form');\n                setTimeout(function() {\n                    $form.submit();\n                }, 200);\n            });\n           //changedate is not suitable as it triggered when showing datepicker. see #149\n           /*\n           this.$input.on('changeDate', function(e){\n               var $form = $(this).closest('form');\n               setTimeout(function() {\n                   $form.submit();\n               }, 200);\n           });\n           */\n       },\n       \n       /*\n        For incorrect date bootstrap-datepicker returns current date that is not suitable\n        for datefield.\n        This function returns null for incorrect date.  \n       */\n       parseDate: function(str, format) {\n           var date = null, formattedBack;\n           if(str) {\n               date = this.dpg.parseDate(str, format, this.options.datepicker.language);\n               if(typeof str === 'string') {\n                   formattedBack = this.dpg.formatDate(date, format, this.options.datepicker.language);\n                   if(str !== formattedBack) {\n                       date = null;\n                   }\n               }\n           }\n           return date;\n       }\n\n    });\n\n    Date.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <div></div>\n        **/         \n        tpl:'<div class=\"editable-date well\"></div>',\n        /**\n        @property inputclass \n        @default null\n        **/\n        inputclass: null,\n        /**\n        Format used for sending value to server. Also applied when converting date from <code>data-value</code> attribute.<br>\n        Possible tokens are: <code>d, dd, m, mm, yy, yyyy</code>  \n\n        @property format \n        @type string\n        @default yyyy-mm-dd\n        **/\n        format:'yyyy-mm-dd',\n        /**\n        Format used for displaying date. Also applied when converting date from element's text on init.   \n        If not specified equals to <code>format</code>\n\n        @property viewformat \n        @type string\n        @default null\n        **/\n        viewformat: null,\n        /**\n        Configuration of datepicker.\n        Full list of options: http://bootstrap-datepicker.readthedocs.org/en/latest/options.html\n\n        @property datepicker \n        @type object\n        @default {\n            weekStart: 0,\n            startView: 0,\n            minViewMode: 0,\n            autoclose: false\n        }\n        **/\n        datepicker:{\n            weekStart: 0,\n            startView: 0,\n            minViewMode: 0,\n            autoclose: false\n        },\n        /**\n        Text shown as clear date button. \n        If <code>false</code> clear button will not be rendered.\n\n        @property clear \n        @type boolean|string\n        @default 'x clear'\n        **/\n        clear: '&times; clear'\n    });\n\n    $.fn.editabletypes.date = Date;\n\n}(window.jQuery));\n\n/**\nBootstrap datefield input - modification for inline mode.\nShows normal <input type=\"text\"> and binds popup datepicker.  \nAutomatically shown in inline mode.\n\n@class datefield\n@extends date\n\n@since 1.4.0\n**/\n(function ($) {\n    \"use strict\";\n    \n    var DateField = function (options) {\n        this.init('datefield', options, DateField.defaults);\n        this.initPicker(options, DateField.defaults);\n    };\n\n    $.fn.editableutils.inherit(DateField, $.fn.editabletypes.date);    \n    \n    $.extend(DateField.prototype, {\n        render: function () {\n            this.$input = this.$tpl.find('input');\n            this.setClass();\n            this.setAttr('placeholder');\n    \n            //bootstrap-datepicker is set `bdateicker` to exclude conflict with jQuery UI one. (in date.js)        \n            this.$tpl.bdatepicker(this.options.datepicker);\n            \n            //need to disable original event handlers\n            this.$input.off('focus keydown');\n            \n            //update value of datepicker\n            this.$input.keyup($.proxy(function(){\n               this.$tpl.removeData('date');\n               this.$tpl.bdatepicker('update');\n            }, this));\n            \n        },   \n        \n       value2input: function(value) {\n           this.$input.val(value ? this.dpg.formatDate(value, this.parsedViewFormat, this.options.datepicker.language) : '');\n           this.$tpl.bdatepicker('update');\n       },\n        \n       input2value: function() { \n           return this.html2value(this.$input.val());\n       },              \n        \n       activate: function() {\n           $.fn.editabletypes.text.prototype.activate.call(this);\n       },\n       \n       autosubmit: function() {\n         //reset autosubmit to empty  \n       }\n    });\n    \n    DateField.defaults = $.extend({}, $.fn.editabletypes.date.defaults, {\n        /**\n        @property tpl \n        **/         \n        tpl:'<div class=\"input-append date\"><input type=\"text\"/><span class=\"add-on\"><i class=\"icon-th\"></i></span></div>',\n        /**\n        @property inputclass \n        @default 'input-small'\n        **/         \n        inputclass: 'input-small',\n        \n        /* datepicker config */\n        datepicker: {\n            weekStart: 0,\n            startView: 0,\n            minViewMode: 0,\n            autoclose: true\n        }\n    });\n    \n    $.fn.editabletypes.datefield = DateField;\n\n}(window.jQuery));\n/**\nBootstrap-datetimepicker.  \nBased on [smalot bootstrap-datetimepicker plugin](https://github.com/smalot/bootstrap-datetimepicker). \nBefore usage you should manually include dependent js and css:\n\n    <link href=\"css/datetimepicker.css\" rel=\"stylesheet\" type=\"text/css\"></link> \n    <script src=\"js/bootstrap-datetimepicker.js\"></script>\n\nFor **i18n** you should include js file from here: https://github.com/smalot/bootstrap-datetimepicker/tree/master/js/locales\nand set `language` option.  \n\n@class datetime\n@extends abstractinput\n@final\n@since 1.4.4\n@example\n<a href=\"#\" id=\"last_seen\" data-type=\"datetime\" data-pk=\"1\" data-url=\"/post\" title=\"Select date & time\">15/03/2013 12:45</a>\n<script>\n$(function(){\n    $('#last_seen').editable({\n        format: 'yyyy-mm-dd hh:ii',    \n        viewformat: 'dd/mm/yyyy hh:ii',    \n        datetimepicker: {\n                weekStart: 1\n           }\n        }\n    });\n});\n</script>\n**/\n(function ($) {\n    \"use strict\";\n\n    var DateTime = function (options) {\n        this.init('datetime', options, DateTime.defaults);\n        this.initPicker(options, DateTime.defaults);\n    };\n\n    $.fn.editableutils.inherit(DateTime, $.fn.editabletypes.abstractinput);\n\n    $.extend(DateTime.prototype, {\n        initPicker: function(options, defaults) {\n            //'format' is set directly from settings or data-* attributes\n\n            //by default viewformat equals to format\n            if(!this.options.viewformat) {\n                this.options.viewformat = this.options.format;\n            }\n            \n            //try parse datetimepicker config defined as json string in data-datetimepicker\n            options.datetimepicker = $.fn.editableutils.tryParseJson(options.datetimepicker, true);\n\n            //overriding datetimepicker config (as by default jQuery extend() is not recursive)\n            //since 1.4 datetimepicker internally uses viewformat instead of format. Format is for submit only\n            this.options.datetimepicker = $.extend({}, defaults.datetimepicker, options.datetimepicker, {\n                format: this.options.viewformat\n            });\n\n            //language\n            this.options.datetimepicker.language = this.options.datetimepicker.language || 'en'; \n\n            //store DPglobal\n            this.dpg = $.fn.datetimepicker.DPGlobal; \n\n            //store parsed formats\n            this.parsedFormat = this.dpg.parseFormat(this.options.format, this.options.formatType);\n            this.parsedViewFormat = this.dpg.parseFormat(this.options.viewformat, this.options.formatType);\n        },\n\n        render: function () {\n            this.$input.datetimepicker(this.options.datetimepicker);\n\n            //adjust container position when viewMode changes\n            //see https://github.com/smalot/bootstrap-datetimepicker/pull/80\n            this.$input.on('changeMode', function(e) {\n                var f = $(this).closest('form').parent();\n                //timeout here, otherwise container changes position before form has new size\n                setTimeout(function(){\n                    f.triggerHandler('resize');\n                }, 0);\n            });\n\n            //\"clear\" link\n            if(this.options.clear) {\n                this.$clear = $('<a href=\"#\"></a>').html(this.options.clear).click($.proxy(function(e){\n                    e.preventDefault();\n                    e.stopPropagation();\n                    this.clear();\n                }, this));\n\n                this.$tpl.parent().append($('<div class=\"editable-clear\">').append(this.$clear));  \n            }\n        },\n\n        value2html: function(value, element) {\n            //formatDate works with UTCDate!\n            var text = value ? this.dpg.formatDate(this.toUTC(value), this.parsedViewFormat, this.options.datetimepicker.language, this.options.formatType) : '';\n            if(element) {\n                DateTime.superclass.value2html.call(this, text, element);\n            } else {\n                return text;\n            }\n        },\n\n        html2value: function(html) {\n            //parseDate return utc date!\n            var value = this.parseDate(html, this.parsedViewFormat); \n            return value ? this.fromUTC(value) : null;\n        },\n\n        value2str: function(value) {\n            //formatDate works with UTCDate!\n            return value ? this.dpg.formatDate(this.toUTC(value), this.parsedFormat, this.options.datetimepicker.language, this.options.formatType) : '';\n       },\n\n       str2value: function(str) {\n           //parseDate return utc date!\n           var value = this.parseDate(str, this.parsedFormat);\n           return value ? this.fromUTC(value) : null;\n       },\n\n       value2submit: function(value) {\n           return this.value2str(value);\n       },\n\n       value2input: function(value) {\n           if(value) {\n             this.$input.data('datetimepicker').setDate(value);\n           }\n       },\n\n       input2value: function() { \n           //date may be cleared, in that case getDate() triggers error\n           var dt = this.$input.data('datetimepicker');\n           return dt.date ? dt.getDate() : null;\n       },\n\n       activate: function() {\n       },\n\n       clear: function() {\n          this.$input.data('datetimepicker').date = null;\n          this.$input.find('.active').removeClass('active');\n          if(!this.options.showbuttons) {\n             this.$input.closest('form').submit(); \n          }          \n       },\n\n       autosubmit: function() {\n           this.$input.on('mouseup', '.minute', function(e){\n               var $form = $(this).closest('form');\n               setTimeout(function() {\n                   $form.submit();\n               }, 200);\n           });\n       },\n\n       //convert date from local to utc\n       toUTC: function(value) {\n         return value ? new Date(value.valueOf() - value.getTimezoneOffset() * 60000) : value;  \n       },\n\n       //convert date from utc to local\n       fromUTC: function(value) {\n         return value ? new Date(value.valueOf() + value.getTimezoneOffset() * 60000) : value;  \n       },\n\n       /*\n        For incorrect date bootstrap-datetimepicker returns current date that is not suitable\n        for datetimefield.\n        This function returns null for incorrect date.  \n       */\n       parseDate: function(str, format) {\n           var date = null, formattedBack;\n           if(str) {\n               date = this.dpg.parseDate(str, format, this.options.datetimepicker.language, this.options.formatType);\n               if(typeof str === 'string') {\n                   formattedBack = this.dpg.formatDate(date, format, this.options.datetimepicker.language, this.options.formatType);\n                   if(str !== formattedBack) {\n                       date = null;\n                   } \n               }\n           }\n           return date;\n       }\n\n    });\n\n    DateTime.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <div></div>\n        **/         \n        tpl:'<div class=\"editable-date well\"></div>',\n        /**\n        @property inputclass \n        @default null\n        **/\n        inputclass: null,\n        /**\n        Format used for sending value to server. Also applied when converting date from <code>data-value</code> attribute.<br>\n        Possible tokens are: <code>d, dd, m, mm, yy, yyyy, h, i</code>  \n        \n        @property format \n        @type string\n        @default yyyy-mm-dd hh:ii\n        **/         \n        format:'yyyy-mm-dd hh:ii',\n        formatType:'standard',\n        /**\n        Format used for displaying date. Also applied when converting date from element's text on init.   \n        If not specified equals to <code>format</code>\n        \n        @property viewformat \n        @type string\n        @default null\n        **/\n        viewformat: null,\n        /**\n        Configuration of datetimepicker.\n        Full list of options: https://github.com/smalot/bootstrap-datetimepicker\n\n        @property datetimepicker \n        @type object\n        @default { }\n        **/\n        datetimepicker:{\n            todayHighlight: false,\n            autoclose: false\n        },\n        /**\n        Text shown as clear date button. \n        If <code>false</code> clear button will not be rendered.\n\n        @property clear \n        @type boolean|string\n        @default 'x clear'\n        **/\n        clear: '&times; clear'\n    });\n\n    $.fn.editabletypes.datetime = DateTime;\n\n}(window.jQuery));\n/**\nBootstrap datetimefield input - datetime input for inline mode.\nShows normal <input type=\"text\"> and binds popup datetimepicker.  \nAutomatically shown in inline mode.\n\n@class datetimefield\n@extends datetime\n\n**/\n(function ($) {\n    \"use strict\";\n    \n    var DateTimeField = function (options) {\n        this.init('datetimefield', options, DateTimeField.defaults);\n        this.initPicker(options, DateTimeField.defaults);\n    };\n\n    $.fn.editableutils.inherit(DateTimeField, $.fn.editabletypes.datetime);\n    \n    $.extend(DateTimeField.prototype, {\n        render: function () {\n            this.$input = this.$tpl.find('input');\n            this.setClass();\n            this.setAttr('placeholder');\n            \n            this.$tpl.datetimepicker(this.options.datetimepicker);\n            \n            //need to disable original event handlers\n            this.$input.off('focus keydown');\n            \n            //update value of datepicker\n            this.$input.keyup($.proxy(function(){\n               this.$tpl.removeData('date');\n               this.$tpl.datetimepicker('update');\n            }, this));\n            \n        },   \n      \n       value2input: function(value) {\n           this.$input.val(this.value2html(value));\n           this.$tpl.datetimepicker('update');\n       },\n        \n       input2value: function() { \n           return this.html2value(this.$input.val());\n       },              \n        \n       activate: function() {\n           $.fn.editabletypes.text.prototype.activate.call(this);\n       },\n       \n       autosubmit: function() {\n         //reset autosubmit to empty  \n       }\n    });\n    \n    DateTimeField.defaults = $.extend({}, $.fn.editabletypes.datetime.defaults, {\n        /**\n        @property tpl \n        **/         \n        tpl:'<div class=\"input-append date\"><input type=\"text\"/><span class=\"add-on\"><i class=\"icon-th\"></i></span></div>',\n        /**\n        @property inputclass \n        @default 'input-medium'\n        **/         \n        inputclass: 'input-medium',\n        \n        /* datetimepicker config */\n        datetimepicker:{\n            todayHighlight: false,\n            autoclose: true\n        }\n    });\n    \n    $.fn.editabletypes.datetimefield = DateTimeField;\n\n}(window.jQuery));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9Nb2R1bGVzL1RyYW5zbGF0aW9uL25vZGVfbW9kdWxlcy94LWVkaXRhYmxlL2Rpc3QvYm9vdHN0cmFwMy1lZGl0YWJsZS9qcy9ib290c3RyYXAtZWRpdGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxxQkFBcUI7QUFDeEUsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJELHVCQUF1QjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQyx3QkFBd0IsUUFBUTtBQUNoQyx3QkFBd0IsT0FBTztBQUMvQix3QkFBd0IsT0FBTztBQUMvQix3QkFBd0IsUUFBUTs7QUFFaEM7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCxpQkFBaUI7QUFDakI7QUFDQSxrREFBa0QsaUVBQWlFO0FBQ25ILGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkRBQTZEO0FBQzdEO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdILGtCQUFrQjtBQUNsSTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0IsT0FBTyw0QkFBNEI7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLGNBQWM7QUFDOUcsa0JBQWtCLG9DQUFvQztBQUN0RDtBQUNBLDZDQUE2QyxjQUFjLGNBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLHFEQUFxRCxtQkFBbUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsUUFBUTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7O0FBRWIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwrQ0FBK0M7QUFDL0Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1QyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNkJBQTZCO0FBQy9EO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxTQUFTOztBQUVUO0FBQ0EseUJBQXlCO0FBQ3pCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLHlEQUF5RCxxQkFBcUI7QUFDOUU7O0FBRUE7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQ0FBbUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGNBQWM7QUFDcEY7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxjQUFjO0FBQ3hGO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxjQUFjO0FBQ3JGO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxnRUFBZ0Usc0JBQXNCLEdBQUcsSUFBSTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0Esa0NBQWtDLGNBQWMsR0FBRyxjQUFjO0FBQ2pFO0FBQ0E7QUFDQSxzQ0FBc0Msd0JBQXdCLEdBQUcsd0JBQXdCO0FBQ3pGLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxxQ0FBcUMsd0JBQXdCO0FBQzdEO0FBQ0E7QUFDQSxjQUFjLFFBQVEsU0FBUztBQUMvQjtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLGtEQUFrRCx3QkFBd0IsR0FBRyx3QkFBd0I7QUFDckcsNERBQTRELCtCQUErQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRCQUE0Qix3QkFBd0IsR0FBRyx3QkFBd0IsRUFBRTs7QUFFNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDRCQUE0QjtBQUMvRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QyxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlO0FBQ2Y7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7O0FBRUwsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSwwQkFBMEI7QUFDekMsZUFBZTtBQUNmO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsMEJBQTBCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxLQUFLOztBQUVMLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUNBQW1DO0FBQ25DO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFVBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDhCQUE4QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0M7QUFDaEMsOERBQThEO0FBQzlEO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwrQkFBK0I7QUFDL0I7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DLGVBQWUsZ0NBQWdDO0FBQy9DLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGlCQUFpQjtBQUNqQjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxrREFBa0Qsc0JBQXNCO0FBQ3hFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsU0FBUztBQUN6RTtBQUNBO0FBQ0Esb0VBQW9FLFFBQVE7QUFDNUU7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBOztBQUVBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxpREFBaUQscUJBQXFCO0FBQ3RFLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUIsR0FBRyxxQkFBcUI7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxVQUFVO0FBQ2pELGFBQWE7O0FBRWI7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVTtBQUM5QyxhQUFhOztBQUViO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHlCQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FB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QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEIsdUNBQXVDO0FBQ2pFO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxxQkFBcUI7QUFDaEU7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxQkFBcUI7QUFDMUQsT0FBTztBQUNQLHFDQUFxQyxzQkFBc0I7QUFDM0Q7QUFDQTtBQUNBLHFDQUFxQyxxQkFBcUI7QUFDMUQsT0FBTztBQUNQLHFDQUFxQyxzQkFBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxQkFBcUI7QUFDMUQsT0FBTztBQUNQLHFDQUFxQyxzQkFBc0I7QUFDM0Q7QUFDQTtBQUNBLHFDQUFxQyxxQkFBcUI7QUFDMUQsT0FBTztBQUNQLHFDQUFxQyxzQkFBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUYsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLFlBQVk7QUFDWixRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTCxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsS0FBSzs7QUFFTDs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZvbWFydC8uL01vZHVsZXMvVHJhbnNsYXRpb24vbm9kZV9tb2R1bGVzL3gtZWRpdGFibGUvZGlzdC9ib290c3RyYXAzLWVkaXRhYmxlL2pzL2Jvb3RzdHJhcC1lZGl0YWJsZS5qcz9jMGFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBYLWVkaXRhYmxlIC0gdjEuNS4xIFxuKiBJbi1wbGFjZSBlZGl0aW5nIHdpdGggVHdpdHRlciBCb290c3RyYXAsIGpRdWVyeSBVSSBvciBwdXJlIGpRdWVyeVxuKiBodHRwOi8vZ2l0aHViLmNvbS92aXRhbGV0cy94LWVkaXRhYmxlXG4qIENvcHlyaWdodCAoYykgMjAxMyBWaXRhbGl5IFBvdGFwb3Y7IExpY2Vuc2VkIE1JVCAqL1xuLyoqXG5Gb3JtIHdpdGggc2luZ2xlIGlucHV0IGVsZW1lbnQsIHR3byBidXR0b25zIGFuZCB0d28gc3RhdGVzOiBub3JtYWwvbG9hZGluZy5cbkFwcGxpZWQgYXMgalF1ZXJ5IG1ldGhvZCB0byBESVYgdGFnIChub3QgdG8gZm9ybSB0YWchKS4gVGhpcyBpcyBiZWNhdXNlIGZvcm0gY2FuIGJlIGluIGxvYWRpbmcgc3RhdGUgd2hlbiBzcGlubmVyIHNob3duLlxuRWRpdGFibGVmb3JtIGlzIGxpbmtlZCB3aXRoIG9uZSBvZiBpbnB1dCB0eXBlcywgZS5nLiAndGV4dCcsICdzZWxlY3QnIGV0Yy5cblxuQGNsYXNzIGVkaXRhYmxlZm9ybVxuQHVzZXMgdGV4dFxuQHVzZXMgdGV4dGFyZWFcbioqL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgXG4gICAgdmFyIEVkaXRhYmxlRm9ybSA9IGZ1bmN0aW9uIChkaXYsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGVmb3JtLmRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy4kZGl2ID0gJChkaXYpOyAvL2RpdiwgY29udGFpbmluZyBmb3JtLiBOb3QgZm9ybSB0YWcuIE5vdCBlZGl0YWJsZS1lbGVtZW50LlxuICAgICAgICBpZighdGhpcy5vcHRpb25zLnNjb3BlKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2NvcGUgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vbm90aGluZyBzaG93biBhZnRlciBpbml0XG4gICAgfTtcblxuICAgIEVkaXRhYmxlRm9ybS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBFZGl0YWJsZUZvcm0sXG4gICAgICAgIGluaXRJbnB1dDogZnVuY3Rpb24oKSB7ICAvL2NhbGxlZCBvbmNlXG4gICAgICAgICAgICAvL3Rha2UgaW5wdXQgZnJvbSBvcHRpb25zIChhcyBpdCBpcyBjcmVhdGVkIGluIGVkaXRhYmxlLWVsZW1lbnQpXG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gdGhpcy5vcHRpb25zLmlucHV0O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3NldCBpbml0aWFsIHZhbHVlXG4gICAgICAgICAgICAvL3RvZG86IG1heSBiZSBhZGQgY2hlY2s6IHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5pbnB1dC5zdHIydmFsdWUodGhpcy5vcHRpb25zLnZhbHVlKTsgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vcHJlcmVuZGVyOiBnZXQgaW5wdXQuJGlucHV0XG4gICAgICAgICAgICB0aGlzLmlucHV0LnByZXJlbmRlcigpO1xuICAgICAgICB9LFxuICAgICAgICBpbml0VGVtcGxhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kZm9ybSA9ICQoJC5mbi5lZGl0YWJsZWZvcm0udGVtcGxhdGUpOyBcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdEJ1dHRvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyICRidG4gPSB0aGlzLiRmb3JtLmZpbmQoJy5lZGl0YWJsZS1idXR0b25zJyk7XG4gICAgICAgICAgICAkYnRuLmFwcGVuZCgkLmZuLmVkaXRhYmxlZm9ybS5idXR0b25zKTtcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5zaG93YnV0dG9ucyA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgICAgICAkYnRuLmFkZENsYXNzKCdlZGl0YWJsZS1idXR0b25zLWJvdHRvbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgUmVuZGVycyBlZGl0YWJsZWZvcm1cblxuICAgICAgICBAbWV0aG9kIHJlbmRlclxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy9pbml0IGxvYWRlclxuICAgICAgICAgICAgdGhpcy4kbG9hZGluZyA9ICQoJC5mbi5lZGl0YWJsZWZvcm0ubG9hZGluZyk7ICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJGRpdi5lbXB0eSgpLmFwcGVuZCh0aGlzLiRsb2FkaW5nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pbml0IGZvcm0gdGVtcGxhdGUgYW5kIGJ1dHRvbnNcbiAgICAgICAgICAgIHRoaXMuaW5pdFRlbXBsYXRlKCk7XG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuc2hvd2J1dHRvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRCdXR0b25zKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuJGZvcm0uZmluZCgnLmVkaXRhYmxlLWJ1dHRvbnMnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9zaG93IGxvYWRpbmcgc3RhdGVcbiAgICAgICAgICAgIHRoaXMuc2hvd0xvYWRpbmcoKTsgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9mbGFnIHNob3dpbmcgaXMgZm9ybSBub3cgc2F2aW5nIHZhbHVlIHRvIHNlcnZlci4gXG4gICAgICAgICAgICAvL0l0IGlzIG5lZWRlZCB0byB3YWl0IHdoZW4gY2xvc2luZyBmb3JtLlxuICAgICAgICAgICAgdGhpcy5pc1NhdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvKiogICAgICAgIFxuICAgICAgICAgICAgRmlyZWQgd2hlbiByZW5kZXJpbmcgc3RhcnRzXG4gICAgICAgICAgICBAZXZlbnQgcmVuZGVyaW5nIFxuICAgICAgICAgICAgQHBhcmFtIHtPYmplY3R9IGV2ZW50IGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgKiovICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRkaXYudHJpZ2dlckhhbmRsZXIoJ3JlbmRlcmluZycpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2luaXQgaW5wdXRcbiAgICAgICAgICAgIHRoaXMuaW5pdElucHV0KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vYXBwZW5kIGlucHV0IHRvIGZvcm1cbiAgICAgICAgICAgIHRoaXMuJGZvcm0uZmluZCgnZGl2LmVkaXRhYmxlLWlucHV0JykuYXBwZW5kKHRoaXMuaW5wdXQuJHRwbCk7ICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vYXBwZW5kIGZvcm0gdG8gY29udGFpbmVyXG4gICAgICAgICAgICB0aGlzLiRkaXYuYXBwZW5kKHRoaXMuJGZvcm0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3JlbmRlciBpbnB1dFxuICAgICAgICAgICAgJC53aGVuKHRoaXMuaW5wdXQucmVuZGVyKCkpXG4gICAgICAgICAgICAudGhlbigkLnByb3h5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvL3NldHVwIGlucHV0IHRvIHN1Ym1pdCBhdXRvbWF0aWNhbGx5IHdoZW4gbm8gYnV0dG9ucyBzaG93blxuICAgICAgICAgICAgICAgIGlmKCF0aGlzLm9wdGlvbnMuc2hvd2J1dHRvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5hdXRvc3VibWl0KCk7IFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9hdHRhY2ggJ2NhbmNlbCcgaGFuZGxlclxuICAgICAgICAgICAgICAgIHRoaXMuJGZvcm0uZmluZCgnLmVkaXRhYmxlLWNhbmNlbCcpLmNsaWNrKCQucHJveHkodGhpcy5jYW5jZWwsIHRoaXMpKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZih0aGlzLmlucHV0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IodGhpcy5pbnB1dC5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGZvcm0uZmluZCgnLmVkaXRhYmxlLXN1Ym1pdCcpLmF0dHIoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuJGlucHV0LmF0dHIoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBmb3JtIGZyb20gc3VibWl0dGluZ1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRmb3JtLnN1Ym1pdChmdW5jdGlvbihlKXsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC4kaW5wdXQucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZm9ybS5maW5kKCcuZWRpdGFibGUtc3VibWl0JykucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gKHRoaXMudmFsdWUgPT09IG51bGwgfHwgdGhpcy52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudmFsdWUgPT09ICcnKSA/IHRoaXMub3B0aW9ucy5kZWZhdWx0VmFsdWUgOiB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0LnZhbHVlMmlucHV0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy9hdHRhY2ggc3VibWl0IGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZm9ybS5zdWJtaXQoJC5wcm94eSh0aGlzLnN1Ym1pdCwgdGhpcykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qKiAgICAgICAgXG4gICAgICAgICAgICAgICAgRmlyZWQgd2hlbiBmb3JtIGlzIHJlbmRlcmVkXG4gICAgICAgICAgICAgICAgQGV2ZW50IHJlbmRlcmVkXG4gICAgICAgICAgICAgICAgQHBhcmFtIHtPYmplY3R9IGV2ZW50IGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgICAgICoqLyAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuJGRpdi50cmlnZ2VySGFuZGxlcigncmVuZGVyZWQnKTsgICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICB0aGlzLnNob3dGb3JtKCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9jYWxsIHBvc3RyZW5kZXIgbWV0aG9kIHRvIHBlcmZvcm0gYWN0aW9ucyByZXF1aXJlZCB2aXNpYmlsaXR5IG9mIGZvcm1cbiAgICAgICAgICAgICAgICBpZih0aGlzLmlucHV0LnBvc3RyZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5wb3N0cmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHsgICBcbiAgICAgICAgICAgIC8qKiAgICAgICAgXG4gICAgICAgICAgICBGaXJlZCB3aGVuIGZvcm0gd2FzIGNhbmNlbGxlZCBieSB1c2VyXG4gICAgICAgICAgICBAZXZlbnQgY2FuY2VsIFxuICAgICAgICAgICAgQHBhcmFtIHtPYmplY3R9IGV2ZW50IGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgKiovICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJGRpdi50cmlnZ2VySGFuZGxlcignY2FuY2VsJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNob3dMb2FkaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB3LCBoO1xuICAgICAgICAgICAgaWYodGhpcy4kZm9ybSkge1xuICAgICAgICAgICAgICAgIC8vc2V0IGxvYWRpbmcgc2l6ZSBlcXVhbCB0byBmb3JtXG4gICAgICAgICAgICAgICAgdyA9IHRoaXMuJGZvcm0ub3V0ZXJXaWR0aCgpO1xuICAgICAgICAgICAgICAgIGggPSB0aGlzLiRmb3JtLm91dGVySGVpZ2h0KCk7IFxuICAgICAgICAgICAgICAgIGlmKHcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9hZGluZy53aWR0aCh3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoaCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2FkaW5nLmhlaWdodChoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4kZm9ybS5oaWRlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vc3RyZXRjaCBsb2FkaW5nIHRvIGZpbGwgY29udGFpbmVyIHdpZHRoXG4gICAgICAgICAgICAgICAgdyA9IHRoaXMuJGxvYWRpbmcucGFyZW50KCkud2lkdGgoKTtcbiAgICAgICAgICAgICAgICBpZih3KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvYWRpbmcud2lkdGgodyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kbG9hZGluZy5zaG93KCk7IFxuICAgICAgICB9LFxuXG4gICAgICAgIHNob3dGb3JtOiBmdW5jdGlvbihhY3RpdmF0ZSkge1xuICAgICAgICAgICAgdGhpcy4kbG9hZGluZy5oaWRlKCk7XG4gICAgICAgICAgICB0aGlzLiRmb3JtLnNob3coKTtcbiAgICAgICAgICAgIGlmKGFjdGl2YXRlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuYWN0aXZhdGUoKTsgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiogICAgICAgIFxuICAgICAgICAgICAgRmlyZWQgd2hlbiBmb3JtIGlzIHNob3duXG4gICAgICAgICAgICBAZXZlbnQgc2hvdyBcbiAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBldmVudCBldmVudCBvYmplY3RcbiAgICAgICAgICAgICoqLyAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRkaXYudHJpZ2dlckhhbmRsZXIoJ3Nob3cnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlcnJvcjogZnVuY3Rpb24obXNnKSB7XG4gICAgICAgICAgICB2YXIgJGdyb3VwID0gdGhpcy4kZm9ybS5maW5kKCcuY29udHJvbC1ncm91cCcpLFxuICAgICAgICAgICAgICAgICRibG9jayA9IHRoaXMuJGZvcm0uZmluZCgnLmVkaXRhYmxlLWVycm9yLWJsb2NrJyksXG4gICAgICAgICAgICAgICAgbGluZXM7XG5cbiAgICAgICAgICAgIGlmKG1zZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAkZ3JvdXAucmVtb3ZlQ2xhc3MoJC5mbi5lZGl0YWJsZWZvcm0uZXJyb3JHcm91cENsYXNzKTtcbiAgICAgICAgICAgICAgICAkYmxvY2sucmVtb3ZlQ2xhc3MoJC5mbi5lZGl0YWJsZWZvcm0uZXJyb3JCbG9ja0NsYXNzKS5lbXB0eSgpLmhpZGUoKTsgXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vY29udmVydCBuZXdsaW5lIHRvIDxicj4gZm9yIG1vcmUgcHJldHR5IGVycm9yIGRpc3BsYXlcbiAgICAgICAgICAgICAgICBpZihtc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZXMgPSAoJycrbXNnKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzW2ldID0gJCgnPGRpdj4nKS50ZXh0KGxpbmVzW2ldKS5odG1sKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbXNnID0gbGluZXMuam9pbignPGJyPicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkZ3JvdXAuYWRkQ2xhc3MoJC5mbi5lZGl0YWJsZWZvcm0uZXJyb3JHcm91cENsYXNzKTtcbiAgICAgICAgICAgICAgICAkYmxvY2suYWRkQ2xhc3MoJC5mbi5lZGl0YWJsZWZvcm0uZXJyb3JCbG9ja0NsYXNzKS5odG1sKG1zZykuc2hvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHN1Ym1pdDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9nZXQgbmV3IHZhbHVlIGZyb20gaW5wdXRcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuaW5wdXQuaW5wdXQydmFsdWUoKTsgXG5cbiAgICAgICAgICAgIC8vdmFsaWRhdGlvbjogaWYgdmFsaWRhdGUgcmV0dXJucyBzdHJpbmcgb3IgdHJ1dGh5IHZhbHVlIC0gbWVhbnMgZXJyb3JcbiAgICAgICAgICAgIC8vaWYgcmV0dXJucyBvYmplY3QgbGlrZSB7bmV3VmFsdWU6ICcuLi4nfSA9PiBzdWJtaXR0ZWQgdmFsdWUgaXMgcmVhc3NpZ25lZCB0byBpdFxuICAgICAgICAgICAgdmFyIGVycm9yID0gdGhpcy52YWxpZGF0ZShuZXdWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoJC50eXBlKGVycm9yKSA9PT0gJ29iamVjdCcgJiYgZXJyb3IubmV3VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gZXJyb3IubmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC52YWx1ZTJpbnB1dChuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIGVycm9yLm1zZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvci5tc2cpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dGb3JtKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93Rm9ybSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaWYgdmFsdWUgbm90IGNoYW5nZWQgLS0+IHRyaWdnZXIgJ25vY2hhbmdlJyBldmVudCBhbmQgcmV0dXJuXG4gICAgICAgICAgICAvKmpzbGludCBlcWVxOiB0cnVlKi9cbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLnNhdmVub2NoYW5nZSAmJiB0aGlzLmlucHV0LnZhbHVlMnN0cihuZXdWYWx1ZSkgPT0gdGhpcy5pbnB1dC52YWx1ZTJzdHIodGhpcy52YWx1ZSkpIHtcbiAgICAgICAgICAgIC8qanNsaW50IGVxZXE6IGZhbHNlKi8gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqICAgICAgICBcbiAgICAgICAgICAgICAgICBGaXJlZCB3aGVuIHZhbHVlIG5vdCBjaGFuZ2VkIGJ1dCBmb3JtIGlzIHN1Ym1pdHRlZC4gUmVxdWlyZXMgc2F2ZW5vY2hhbmdlID0gZmFsc2UuXG4gICAgICAgICAgICAgICAgQGV2ZW50IG5vY2hhbmdlIFxuICAgICAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBldmVudCBldmVudCBvYmplY3RcbiAgICAgICAgICAgICAgICAqKi8gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuJGRpdi50cmlnZ2VySGFuZGxlcignbm9jaGFuZ2UnKTsgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IFxuXG4gICAgICAgICAgICAvL2NvbnZlcnQgdmFsdWUgZm9yIHN1Ym1pdHRpbmcgdG8gc2VydmVyXG4gICAgICAgICAgICB2YXIgc3VibWl0VmFsdWUgPSB0aGlzLmlucHV0LnZhbHVlMnN1Ym1pdChuZXdWYWx1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuaXNTYXZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3NlbmRpbmcgZGF0YSB0byBzZXJ2ZXJcbiAgICAgICAgICAgICQud2hlbih0aGlzLnNhdmUoc3VibWl0VmFsdWUpKVxuICAgICAgICAgICAgLmRvbmUoJC5wcm94eShmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNTYXZpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vcnVuIHN1Y2Nlc3MgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gdHlwZW9mIHRoaXMub3B0aW9ucy5zdWNjZXNzID09PSAnZnVuY3Rpb24nID8gdGhpcy5vcHRpb25zLnN1Y2Nlc3MuY2FsbCh0aGlzLm9wdGlvbnMuc2NvcGUsIHJlc3BvbnNlLCBuZXdWYWx1ZSkgOiBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy9pZiBzdWNjZXNzIGNhbGxiYWNrIHJldHVybnMgZmFsc2UgLS0+IGtlZXAgZm9ybSBvcGVuIGFuZCBkbyBub3QgYWN0aXZhdGUgaW5wdXRcbiAgICAgICAgICAgICAgICBpZihyZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dGb3JtKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vaWYgc3VjY2VzcyBjYWxsYmFjayByZXR1cm5zIHN0cmluZyAtLT4gIGtlZXAgZm9ybSBvcGVuLCBzaG93IGVycm9yIGFuZCBhY3RpdmF0ZSBpbnB1dCAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiByZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IocmVzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93Rm9ybSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9pZiBzdWNjZXNzIGNhbGxiYWNrIHJldHVybnMgb2JqZWN0IGxpa2Uge25ld1ZhbHVlOiA8c29tZXRoaW5nPn0gLS0+IHVzZSB0aGF0IHZhbHVlIGluc3RlYWQgb2Ygc3VibWl0dGVkXG4gICAgICAgICAgICAgICAgLy9pdCBpcyB1c2VmdWxsIGlmIHlvdSB3YW50IHRvIGNobmFnZSB2YWx1ZSBpbiB1cmwtZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBpZihyZXMgJiYgdHlwZW9mIHJlcyA9PT0gJ29iamVjdCcgJiYgcmVzLmhhc093blByb3BlcnR5KCduZXdWYWx1ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gcmVzLm5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vY2xlYXIgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZmFsc2UpOyAgIFxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAvKiogICAgICAgIFxuICAgICAgICAgICAgICAgIEZpcmVkIHdoZW4gZm9ybSBpcyBzdWJtaXR0ZWRcbiAgICAgICAgICAgICAgICBAZXZlbnQgc2F2ZSBcbiAgICAgICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gZXZlbnQgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICAgICAgQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBhZGRpdGlvbmFsIHBhcmFtc1xuICAgICAgICAgICAgICAgIEBwYXJhbSB7bWl4ZWR9IHBhcmFtcy5uZXdWYWx1ZSByYXcgbmV3IHZhbHVlXG4gICAgICAgICAgICAgICAgQHBhcmFtIHttaXhlZH0gcGFyYW1zLnN1Ym1pdFZhbHVlIHN1Ym1pdHRlZCB2YWx1ZSBhcyBzdHJpbmdcbiAgICAgICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gcGFyYW1zLnJlc3BvbnNlIGFqYXggcmVzcG9uc2VcblxuICAgICAgICAgICAgICAgIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgJCgnI2Zvcm0tZGl2Jykub24oJ3NhdmUnKSwgZnVuY3Rpb24oZSwgcGFyYW1zKXtcbiAgICAgICAgICAgICAgICAgICAgaWYocGFyYW1zLm5ld1ZhbHVlID09PSAndXNlcm5hbWUnKSB7Li4ufVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICoqL1xuICAgICAgICAgICAgICAgIHRoaXMuJGRpdi50cmlnZ2VySGFuZGxlcignc2F2ZScsIHtuZXdWYWx1ZTogbmV3VmFsdWUsIHN1Ym1pdFZhbHVlOiBzdWJtaXRWYWx1ZSwgcmVzcG9uc2U6IHJlc3BvbnNlfSk7XG4gICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgIC5mYWlsKCQucHJveHkoZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1NhdmluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgdmFyIG1zZztcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgdGhpcy5vcHRpb25zLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IHRoaXMub3B0aW9ucy5lcnJvci5jYWxsKHRoaXMub3B0aW9ucy5zY29wZSwgeGhyLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnID0gdHlwZW9mIHhociA9PT0gJ3N0cmluZycgPyB4aHIgOiB4aHIucmVzcG9uc2VUZXh0IHx8IHhoci5zdGF0dXNUZXh0IHx8ICdVbmtub3duIGVycm9yISc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihtc2cpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Zvcm0oKTtcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzYXZlOiBmdW5jdGlvbihzdWJtaXRWYWx1ZSkge1xuICAgICAgICAgICAgLy90cnkgcGFyc2UgY29tcG9zaXRlIHBrIGRlZmluZWQgYXMganNvbiBzdHJpbmcgaW4gZGF0YS1wayBcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wayA9ICQuZm4uZWRpdGFibGV1dGlscy50cnlQYXJzZUpzb24odGhpcy5vcHRpb25zLnBrLCB0cnVlKTsgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBwayA9ICh0eXBlb2YgdGhpcy5vcHRpb25zLnBrID09PSAnZnVuY3Rpb24nKSA/IHRoaXMub3B0aW9ucy5way5jYWxsKHRoaXMub3B0aW9ucy5zY29wZSkgOiB0aGlzLm9wdGlvbnMucGssXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICBzZW5kIG9uIHNlcnZlciBpbiBmb2xsb3dpbmcgY2FzZXM6XG4gICAgICAgICAgICAgIDEuIHVybCBpcyBmdW5jdGlvblxuICAgICAgICAgICAgICAyLiB1cmwgaXMgc3RyaW5nIEFORCAocGsgZGVmaW5lZCBPUiBzZW5kIG9wdGlvbiA9IGFsd2F5cykgXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2VuZCA9ICEhKHR5cGVvZiB0aGlzLm9wdGlvbnMudXJsID09PSAnZnVuY3Rpb24nIHx8ICh0aGlzLm9wdGlvbnMudXJsICYmICgodGhpcy5vcHRpb25zLnNlbmQgPT09ICdhbHdheXMnKSB8fCAodGhpcy5vcHRpb25zLnNlbmQgPT09ICdhdXRvJyAmJiBwayAhPT0gbnVsbCAmJiBwayAhPT0gdW5kZWZpbmVkKSkpKSxcbiAgICAgICAgICAgIHBhcmFtcztcblxuICAgICAgICAgICAgaWYgKHNlbmQpIHsgLy9zZW5kIHRvIHNlcnZlclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0xvYWRpbmcoKTtcblxuICAgICAgICAgICAgICAgIC8vc3RhbmRhcmQgcGFyYW1zXG4gICAgICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm9wdGlvbnMubmFtZSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN1Ym1pdFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBwazogcGsgXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vYWRkaXRpb25hbCBwYXJhbXNcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgdGhpcy5vcHRpb25zLnBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB0aGlzLm9wdGlvbnMucGFyYW1zLmNhbGwodGhpcy5vcHRpb25zLnNjb3BlLCBwYXJhbXMpOyAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy90cnkgcGFyc2UganNvbiBpbiBzaW5nbGUgcXVvdGVzIChmcm9tIGRhdGEtcGFyYW1zIGF0dHJpYnV0ZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBhcmFtcyA9ICQuZm4uZWRpdGFibGV1dGlscy50cnlQYXJzZUpzb24odGhpcy5vcHRpb25zLnBhcmFtcywgdHJ1ZSk7ICAgXG4gICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKHBhcmFtcywgdGhpcy5vcHRpb25zLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIHRoaXMub3B0aW9ucy51cmwgPT09ICdmdW5jdGlvbicpIHsgLy91c2VyJ3MgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy51cmwuY2FsbCh0aGlzLm9wdGlvbnMuc2NvcGUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgIFxuICAgICAgICAgICAgICAgICAgICAvL3NlbmQgYWpheCB0byBzZXJ2ZXIgYW5kIHJldHVybiBkZWZlcnJlZCBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQuYWpheCgkLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgICAgIDogdGhpcy5vcHRpb25zLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgICAgOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlICAgIDogJ1BPU1QnXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMub3B0aW9ucy5hamF4T3B0aW9ucykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgXG5cbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy52YWxpZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudmFsaWRhdGUuY2FsbCh0aGlzLm9wdGlvbnMuc2NvcGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvcHRpb246IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmKGtleSBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihrZXkgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9kbyBub3QgcGFzcyBvcHRpb24gdG8gaW5wdXQgYXMgaXQgaXMgcGFzc2VkIGluIGVkaXRhYmxlLWVsZW1lbnRcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24odmFsdWUsIGNvbnZlcnRTdHIpIHtcbiAgICAgICAgICAgIGlmKGNvbnZlcnRTdHIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5pbnB1dC5zdHIydmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaWYgZm9ybSBpcyB2aXNpYmxlLCB1cGRhdGUgaW5wdXRcbiAgICAgICAgICAgIGlmKHRoaXMuJGZvcm0gJiYgdGhpcy4kZm9ybS5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQudmFsdWUyaW5wdXQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB9ICAgICAgICAgICAgXG4gICAgICAgIH0gICAgICAgICAgICAgICBcbiAgICB9O1xuXG4gICAgLypcbiAgICBJbml0aWFsaXplIGVkaXRhYmxlZm9ybS4gQXBwbGllZCB0byBqUXVlcnkgb2JqZWN0LlxuXG4gICAgQG1ldGhvZCAkKCkuZWRpdGFibGVmb3JtKG9wdGlvbnMpXG4gICAgQHBhcmFtcyB7T2JqZWN0fSBvcHRpb25zXG4gICAgQGV4YW1wbGVcbiAgICB2YXIgJGZvcm0gPSAkKCcmbHQ7ZGl2Jmd0OycpLmVkaXRhYmxlZm9ybSh7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgbmFtZTogJ3VzZXJuYW1lJyxcbiAgICAgICAgdXJsOiAnL3Bvc3QnLFxuICAgICAgICB2YWx1ZTogJ3ZpdGFsaXknXG4gICAgfSk7XG5cbiAgICAvL3RvIGRpc3BsYXkgZm9ybSB5b3Ugc2hvdWxkIGNhbGwgJ3JlbmRlcicgbWV0aG9kXG4gICAgJGZvcm0uZWRpdGFibGVmb3JtKCdyZW5kZXInKTsgICAgIFxuICAgICovXG4gICAgJC5mbi5lZGl0YWJsZWZvcm0gPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksIFxuICAgICAgICAgICAgZGF0YSA9ICR0aGlzLmRhdGEoJ2VkaXRhYmxlZm9ybScpLCBcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09PSAnb2JqZWN0JyAmJiBvcHRpb247IFxuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuZGF0YSgnZWRpdGFibGVmb3JtJywgKGRhdGEgPSBuZXcgRWRpdGFibGVGb3JtKHRoaXMsIG9wdGlvbnMpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnc3RyaW5nJykgeyAvL2NhbGwgbWV0aG9kIFxuICAgICAgICAgICAgICAgIGRhdGFbb3B0aW9uXS5hcHBseShkYXRhLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG4gICAgICAgICAgICB9IFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy9rZWVwIGxpbmsgdG8gY29uc3RydWN0b3IgdG8gYWxsb3cgaW5oZXJpdGFuY2VcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5Db25zdHJ1Y3RvciA9IEVkaXRhYmxlRm9ybTsgICAgXG5cbiAgICAvL2RlZmF1bHRzXG4gICAgJC5mbi5lZGl0YWJsZWZvcm0uZGVmYXVsdHMgPSB7XG4gICAgICAgIC8qIHNlZSBhbHNvIGRlZmF1bHRzIGZvciBpbnB1dCAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICBUeXBlIG9mIGlucHV0LiBDYW4gYmUgPGNvZGU+dGV4dHx0ZXh0YXJlYXxzZWxlY3R8ZGF0ZXxjaGVja2xpc3Q8L2NvZGU+XG5cbiAgICAgICAgQHByb3BlcnR5IHR5cGUgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAndGV4dCdcbiAgICAgICAgKiovXG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgLyoqXG4gICAgICAgIFVybCBmb3Igc3VibWl0LCBlLmcuIDxjb2RlPicvcG9zdCc8L2NvZGU+ICBcbiAgICAgICAgSWYgZnVuY3Rpb24gLSBpdCB3aWxsIGJlIGNhbGxlZCBpbnN0ZWFkIG9mIGFqYXguIEZ1bmN0aW9uIHNob3VsZCByZXR1cm4gZGVmZXJyZWQgb2JqZWN0IHRvIHJ1biBmYWlsL2RvbmUgY2FsbGJhY2tzLlxuXG4gICAgICAgIEBwcm9wZXJ0eSB1cmwgXG4gICAgICAgIEB0eXBlIHN0cmluZ3xmdW5jdGlvblxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBleGFtcGxlXG4gICAgICAgIHVybDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgZCA9IG5ldyAkLkRlZmVycmVkO1xuICAgICAgICAgICAgaWYocGFyYW1zLnZhbHVlID09PSAnYWJjJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLnJlamVjdCgnZXJyb3IgbWVzc2FnZScpOyAvL3JldHVybmluZyBlcnJvciB2aWEgZGVmZXJyZWQgb2JqZWN0XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vYXN5bmMgc2F2aW5nIGRhdGEgaW4ganMgbW9kZWxcbiAgICAgICAgICAgICAgICBzb21lTW9kZWwuYXN5bmNTYXZlTWV0aG9kKHtcbiAgICAgICAgICAgICAgICAgICAuLi4sIFxuICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pOyBcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5wcm9taXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIHVybDpudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgQWRkaXRpb25hbCBwYXJhbXMgZm9yIHN1Ym1pdC4gSWYgZGVmaW5lZCBhcyA8Y29kZT5vYmplY3Q8L2NvZGU+IC0gaXQgaXMgKiphcHBlbmRlZCoqIHRvIG9yaWdpbmFsIGFqYXggZGF0YSAocGssIG5hbWUgYW5kIHZhbHVlKS4gIFxuICAgICAgICBJZiBkZWZpbmVkIGFzIDxjb2RlPmZ1bmN0aW9uPC9jb2RlPiAtIHJldHVybmVkIG9iamVjdCAqKm92ZXJ3cml0ZXMqKiBvcmlnaW5hbCBhamF4IGRhdGEuXG4gICAgICAgIEBleGFtcGxlXG4gICAgICAgIHBhcmFtczogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgICAgICAvL29yaWdpbmFsbHkgcGFyYW1zIGNvbnRhaW4gcGssIG5hbWUgYW5kIHZhbHVlXG4gICAgICAgICAgICBwYXJhbXMuYSA9IDE7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICB9XG5cbiAgICAgICAgQHByb3BlcnR5IHBhcmFtcyBcbiAgICAgICAgQHR5cGUgb2JqZWN0fGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovICAgICAgICAgIFxuICAgICAgICBwYXJhbXM6bnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIE5hbWUgb2YgZmllbGQuIFdpbGwgYmUgc3VibWl0dGVkIG9uIHNlcnZlci4gQ2FuIGJlIHRha2VuIGZyb20gPGNvZGU+aWQ8L2NvZGU+IGF0dHJpYnV0ZVxuXG4gICAgICAgIEBwcm9wZXJ0eSBuYW1lIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIFByaW1hcnkga2V5IG9mIGVkaXRhYmxlIG9iamVjdCAoZS5nLiByZWNvcmQgaWQgaW4gZGF0YWJhc2UpLiBGb3IgY29tcG9zaXRlIGtleXMgdXNlIG9iamVjdCwgZS5nLiA8Y29kZT57aWQ6IDEsIGxhbmc6ICdlbid9PC9jb2RlPi5cbiAgICAgICAgQ2FuIGJlIGNhbGN1bGF0ZWQgZHluYW1pY2FsbHkgdmlhIGZ1bmN0aW9uLlxuXG4gICAgICAgIEBwcm9wZXJ0eSBwayBcbiAgICAgICAgQHR5cGUgc3RyaW5nfG9iamVjdHxmdW5jdGlvblxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBwazogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIEluaXRpYWwgdmFsdWUuIElmIG5vdCBkZWZpbmVkIC0gd2lsbCBiZSB0YWtlbiBmcm9tIGVsZW1lbnQncyBjb250ZW50LlxuICAgICAgICBGb3IgX19zZWxlY3RfXyB0eXBlIHNob3VsZCBiZSBkZWZpbmVkIChhcyBpdCBpcyBJRCBvZiBzaG93biB0ZXh0KS5cblxuICAgICAgICBAcHJvcGVydHkgdmFsdWUgXG4gICAgICAgIEB0eXBlIHN0cmluZ3xvYmplY3RcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIFZhbHVlIHRoYXQgd2lsbCBiZSBkaXNwbGF5ZWQgaW4gaW5wdXQgaWYgb3JpZ2luYWwgZmllbGQgdmFsdWUgaXMgZW1wdHkgKGBudWxsfHVuZGVmaW5lZHwnJ2ApLlxuXG4gICAgICAgIEBwcm9wZXJ0eSBkZWZhdWx0VmFsdWUgXG4gICAgICAgIEB0eXBlIHN0cmluZ3xvYmplY3RcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICBAc2luY2UgMS40LjZcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgU3RyYXRlZ3kgZm9yIHNlbmRpbmcgZGF0YSBvbiBzZXJ2ZXIuIENhbiBiZSBgYXV0b3xhbHdheXN8bmV2ZXJgLlxuICAgICAgICBXaGVuICdhdXRvJyBkYXRhIHdpbGwgYmUgc2VudCBvbiBzZXJ2ZXIgKipvbmx5IGlmIHBrIGFuZCB1cmwgZGVmaW5lZCoqLCBvdGhlcndpc2UgbmV3IHZhbHVlIHdpbGwgYmUgc3RvcmVkIGxvY2FsbHkuXG5cbiAgICAgICAgQHByb3BlcnR5IHNlbmQgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAnYXV0bydcbiAgICAgICAgKiovICAgICAgICAgIFxuICAgICAgICBzZW5kOiAnYXV0bycsIFxuICAgICAgICAvKipcbiAgICAgICAgRnVuY3Rpb24gZm9yIGNsaWVudC1zaWRlIHZhbGlkYXRpb24uIElmIHJldHVybnMgc3RyaW5nIC0gbWVhbnMgdmFsaWRhdGlvbiBub3QgcGFzc2VkIGFuZCBzdHJpbmcgc2hvd2VkIGFzIGVycm9yLlxuICAgICAgICBTaW5jZSAxLjUuMSB5b3UgY2FuIG1vZGlmeSBzdWJtaXR0ZWQgdmFsdWUgYnkgcmV0dXJuaW5nIG9iamVjdCBmcm9tIGB2YWxpZGF0ZWA6IFxuICAgICAgICBge25ld1ZhbHVlOiAnLi4uJ31gIG9yIGB7bmV3VmFsdWU6ICcuLi4nLCBtc2c6ICcuLi4nfWBcblxuICAgICAgICBAcHJvcGVydHkgdmFsaWRhdGUgXG4gICAgICAgIEB0eXBlIGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZigkLnRyaW0odmFsdWUpID09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdUaGlzIGZpZWxkIGlzIHJlcXVpcmVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgdmFsaWRhdGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBTdWNjZXNzIGNhbGxiYWNrLiBDYWxsZWQgd2hlbiB2YWx1ZSBzdWNjZXNzZnVsbHkgc2VudCBvbiBzZXJ2ZXIgYW5kICoqcmVzcG9uc2Ugc3RhdHVzID0gMjAwKiouICBcbiAgICAgICAgVXNlZnVsbCB0byB3b3JrIHdpdGgganNvbiByZXNwb25zZS4gRm9yIGV4YW1wbGUsIGlmIHlvdXIgYmFja2VuZCByZXNwb25zZSBjYW4gYmUgPGNvZGU+e3N1Y2Nlc3M6IHRydWV9PC9jb2RlPlxuICAgICAgICBvciA8Y29kZT57c3VjY2VzczogZmFsc2UsIG1zZzogXCJzZXJ2ZXIgZXJyb3JcIn08L2NvZGU+IHlvdSBjYW4gY2hlY2sgaXQgaW5zaWRlIHRoaXMgY2FsbGJhY2suICBcbiAgICAgICAgSWYgaXQgcmV0dXJucyAqKnN0cmluZyoqIC0gbWVhbnMgZXJyb3Igb2NjdXJlZCBhbmQgc3RyaW5nIGlzIHNob3duIGFzIGVycm9yIG1lc3NhZ2UuICBcbiAgICAgICAgSWYgaXQgcmV0dXJucyAqKm9iamVjdCBsaWtlKiogPGNvZGU+e25ld1ZhbHVlOiAmbHQ7c29tZXRoaW5nJmd0O308L2NvZGU+IC0gaXQgb3ZlcndyaXRlcyB2YWx1ZSwgc3VibWl0dGVkIGJ5IHVzZXIuICBcbiAgICAgICAgT3RoZXJ3aXNlIG5ld1ZhbHVlIHNpbXBseSByZW5kZXJlZCBpbnRvIGVsZW1lbnQuXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgc3VjY2VzcyBcbiAgICAgICAgQHR5cGUgZnVuY3Rpb25cbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICBAZXhhbXBsZVxuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXNwb25zZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGlmKCFyZXNwb25zZS5zdWNjZXNzKSByZXR1cm4gcmVzcG9uc2UubXNnO1xuICAgICAgICB9XG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgc3VjY2VzczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIEVycm9yIGNhbGxiYWNrLiBDYWxsZWQgd2hlbiByZXF1ZXN0IGZhaWxlZCAocmVzcG9uc2Ugc3RhdHVzICE9IDIwMCkuICBcbiAgICAgICAgVXNlZnVsbCB3aGVuIHlvdSB3YW50IHRvIHBhcnNlIGVycm9yIHJlc3BvbnNlIGFuZCBkaXNwbGF5IGEgY3VzdG9tIG1lc3NhZ2UuXG4gICAgICAgIE11c3QgcmV0dXJuICoqc3RyaW5nKiogLSB0aGUgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGVycm9yIGJsb2NrLlxuICAgICAgICAgICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgZXJyb3IgXG4gICAgICAgIEB0eXBlIGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgQHNpbmNlIDEuNC40XG4gICAgICAgIEBleGFtcGxlXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbihyZXNwb25zZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGlmKHJlc3BvbnNlLnN0YXR1cyA9PT0gNTAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdTZXJ2aWNlIHVuYXZhaWxhYmxlLiBQbGVhc2UgdHJ5IGxhdGVyLic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKiovICAgICAgICAgIFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3Igc3VibWl0IGFqYXggcmVxdWVzdC5cbiAgICAgICAgTGlzdCBvZiB2YWx1ZXM6IGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9qUXVlcnkuYWpheFxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IGFqYXhPcHRpb25zIFxuICAgICAgICBAdHlwZSBvYmplY3RcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICBAc2luY2UgMS4xLjEgICAgICAgIFxuICAgICAgICBAZXhhbXBsZSBcbiAgICAgICAgYWpheE9wdGlvbnM6IHtcbiAgICAgICAgICAgIHR5cGU6ICdwdXQnLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgICB9ICAgICAgICBcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgYWpheE9wdGlvbnM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBXaGVyZSB0byBzaG93IGJ1dHRvbnM6IGxlZnQodHJ1ZSl8Ym90dG9tfGZhbHNlICBcbiAgICAgICAgRm9ybSB3aXRob3V0IGJ1dHRvbnMgaXMgYXV0by1zdWJtaXR0ZWQuXG5cbiAgICAgICAgQHByb3BlcnR5IHNob3didXR0b25zIFxuICAgICAgICBAdHlwZSBib29sZWFufHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCB0cnVlXG4gICAgICAgIEBzaW5jZSAxLjEuMVxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgc2hvd2J1dHRvbnM6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICBTY29wZSBmb3IgY2FsbGJhY2sgbWV0aG9kcyAoc3VjY2VzcywgdmFsaWRhdGUpLiAgXG4gICAgICAgIElmIDxjb2RlPm51bGw8L2NvZGU+IG1lYW5zIGVkaXRhYmxlZm9ybSBpbnN0YW5jZSBpdHNlbGYuIFxuXG4gICAgICAgIEBwcm9wZXJ0eSBzY29wZSBcbiAgICAgICAgQHR5cGUgRE9NRWxlbWVudHxvYmplY3RcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICBAc2luY2UgMS4yLjBcbiAgICAgICAgQHByaXZhdGVcbiAgICAgICAgKiovICAgICAgICAgICAgXG4gICAgICAgIHNjb3BlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgV2hldGhlciB0byBzYXZlIG9yIGNhbmNlbCB2YWx1ZSB3aGVuIGl0IHdhcyBub3QgY2hhbmdlZCBidXQgZm9ybSB3YXMgc3VibWl0dGVkXG5cbiAgICAgICAgQHByb3BlcnR5IHNhdmVub2NoYW5nZSBcbiAgICAgICAgQHR5cGUgYm9vbGVhblxuICAgICAgICBAZGVmYXVsdCBmYWxzZVxuICAgICAgICBAc2luY2UgMS4yLjBcbiAgICAgICAgKiovXG4gICAgICAgIHNhdmVub2NoYW5nZTogZmFsc2VcbiAgICB9OyAgIFxuXG4gICAgLypcbiAgICBOb3RlOiBmb2xsb3dpbmcgcGFyYW1zIGNvdWxkIHJlZGVmaW5lZCBpbiBlbmdpbmU6IGJvb3RzdHJhcCBvciBqcXVlcnl1aTpcbiAgICBDbGFzc2VzICdjb250cm9sLWdyb3VwJyBhbmQgJ2VkaXRhYmxlLWVycm9yLWJsb2NrJyBtdXN0IGFsd2F5cyBwcmVzZW50IVxuICAgICovICAgICAgXG4gICAgJC5mbi5lZGl0YWJsZWZvcm0udGVtcGxhdGUgPSAnPGZvcm0gY2xhc3M9XCJmb3JtLWlubGluZSBlZGl0YWJsZWZvcm1cIj4nK1xuICAgICc8ZGl2IGNsYXNzPVwiY29udHJvbC1ncm91cFwiPicgKyBcbiAgICAnPGRpdj48ZGl2IGNsYXNzPVwiZWRpdGFibGUtaW5wdXRcIj48L2Rpdj48ZGl2IGNsYXNzPVwiZWRpdGFibGUtYnV0dG9uc1wiPjwvZGl2PjwvZGl2PicrXG4gICAgJzxkaXYgY2xhc3M9XCJlZGl0YWJsZS1lcnJvci1ibG9ja1wiPjwvZGl2PicgKyBcbiAgICAnPC9kaXY+JyArIFxuICAgICc8L2Zvcm0+JztcblxuICAgIC8vbG9hZGluZyBkaXZcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5sb2FkaW5nID0gJzxkaXYgY2xhc3M9XCJlZGl0YWJsZWZvcm0tbG9hZGluZ1wiPjwvZGl2Pic7XG5cbiAgICAvL2J1dHRvbnNcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5idXR0b25zID0gJzxidXR0b24gdHlwZT1cInN1Ym1pdFwiIGNsYXNzPVwiZWRpdGFibGUtc3VibWl0XCI+b2s8L2J1dHRvbj4nK1xuICAgICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImVkaXRhYmxlLWNhbmNlbFwiPmNhbmNlbDwvYnV0dG9uPic7ICAgICAgXG5cbiAgICAvL2Vycm9yIGNsYXNzIGF0dGFjaGVkIHRvIGNvbnRyb2wtZ3JvdXBcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5lcnJvckdyb3VwQ2xhc3MgPSBudWxsOyAgXG5cbiAgICAvL2Vycm9yIGNsYXNzIGF0dGFjaGVkIHRvIGVkaXRhYmxlLWVycm9yLWJsb2NrXG4gICAgJC5mbi5lZGl0YWJsZWZvcm0uZXJyb3JCbG9ja0NsYXNzID0gJ2VkaXRhYmxlLWVycm9yJztcbiAgICBcbiAgICAvL2VuZ2luZVxuICAgICQuZm4uZWRpdGFibGVmb3JtLmVuZ2luZSA9ICdqcXVlcnknO1xufSh3aW5kb3cualF1ZXJ5KSk7XG5cbi8qKlxuKiBFZGl0YWJsZUZvcm0gdXRpbGl0ZXNcbiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBcbiAgICAvL3V0aWxzXG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgKiBjbGFzc2ljIEpTIGluaGVyaXRhbmNlIGZ1bmN0aW9uXG4gICAgICAgICovICBcbiAgICAgICAgaW5oZXJpdDogZnVuY3Rpb24gKENoaWxkLCBQYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBGID0gZnVuY3Rpb24oKSB7IH07XG4gICAgICAgICAgICBGLnByb3RvdHlwZSA9IFBhcmVudC5wcm90b3R5cGU7XG4gICAgICAgICAgICBDaGlsZC5wcm90b3R5cGUgPSBuZXcgRigpO1xuICAgICAgICAgICAgQ2hpbGQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2hpbGQ7XG4gICAgICAgICAgICBDaGlsZC5zdXBlcmNsYXNzID0gUGFyZW50LnByb3RvdHlwZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgKiBzZXQgY2FyZXQgcG9zaXRpb24gaW4gaW5wdXRcbiAgICAgICAgKiBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTkxMjYvanF1ZXJ5LXNldC1jdXJzb3ItcG9zaXRpb24taW4tdGV4dC1hcmVhXG4gICAgICAgICovICAgICAgICBcbiAgICAgICAgc2V0Q3Vyc29yUG9zaXRpb246IGZ1bmN0aW9uKGVsZW0sIHBvcykge1xuICAgICAgICAgICAgaWYgKGVsZW0uc2V0U2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBlbGVtLnNldFNlbGVjdGlvblJhbmdlKHBvcywgcG9zKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbS5jcmVhdGVUZXh0UmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBlbGVtLmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIHBvcyk7XG4gICAgICAgICAgICAgICAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBwb3MpO1xuICAgICAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIGZ1bmN0aW9uIHRvIHBhcnNlIEpTT04gaW4gKnNpbmdsZSogcXVvdGVzLiAoanF1ZXJ5IGF1dG9tYXRpY2FsbHkgcGFyc2Ugb25seSBkb3VibGUgcXVvdGVzKVxuICAgICAgICAqIFRoYXQgYWxsb3dzIHN1Y2ggY29kZSBhczogPGEgZGF0YS1zb3VyY2U9XCJ7J2EnOiAnYicsICdjJzogJ2QnfVwiPlxuICAgICAgICAqIHNhZmUgPSB0cnVlIC0tPiBtZWFucyBubyBleGNlcHRpb24gd2lsbCBiZSB0aHJvd25cbiAgICAgICAgKiBmb3IgZGV0YWlscyBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NDEwMzQ4L2hvdy10by1zZXQtanNvbi1mb3JtYXQtdG8taHRtbDUtZGF0YS1hdHRyaWJ1dGVzLWluLXRoZS1qcXVlcnlcbiAgICAgICAgKi9cbiAgICAgICAgdHJ5UGFyc2VKc29uOiBmdW5jdGlvbihzLCBzYWZlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnICYmIHMubGVuZ3RoICYmIHMubWF0Y2goL15bXFx7XFxbXS4qW1xcfVxcXV0kLykpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2FmZSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLypqc2xpbnQgZXZpbDogdHJ1ZSovXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gKG5ldyBGdW5jdGlvbigncmV0dXJuICcgKyBzKSkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qanNsaW50IGV2aWw6IGZhbHNlKi9cbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge30gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qanNsaW50IGV2aWw6IHRydWUqL1xuICAgICAgICAgICAgICAgICAgICBzID0gKG5ldyBGdW5jdGlvbigncmV0dXJuICcgKyBzKSkoKTtcbiAgICAgICAgICAgICAgICAgICAgLypqc2xpbnQgZXZpbDogZmFsc2UqL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIHNsaWNlIG9iamVjdCBieSBzcGVjaWZpZWQga2V5c1xuICAgICAgICAqL1xuICAgICAgICBzbGljZU9iajogZnVuY3Rpb24ob2JqLCBrZXlzLCBjYXNlU2Vuc2l0aXZlIC8qIGRlZmF1bHQ6IGZhbHNlICovKSB7XG4gICAgICAgICAgICB2YXIga2V5LCBrZXlMb3dlciwgbmV3T2JqID0ge307XG5cbiAgICAgICAgICAgIGlmICghJC5pc0FycmF5KGtleXMpIHx8ICFrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoY2FzZVNlbnNpdGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL3doZW4gZ2V0dGluZyBkYXRhLSogYXR0cmlidXRlcyB2aWEgJC5kYXRhKCkgaXQncyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlLlxuICAgICAgICAgICAgICAgIC8vZGV0YWlsczogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NjAyNTY1L3VzaW5nLWRhdGEtYXR0cmlidXRlcy13aXRoLWpxdWVyeVxuICAgICAgICAgICAgICAgIC8vd29ya2Fyb3VuZCBpcyBjb2RlIGJlbG93LlxuICAgICAgICAgICAgICAgIGtleUxvd2VyID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXlMb3dlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBvYmpba2V5TG93ZXJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ld09iajtcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICBleGNsdWRlIGNvbXBsZXggb2JqZWN0cyBmcm9tICQuZGF0YSgpIGJlZm9yZSBwYXNzIHRvIGNvbmZpZ1xuICAgICAgICAqL1xuICAgICAgICBnZXRDb25maWdEYXRhOiBmdW5jdGlvbigkZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgICAgICQuZWFjaCgkZWxlbWVudC5kYXRhKCksIGZ1bmN0aW9uKGssIHYpIHtcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgdiAhPT0gJ29iamVjdCcgfHwgKHYgJiYgdHlwZW9mIHYgPT09ICdvYmplY3QnICYmICh2LmNvbnN0cnVjdG9yID09PSBPYmplY3QgfHwgdi5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2tdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qXG4gICAgICAgICByZXR1cm5zIGtleXMgb2Ygb2JqZWN0XG4gICAgICAgICovXG4gICAgICAgIG9iamVjdEtleXM6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvKTsgIFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobyAhPT0gT2JqZWN0KG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGs9W10sIHA7XG4gICAgICAgICAgICAgICAgZm9yIChwIGluIG8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgLyoqXG4gICAgICAgIG1ldGhvZCB0byBlc2NhcGUgaHRtbC5cbiAgICAgICAqKi9cbiAgICAgICBlc2NhcGU6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICByZXR1cm4gJCgnPGRpdj4nKS50ZXh0KHN0cikuaHRtbCgpO1xuICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgLypcbiAgICAgICAgcmV0dXJucyBhcnJheSBpdGVtcyBmcm9tIHNvdXJjZURhdGEgaGF2aW5nIHZhbHVlIHByb3BlcnR5IGVxdWFsIG9yIGluQXJyYXkgb2YgJ3ZhbHVlJ1xuICAgICAgICovXG4gICAgICAgaXRlbXNCeVZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgc291cmNlRGF0YSwgdmFsdWVQcm9wKSB7XG4gICAgICAgICAgIGlmKCFzb3VyY2VEYXRhIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgXG4gICAgICAgICAgIGlmICh0eXBlb2YodmFsdWVQcm9wKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICB2YXIgaWRLZXkgPSB2YWx1ZVByb3AgfHwgJ3ZhbHVlJztcbiAgICAgICAgICAgICAgIHZhbHVlUHJvcCA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlW2lkS2V5XTsgfTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICB2YXIgaXNWYWxBcnJheSA9ICQuaXNBcnJheSh2YWx1ZSksXG4gICAgICAgICAgIHJlc3VsdCA9IFtdLCBcbiAgICAgICAgICAgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgJC5lYWNoKHNvdXJjZURhdGEsIGZ1bmN0aW9uKGksIG8pIHtcbiAgICAgICAgICAgICAgIGlmKG8uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoYXQuaXRlbXNCeVZhbHVlKHZhbHVlLCBvLmNoaWxkcmVuLCB2YWx1ZVByb3ApKTtcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgLypqc2xpbnQgZXFlcTogdHJ1ZSovXG4gICAgICAgICAgICAgICAgICAgaWYoaXNWYWxBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICBpZigkLmdyZXAodmFsdWUsIGZ1bmN0aW9uKHYpeyAgcmV0dXJuIHYgPT0gKG8gJiYgdHlwZW9mIG8gPT09ICdvYmplY3QnID8gdmFsdWVQcm9wKG8pIDogbyk7IH0pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobyk7IFxuICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1WYWx1ZSA9IChvICYmICh0eXBlb2YgbyA9PT0gJ29iamVjdCcpKSA/IHZhbHVlUHJvcChvKSA6IG87XG4gICAgICAgICAgICAgICAgICAgICAgIGlmKHZhbHVlID09IGl0ZW1WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobyk7IFxuICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIC8qanNsaW50IGVxZXE6IGZhbHNlKi9cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfSk7XG4gICAgICAgICAgIFxuICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgLypcbiAgICAgICBSZXR1cm5zIGlucHV0IGJ5IG9wdGlvbnM6IHR5cGUsIG1vZGUuIFxuICAgICAgICovXG4gICAgICAgY3JlYXRlSW5wdXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgdmFyIFR5cGVDb25zdHJ1Y3RvciwgdHlwZU9wdGlvbnMsIGlucHV0LFxuICAgICAgICAgICB0eXBlID0gb3B0aW9ucy50eXBlO1xuXG4gICAgICAgICAgIC8vYGRhdGVgIGlzIHNvbWUga2luZCBvZiB2aXJ0dWFsIHR5cGUgdGhhdCBpcyB0cmFuc2Zvcm1lZCB0byBvbmUgb2YgZXhhY3QgdHlwZXNcbiAgICAgICAgICAgLy9kZXBlbmRpbmcgb24gbW9kZSBhbmQgY29yZSBsaWJcbiAgICAgICAgICAgaWYodHlwZSA9PT0gJ2RhdGUnKSB7XG4gICAgICAgICAgICAgICAvL2lubGluZVxuICAgICAgICAgICAgICAgaWYob3B0aW9ucy5tb2RlID09PSAnaW5saW5lJykge1xuICAgICAgICAgICAgICAgICAgIGlmKCQuZm4uZWRpdGFibGV0eXBlcy5kYXRlZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdkYXRlZmllbGQnO1xuICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZigkLmZuLmVkaXRhYmxldHlwZXMuZGF0ZXVpZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdkYXRldWlmaWVsZCc7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgLy9wb3B1cFxuICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICBpZigkLmZuLmVkaXRhYmxldHlwZXMuZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ2RhdGUnO1xuICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZigkLmZuLmVkaXRhYmxldHlwZXMuZGF0ZXVpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnZGF0ZXVpJztcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgIC8vaWYgdHlwZSBzdGlsbCBgZGF0ZWAgYW5kIG5vdCBleGlzdCBpbiB0eXBlcywgcmVwbGFjZSB3aXRoIGBjb21ib2RhdGVgIHRoYXQgaXMgYmFzZSBpbnB1dFxuICAgICAgICAgICAgICAgaWYodHlwZSA9PT0gJ2RhdGUnICYmICEkLmZuLmVkaXRhYmxldHlwZXMuZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnY29tYm9kYXRlJztcbiAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgIH1cbiAgICAgICAgICAgXG4gICAgICAgICAgIC8vYGRhdGV0aW1lYCBzaG91bGQgYmUgZGF0ZXRpbWVmaWVsZCBpbiAnaW5saW5lJyBtb2RlXG4gICAgICAgICAgIGlmKHR5cGUgPT09ICdkYXRldGltZScgJiYgb3B0aW9ucy5tb2RlID09PSAnaW5saW5lJykge1xuICAgICAgICAgICAgIHR5cGUgPSAnZGF0ZXRpbWVmaWVsZCc7ICBcbiAgICAgICAgICAgfSAgICAgICAgICAgXG5cbiAgICAgICAgICAgLy9jaGFuZ2Ugd3lzaWh0bWw1IHRvIHRleHRhcmVhIGZvciBqcXVlcnkgVUkgYW5kIHBsYWluIHZlcnNpb25zXG4gICAgICAgICAgIGlmKHR5cGUgPT09ICd3eXNpaHRtbDUnICYmICEkLmZuLmVkaXRhYmxldHlwZXNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgIHR5cGUgPSAndGV4dGFyZWEnO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgLy9jcmVhdGUgaW5wdXQgb2Ygc3BlY2lmaWVkIHR5cGUuIElucHV0IHdpbGwgYmUgdXNlZCBmb3IgY29udmVydGluZyB2YWx1ZSwgbm90IGluIGZvcm1cbiAgICAgICAgICAgaWYodHlwZW9mICQuZm4uZWRpdGFibGV0eXBlc1t0eXBlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgVHlwZUNvbnN0cnVjdG9yID0gJC5mbi5lZGl0YWJsZXR5cGVzW3R5cGVdO1xuICAgICAgICAgICAgICAgdHlwZU9wdGlvbnMgPSB0aGlzLnNsaWNlT2JqKG9wdGlvbnMsIHRoaXMub2JqZWN0S2V5cyhUeXBlQ29uc3RydWN0b3IuZGVmYXVsdHMpKTtcbiAgICAgICAgICAgICAgIGlucHV0ID0gbmV3IFR5cGVDb25zdHJ1Y3Rvcih0eXBlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAkLmVycm9yKCdVbmtub3duIHR5cGU6ICcrIHR5cGUpO1xuICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyBcbiAgICAgICAgICAgfSAgXG4gICAgICAgfSxcbiAgICAgICBcbiAgICAgICAvL3NlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzcyNjQ4OTkvZGV0ZWN0LWNzcy10cmFuc2l0aW9ucy11c2luZy1qYXZhc2NyaXB0LWFuZC13aXRob3V0LW1vZGVybml6clxuICAgICAgIHN1cHBvcnRzVHJhbnNpdGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgdmFyIGIgPSBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgIHMgPSBiLnN0eWxlLFxuICAgICAgICAgICAgICAgcCA9ICd0cmFuc2l0aW9uJyxcbiAgICAgICAgICAgICAgIHYgPSBbJ01veicsICdXZWJraXQnLCAnS2h0bWwnLCAnTycsICdtcyddO1xuICAgICAgICAgICAgICAgXG4gICAgICAgICAgIGlmKHR5cGVvZiBzW3BdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IFxuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgLy8gVGVzdHMgZm9yIHZlbmRvciBzcGVjaWZpYyBwcm9wXG4gICAgICAgICAgIHAgPSBwLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcC5zdWJzdHIoMSk7XG4gICAgICAgICAgIGZvcih2YXIgaT0wOyBpPHYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgIGlmKHR5cGVvZiBzW3ZbaV0gKyBwXSA9PT0gJ3N0cmluZycpIHsgXG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IFxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICB9ICAgICAgICAgICAgXG4gICAgICAgXG4gICAgfTsgICAgICBcbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKipcbkF0dGFjaGVzIHN0YW5kLWFsb25lIGNvbnRhaW5lciB3aXRoIGVkaXRhYmxlLWZvcm0gdG8gSFRNTCBlbGVtZW50LiBFbGVtZW50IGlzIHVzZWQgb25seSBmb3IgcG9zaXRpb25pbmcsIHZhbHVlIGlzIG5vdCBzdG9yZWQgYW55d2hlcmUuPGJyPlxuVGhpcyBtZXRob2QgYXBwbGllZCBpbnRlcm5hbGx5IGluIDxjb2RlPiQoKS5lZGl0YWJsZSgpPC9jb2RlPi4gWW91IHNob3VsZCBzdWJzY3JpYmUgb24gaXQncyBldmVudHMgKHNhdmUgLyBjYW5jZWwpIHRvIGdldCBwcm9maXQgb2YgaXQuPGJyPlxuRmluYWwgcmVhbGl6YXRpb24gY2FuIGJlIGRpZmZlcmVudDogYm9vdHN0cmFwLXBvcG92ZXIsIGpxdWVyeXVpLXRvb2x0aXAsIHBvc2h5dGlwLCBpbmxpbmUtZGl2LiBJdCBkZXBlbmRzIG9uIHdoaWNoIGpzIGZpbGUgeW91IGluY2x1ZGUuPGJyPlxuQXBwbGllZCBhcyBqUXVlcnkgbWV0aG9kLlxuXG5AY2xhc3MgZWRpdGFibGVDb250YWluZXJcbkB1c2VzIGVkaXRhYmxlZm9ybVxuKiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBQb3B1cCA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdChlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBJbmxpbmUgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfTsgICAgXG5cbiAgICAvL21ldGhvZHNcbiAgICBQb3B1cC5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnRhaW5lck5hbWU6IG51bGwsIC8vbWV0aG9kIHRvIGNhbGwgY29udGFpbmVyIG9uIGVsZW1lbnRcbiAgICAgICAgY29udGFpbmVyRGF0YU5hbWU6IG51bGwsIC8vb2JqZWN0IG5hbWUgaW4gZWxlbWVudCdzIC5kYXRhKClcbiAgICAgICAgaW5uZXJDc3M6IG51bGwsIC8vdGJkIGluIGNoaWxkIGNsYXNzXG4gICAgICAgIGNvbnRhaW5lckNsYXNzOiAnZWRpdGFibGUtY29udGFpbmVyIGVkaXRhYmxlLXBvcHVwJywgLy9jc3MgY2xhc3MgYXBwbGllZCB0byBjb250YWluZXIgZWxlbWVudFxuICAgICAgICBkZWZhdWx0czoge30sIC8vY29udGFpbmVyIGl0c2VsZiBkZWZhdWx0c1xuICAgICAgICBcbiAgICAgICAgaW5pdDogZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy4kZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgICAgICAgICAvL3NpbmNlIDEuNC4xIGNvbnRhaW5lciBkbyBub3QgdXNlIGRhdGEtKiBkaXJlY3RseSBhcyB0aGV5IGFscmVhZHkgbWVyZ2VkIGludG8gb3B0aW9ucy5cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxlQ29udGFpbmVyLmRlZmF1bHRzLCBvcHRpb25zKTsgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuc3BsaXRPcHRpb25zKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vc2V0IHNjb3BlIG9mIGZvcm0gY2FsbGJhY2tzIHRvIGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuZm9ybU9wdGlvbnMuc2NvcGUgPSB0aGlzLiRlbGVtZW50WzBdOyBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5pbml0Q29udGFpbmVyKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vZmxhZyB0byBoaWRlIGNvbnRhaW5lciwgd2hlbiBzYXZpbmcgdmFsdWUgd2lsbCBmaW5pc2hcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZEhpZGUgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy9iaW5kICdkZXN0cm95ZWQnIGxpc3RlbmVyIHRvIGRlc3Ryb3kgY29udGFpbmVyIHdoZW4gZWxlbWVudCBpcyByZW1vdmVkIGZyb20gZG9tXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdkZXN0cm95ZWQnLCAkLnByb3h5KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICB9LCB0aGlzKSk7IFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2F0dGFjaCBkb2N1bWVudCBoYW5kbGVyIHRvIGNsb3NlIGNvbnRhaW5lcnMgb24gY2xpY2sgLyBlc2NhcGVcbiAgICAgICAgICAgIGlmKCEkKGRvY3VtZW50KS5kYXRhKCdlZGl0YWJsZS1oYW5kbGVycy1hdHRhY2hlZCcpKSB7XG4gICAgICAgICAgICAgICAgLy9jbG9zZSBhbGwgb24gZXNjYXBlXG4gICAgICAgICAgICAgICAgJChkb2N1bWVudCkub24oJ2tleXVwLmVkaXRhYmxlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IDI3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcuZWRpdGFibGUtb3BlbicpLmVkaXRhYmxlQ29udGFpbmVyKCdoaWRlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RvZG86IHJldHVybiBmb2N1cyBvbiBlbGVtZW50IFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvL2Nsb3NlIGNvbnRhaW5lcnMgd2hlbiBjbGljayBvdXRzaWRlIFxuICAgICAgICAgICAgICAgIC8vKG1vdXNlZG93biBjb3VsZCBiZSBiZXR0ZXIgdGhhbiBjbGljaywgaXQgY2xvc2VzIGV2ZXJ5dGhpbmcgYWxzbyBvbiBkcmFnIGRyb3ApXG4gICAgICAgICAgICAgICAgJChkb2N1bWVudCkub24oJ2NsaWNrLmVkaXRhYmxlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgJHRhcmdldCA9ICQoZS50YXJnZXQpLCBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhjbHVkZV9jbGFzc2VzID0gWycuZWRpdGFibGUtY29udGFpbmVyJywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy51aS1kYXRlcGlja2VyLWhlYWRlcicsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcuZGF0ZXBpY2tlcicsIC8vaW4gaW5saW5lIG1vZGUgZGF0ZXBpY2tlciBpcyByZW5kZXJlZCBpbnRvIGJvZHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLm1vZGFsLWJhY2tkcm9wJywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy5ib290c3RyYXAtd3lzaWh0bWw1LWluc2VydC1pbWFnZS1tb2RhbCcsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcuYm9vdHN0cmFwLXd5c2lodG1sNS1pbnNlcnQtbGluay1tb2RhbCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpZiBlbGVtZW50IGlzIGRldGFjaGVkLiBJdCBvY2N1cnMgd2hlbiBjbGlja2luZyBpbiBib290c3RyYXAgZGF0ZXBpY2tlclxuICAgICAgICAgICAgICAgICAgICBpZiAoISQuY29udGFpbnMoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBlLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL2ZvciBzb21lIHJlYXNvbiBGRiAyMCBnZW5lcmF0ZXMgZXh0cmEgZXZlbnQgKGNsaWNrKSBpbiBzZWxlY3QyIHdpZGdldCB3aXRoIGUudGFyZ2V0ID0gZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy93ZSBuZWVkIHRvIGZpbHRlciBpdCB2aWEgY29uc3RydWN0aW9uIGJlbG93LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpdGFsZXRzL3gtZWRpdGFibGUvaXNzdWVzLzE5OVxuICAgICAgICAgICAgICAgICAgICAvL1Bvc3NpYmx5IHJlbGF0ZWQgdG8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDExOTc5My93aHktZG9lcy1maXJlZm94LXJlYWN0LWRpZmZlcmVudGx5LWZyb20td2Via2l0LWFuZC1pZS10by1jbGljay1ldmVudC1vbi1zZWxlY1xuICAgICAgICAgICAgICAgICAgICBpZigkdGFyZ2V0LmlzKGRvY3VtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL2lmIGNsaWNrIGluc2lkZSBvbmUgb2YgZXhjbHVkZSBjbGFzc2VzIC0tPiBubyBub3RoaW5nXG4gICAgICAgICAgICAgICAgICAgIGZvcihpPTA7IGk8ZXhjbHVkZV9jbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgaWYoJHRhcmdldC5pcyhleGNsdWRlX2NsYXNzZXNbaV0pIHx8ICR0YXJnZXQucGFyZW50cyhleGNsdWRlX2NsYXNzZXNbaV0pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vY2xvc2UgYWxsIG9wZW4gY29udGFpbmVycyAoZXhjZXB0IG9uZSAtIHRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgUG9wdXAucHJvdG90eXBlLmNsb3NlT3RoZXJzKGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAkKGRvY3VtZW50KS5kYXRhKCdlZGl0YWJsZS1oYW5kbGVycy1hdHRhY2hlZCcsIHRydWUpO1xuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB9LFxuXG4gICAgICAgIC8vc3BsaXQgb3B0aW9ucyBvbiBjb250YWluZXJPcHRpb25zIGFuZCBmb3JtT3B0aW9uc1xuICAgICAgICBzcGxpdE9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJPcHRpb25zID0ge307XG4gICAgICAgICAgICB0aGlzLmZvcm1PcHRpb25zID0ge307XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCEkLmZuW3RoaXMuY29udGFpbmVyTmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5jb250YWluZXJOYW1lICsgJyBub3QgZm91bmQuIEhhdmUgeW91IGluY2x1ZGVkIGNvcnJlc3BvbmRpbmcganMgZmlsZT8nKTsgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9rZXlzIGRlZmluZWQgaW4gY29udGFpbmVyIGRlZmF1bHRzIGdvIHRvIGNvbnRhaW5lciwgb3RoZXJzIGdvIHRvIGZvcm1cbiAgICAgICAgICAgIGZvcih2YXIgayBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgaWYoayBpbiB0aGlzLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyT3B0aW9uc1trXSA9IHRoaXMub3B0aW9uc1trXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgdGhpcy5mb3JtT3B0aW9uc1trXSA9IHRoaXMub3B0aW9uc1trXTtcbiAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgIFJldHVybnMganF1ZXJ5IG9iamVjdCBvZiBjb250YWluZXJcbiAgICAgICAgQG1ldGhvZCB0aXAoKVxuICAgICAgICAqLyAgICAgICAgIFxuICAgICAgICB0aXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyKCkgPyB0aGlzLmNvbnRhaW5lcigpLiR0aXAgOiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qIHJldHVybnMgY29udGFpbmVyIG9iamVjdCAqL1xuICAgICAgICBjb250YWluZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lcjtcbiAgICAgICAgICAgIC8vZmlyc3QsIHRyeSBnZXQgaXQgYnkgYGNvbnRhaW5lckRhdGFOYW1lYFxuICAgICAgICAgICAgaWYodGhpcy5jb250YWluZXJEYXRhTmFtZSkge1xuICAgICAgICAgICAgICAgIGlmKGNvbnRhaW5lciA9IHRoaXMuJGVsZW1lbnQuZGF0YSh0aGlzLmNvbnRhaW5lckRhdGFOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vc2Vjb25kLCB0cnkgYGNvbnRhaW5lck5hbWVgXG4gICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLiRlbGVtZW50LmRhdGEodGhpcy5jb250YWluZXJOYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyogY2FsbCBuYXRpdmUgbWV0aG9kIG9mIHVuZGVybHlpbmcgY29udGFpbmVyLCBlLmcuIHRoaXMuJGVsZW1lbnQucG9wb3ZlcignbWV0aG9kJykgKi8gXG4gICAgICAgIGNhbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kZWxlbWVudFt0aGlzLmNvbnRhaW5lck5hbWVdLmFwcGx5KHRoaXMuJGVsZW1lbnQsIGFyZ3VtZW50cyk7IFxuICAgICAgICB9LCAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBpbml0Q29udGFpbmVyOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5jYWxsKHRoaXMuY29udGFpbmVyT3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyRm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLiRmb3JtXG4gICAgICAgICAgICAuZWRpdGFibGVmb3JtKHRoaXMuZm9ybU9wdGlvbnMpXG4gICAgICAgICAgICAub24oe1xuICAgICAgICAgICAgICAgIHNhdmU6ICQucHJveHkodGhpcy5zYXZlLCB0aGlzKSwgLy9jbGljayBvbiBzdWJtaXQgYnV0dG9uICh2YWx1ZSBjaGFuZ2VkKVxuICAgICAgICAgICAgICAgIG5vY2hhbmdlOiAkLnByb3h5KGZ1bmN0aW9uKCl7IHRoaXMuaGlkZSgnbm9jaGFuZ2UnKTsgfSwgdGhpcyksIC8vY2xpY2sgb24gc3VibWl0IGJ1dHRvbiAodmFsdWUgTk9UIGNoYW5nZWQpICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNhbmNlbDogJC5wcm94eShmdW5jdGlvbigpeyB0aGlzLmhpZGUoJ2NhbmNlbCcpOyB9LCB0aGlzKSwgLy9jbGljayBvbiBjYWxjZWwgYnV0dG9uXG4gICAgICAgICAgICAgICAgc2hvdzogJC5wcm94eShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5kZWxheWVkSGlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlKHRoaXMuZGVsYXllZEhpZGUucmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsYXllZEhpZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpLCAvL3JlLXBvc2l0aW9uIGNvbnRhaW5lciBldmVyeSB0aW1lIGZvcm0gaXMgc2hvd24gKG9jY3VycyBlYWNoIHRpbWUgYWZ0ZXIgbG9hZGluZyBzdGF0ZSlcbiAgICAgICAgICAgICAgICByZW5kZXJpbmc6ICQucHJveHkodGhpcy5zZXRQb3NpdGlvbiwgdGhpcyksIC8vdGhpcyBhbGxvd3MgdG8gcGxhY2UgY29udGFpbmVyIGNvcnJlY3RseSB3aGVuIGxvYWRpbmcgc2hvd25cbiAgICAgICAgICAgICAgICByZXNpemU6ICQucHJveHkodGhpcy5zZXRQb3NpdGlvbiwgdGhpcyksIC8vdGhpcyBhbGxvd3MgdG8gcmUtcG9zaXRpb24gY29udGFpbmVyIHdoZW4gZm9ybSBzaXplIGlzIGNoYW5nZWQgXG4gICAgICAgICAgICAgICAgcmVuZGVyZWQ6ICQucHJveHkoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgLyoqICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgRmlyZWQgd2hlbiBjb250YWluZXIgaXMgc2hvd24gYW5kIGZvcm0gaXMgcmVuZGVyZWQgKGZvciBzZWxlY3Qgd2lsbCB3YWl0IGZvciBsb2FkaW5nIGRyb3Bkb3duIG9wdGlvbnMpLiAgXG4gICAgICAgICAgICAgICAgICAgICoqTm90ZToqKiBCb290c3RyYXAgcG9wb3ZlciBoYXMgb3duIGBzaG93bmAgZXZlbnQgdGhhdCBub3cgY2Fubm90IGJlIHNlcGFyYXRlZCBmcm9tIHgtZWRpdGFibGUncyBvbmUuXG4gICAgICAgICAgICAgICAgICAgIFRoZSB3b3JrYXJvdW5kIGlzIHRvIGNoZWNrIGBhcmd1bWVudHMubGVuZ3RoYCB0aGF0IGlzIGFsd2F5cyBgMmAgZm9yIHgtZWRpdGFibGUuICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBAZXZlbnQgc2hvd24gXG4gICAgICAgICAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBldmVudCBldmVudCBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgICAgJCgnI3VzZXJuYW1lJykub24oJ3Nob3duJywgZnVuY3Rpb24oZSwgZWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlLmlucHV0LiRpbnB1dC52YWwoJ292ZXJ3cml0aW5nIHZhbHVlIG9mIGlucHV0Li4nKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7ICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICoqLyAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgIFRPRE86IGFkZGVkIHNlY29uZCBwYXJhbSBtYWlubHkgdG8gZGlzdGluZ3Vpc2ggZnJvbSBib290c3RyYXAncyBzaG93biBldmVudC4gSXQncyBhIGhvdGZpeCB0aGF0IHdpbGwgYmUgc29sdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucyB2aWEgbmFtZXNwYWNlZCBldmVudHMuICBcbiAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VySGFuZGxlcignc2hvd24nLCAkKHRoaXMub3B0aW9ucy5zY29wZSkuZGF0YSgnZWRpdGFibGUnKSk7IFxuICAgICAgICAgICAgICAgIH0sIHRoaXMpIFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5lZGl0YWJsZWZvcm0oJ3JlbmRlcicpO1xuICAgICAgICB9LCAgICAgICAgXG5cbiAgICAgICAgLyoqXG4gICAgICAgIFNob3dzIGNvbnRhaW5lciB3aXRoIGZvcm1cbiAgICAgICAgQG1ldGhvZCBzaG93KClcbiAgICAgICAgQHBhcmFtIHtib29sZWFufSBjbG9zZUFsbCBXaGV0aGVyIHRvIGNsb3NlIGFsbCBvdGhlciBlZGl0YWJsZSBjb250YWluZXJzIHdoZW4gc2hvd2luZyB0aGlzIG9uZS4gRGVmYXVsdCB0cnVlLlxuICAgICAgICAqKi9cbiAgICAgICAgLyogTm90ZTogcG9zaHl0aXAgb3dlcndyaXRlcyB0aGlzIG1ldGhvZCB0b3RhbGx5ISAqLyAgICAgICAgICBcbiAgICAgICAgc2hvdzogZnVuY3Rpb24gKGNsb3NlQWxsKSB7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKCdlZGl0YWJsZS1vcGVuJyk7XG4gICAgICAgICAgICBpZihjbG9zZUFsbCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvL2Nsb3NlIGFsbCBvcGVuIGNvbnRhaW5lcnMgKGV4Y2VwdCB0aGlzKVxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VPdGhlcnModGhpcy4kZWxlbWVudFswXSk7ICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9zaG93IGNvbnRhaW5lciBpdHNlbGZcbiAgICAgICAgICAgIHRoaXMuaW5uZXJTaG93KCk7XG4gICAgICAgICAgICB0aGlzLnRpcCgpLmFkZENsYXNzKHRoaXMuY29udGFpbmVyQ2xhc3MpO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgQ3VycmVudGx5LCBmb3JtIGlzIHJlLXJlbmRlcmVkIG9uIGV2ZXJ5IHNob3cuIFxuICAgICAgICAgICAgVGhlIG1haW4gcmVhc29uIGlzIHRoYXQgd2UgZG9udCBrbm93LCB3aGF0IHdpbGwgY29udGFpbmVyIGRvIHdpdGggY29udGVudCB3aGVuIGNsb3NlZDpcbiAgICAgICAgICAgIHJlbW92ZSgpLCBkZXRhY2goKSBvciBqdXN0IGhpZGUoKSAtIGl0IGRlcGVuZHMgb24gY29udGFpbmVyLlxuICAgICAgICAgICAgXG4gICAgICAgICAgICBEZXRhY2hpbmcgZm9ybSBpdHNlbGYgYmVmb3JlIGhpZGUgYW5kIHJlLWluc2VydCBiZWZvcmUgc2hvdyBpcyBnb29kIHNvbHV0aW9uLCBcbiAgICAgICAgICAgIGJ1dCB2aXN1YWxseSBpdCBsb29rcyB1Z2x5IC0tPiBjb250YWluZXIgY2hhbmdlcyBzaXplIGJlZm9yZSBoaWRlLiAgXG4gICAgICAgICAgICAqLyAgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pZiBmb3JtIGFscmVhZHkgZXhpc3QgLSBkZWxldGUgcHJldmlvdXMgZGF0YSBcbiAgICAgICAgICAgIGlmKHRoaXMuJGZvcm0pIHtcbiAgICAgICAgICAgICAgICAvL3RvZG86IGRlc3Ryb3kgcHJldiBkYXRhIVxuICAgICAgICAgICAgICAgIC8vdGhpcy4kZm9ybS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuJGZvcm0gPSAkKCc8ZGl2PicpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2luc2VydCBmb3JtIGludG8gY29udGFpbmVyIGJvZHlcbiAgICAgICAgICAgIGlmKHRoaXMudGlwKCkuaXModGhpcy5pbm5lckNzcykpIHtcbiAgICAgICAgICAgICAgICAvL2ZvciBpbmxpbmUgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgdGhpcy50aXAoKS5hcHBlbmQodGhpcy4kZm9ybSk7IFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpcCgpLmZpbmQodGhpcy5pbm5lckNzcykuYXBwZW5kKHRoaXMuJGZvcm0pO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9yZW5kZXIgZm9ybVxuICAgICAgICAgICAgdGhpcy5yZW5kZXJGb3JtKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgIEhpZGVzIGNvbnRhaW5lciB3aXRoIGZvcm1cbiAgICAgICAgQG1ldGhvZCBoaWRlKClcbiAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiBSZWFzb24gY2F1c2VkIGhpZGluZy4gQ2FuIGJlIDxjb2RlPnNhdmV8Y2FuY2VsfG9uYmx1cnxub2NoYW5nZXx1bmRlZmluZWQgKD1tYW51YWwpPC9jb2RlPlxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgaGlkZTogZnVuY3Rpb24ocmVhc29uKSB7ICBcbiAgICAgICAgICAgIGlmKCF0aGlzLnRpcCgpIHx8ICF0aGlzLnRpcCgpLmlzKCc6dmlzaWJsZScpIHx8ICF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdlZGl0YWJsZS1vcGVuJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaWYgZm9ybSBpcyBzYXZpbmcgdmFsdWUsIHNjaGVkdWxlIGhpZGVcbiAgICAgICAgICAgIGlmKHRoaXMuJGZvcm0uZGF0YSgnZWRpdGFibGVmb3JtJykuaXNTYXZpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGF5ZWRIaWRlID0ge3JlYXNvbjogcmVhc29ufTtcbiAgICAgICAgICAgICAgICByZXR1cm47ICAgIFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGF5ZWRIaWRlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2VkaXRhYmxlLW9wZW4nKTsgICBcbiAgICAgICAgICAgIHRoaXMuaW5uZXJIaWRlKCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgRmlyZWQgd2hlbiBjb250YWluZXIgd2FzIGhpZGRlbi4gSXQgb2NjdXJzIG9uIGJvdGggc2F2ZSBvciBjYW5jZWwuICBcbiAgICAgICAgICAgICoqTm90ZToqKiBCb290c3RyYXAgcG9wb3ZlciBoYXMgb3duIGBoaWRkZW5gIGV2ZW50IHRoYXQgbm93IGNhbm5vdCBiZSBzZXBhcmF0ZWQgZnJvbSB4LWVkaXRhYmxlJ3Mgb25lLlxuICAgICAgICAgICAgVGhlIHdvcmthcm91bmQgaXMgdG8gY2hlY2sgYGFyZ3VtZW50cy5sZW5ndGhgIHRoYXQgaXMgYWx3YXlzIGAyYCBmb3IgeC1lZGl0YWJsZS4gXG5cbiAgICAgICAgICAgIEBldmVudCBoaWRkZW4gXG4gICAgICAgICAgICBAcGFyYW0ge29iamVjdH0gZXZlbnQgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gcmVhc29uIFJlYXNvbiBjYXVzZWQgaGlkaW5nLiBDYW4gYmUgPGNvZGU+c2F2ZXxjYW5jZWx8b25ibHVyfG5vY2hhbmdlfG1hbnVhbDwvY29kZT5cbiAgICAgICAgICAgIEBleGFtcGxlXG4gICAgICAgICAgICAkKCcjdXNlcm5hbWUnKS5vbignaGlkZGVuJywgZnVuY3Rpb24oZSwgcmVhc29uKSB7XG4gICAgICAgICAgICAgICAgaWYocmVhc29uID09PSAnc2F2ZScgfHwgcmVhc29uID09PSAnY2FuY2VsJykge1xuICAgICAgICAgICAgICAgICAgICAvL2F1dG8tb3BlbiBuZXh0IGVkaXRhYmxlXG4gICAgICAgICAgICAgICAgICAgICQodGhpcykuY2xvc2VzdCgndHInKS5uZXh0KCkuZmluZCgnLmVkaXRhYmxlJykuZWRpdGFibGUoJ3Nob3cnKTtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAqKi9cbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlckhhbmRsZXIoJ2hpZGRlbicsIHJlYXNvbiB8fCAnbWFudWFsJyk7ICAgXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyogaW50ZXJuYWwgc2hvdyBtZXRob2QuIFRvIGJlIG92ZXJ3cml0dGVuIGluIGNoaWxkIGNsYXNzZXMgKi9cbiAgICAgICAgaW5uZXJTaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgXG4gICAgICAgIH0sICAgICAgICBcblxuICAgICAgICAvKiBpbnRlcm5hbCBoaWRlIG1ldGhvZC4gVG8gYmUgb3ZlcndyaXR0ZW4gaW4gY2hpbGQgY2xhc3NlcyAqL1xuICAgICAgICBpbm5lckhpZGU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIFRvZ2dsZXMgY29udGFpbmVyIHZpc2liaWxpdHkgKHNob3cgLyBoaWRlKVxuICAgICAgICBAbWV0aG9kIHRvZ2dsZSgpXG4gICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gY2xvc2VBbGwgV2hldGhlciB0byBjbG9zZSBhbGwgb3RoZXIgZWRpdGFibGUgY29udGFpbmVycyB3aGVuIHNob3dpbmcgdGhpcyBvbmUuIERlZmF1bHQgdHJ1ZS5cbiAgICAgICAgKiovICAgICAgICAgIFxuICAgICAgICB0b2dnbGU6IGZ1bmN0aW9uKGNsb3NlQWxsKSB7XG4gICAgICAgICAgICBpZih0aGlzLmNvbnRhaW5lcigpICYmIHRoaXMudGlwKCkgJiYgdGhpcy50aXAoKS5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3coY2xvc2VBbGwpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiBjb250YWluZXIgd2hlbiBjb250ZW50IGNoYW5nZWQuXG4gICAgICAgIEBtZXRob2Qgc2V0UG9zaXRpb24oKVxuICAgICAgICAqLyAgICAgICBcbiAgICAgICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy90YmQgaW4gY2hpbGQgY2xhc3NcbiAgICAgICAgfSxcblxuICAgICAgICBzYXZlOiBmdW5jdGlvbihlLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIC8qKiAgICAgICAgXG4gICAgICAgICAgICBGaXJlZCB3aGVuIG5ldyB2YWx1ZSB3YXMgc3VibWl0dGVkLiBZb3UgY2FuIHVzZSA8Y29kZT4kKHRoaXMpLmRhdGEoJ2VkaXRhYmxlQ29udGFpbmVyJyk8L2NvZGU+IGluc2lkZSBoYW5kbGVyIHRvIGFjY2VzcyB0byBlZGl0YWJsZUNvbnRhaW5lciBpbnN0YW5jZVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBAZXZlbnQgc2F2ZSBcbiAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBldmVudCBldmVudCBvYmplY3RcbiAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgYWRkaXRpb25hbCBwYXJhbXNcbiAgICAgICAgICAgIEBwYXJhbSB7bWl4ZWR9IHBhcmFtcy5uZXdWYWx1ZSBzdWJtaXR0ZWQgdmFsdWVcbiAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMucmVzcG9uc2UgYWpheCByZXNwb25zZVxuICAgICAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgICAgICQoJyN1c2VybmFtZScpLm9uKCdzYXZlJywgZnVuY3Rpb24oZSwgcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgLy9hc3N1bWluZyBzZXJ2ZXIgcmVzcG9uc2U6ICd7c3VjY2VzczogdHJ1ZX0nXG4gICAgICAgICAgICAgICAgdmFyIHBrID0gJCh0aGlzKS5kYXRhKCdlZGl0YWJsZUNvbnRhaW5lcicpLm9wdGlvbnMucGs7XG4gICAgICAgICAgICAgICAgaWYocGFyYW1zLnJlc3BvbnNlICYmIHBhcmFtcy5yZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KCd2YWx1ZTogJyArIHBhcmFtcy5uZXdWYWx1ZSArICcgd2l0aCBwazogJyArIHBrICsgJyBzYXZlZCEnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbGVydCgnZXJyb3IhJyk7IFxuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICoqLyAgICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlckhhbmRsZXIoJ3NhdmUnLCBwYXJhbXMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2hpZGUgbXVzdCBiZSBhZnRlciB0cmlnZ2VyLCBhcyBzYXZpbmcgdmFsdWUgbWF5IHJlcXVpcmUgbWV0aG9kcyBvZiBwbHVnaW4sIGFwcGxpZWQgdG8gaW5wdXRcbiAgICAgICAgICAgIHRoaXMuaGlkZSgnc2F2ZScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICBTZXRzIG5ldyBvcHRpb25cbiAgICAgICAgXG4gICAgICAgIEBtZXRob2Qgb3B0aW9uKGtleSwgdmFsdWUpXG4gICAgICAgIEBwYXJhbSB7c3RyaW5nfSBrZXkgXG4gICAgICAgIEBwYXJhbSB7bWl4ZWR9IHZhbHVlIFxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgb3B0aW9uOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYoa2V5IGluIHRoaXMuY29udGFpbmVyT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyT3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDb250YWluZXJPcHRpb24oa2V5LCB2YWx1ZSk7IFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1PcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLiRmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGZvcm0uZWRpdGFibGVmb3JtKCdvcHRpb24nLCBrZXksIHZhbHVlKTsgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHNldENvbnRhaW5lck9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jYWxsKCdvcHRpb24nLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgRGVzdHJveXMgdGhlIGNvbnRhaW5lciBpbnN0YW5jZVxuICAgICAgICBAbWV0aG9kIGRlc3Ryb3koKVxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgdGhpcy5pbm5lckRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdkZXN0cm95ZWQnKTtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlRGF0YSgnZWRpdGFibGVDb250YWluZXInKTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qIHRvIGJlIG92ZXJ3cml0dGVuIGluIGNoaWxkIGNsYXNzZXMgKi9cbiAgICAgICAgaW5uZXJEZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFxuICAgICAgICB9LCBcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgIENsb3NlcyBvdGhlciBjb250YWluZXJzIGV4Y2VwdCBvbmUgcmVsYXRlZCB0byBwYXNzZWQgZWxlbWVudC4gXG4gICAgICAgIE90aGVyIGNvbnRhaW5lcnMgY2FuIGJlIGNhbmNlbGxlZCBvciBzdWJtaXR0ZWQgKGRlcGVuZHMgb24gb25ibHVyIG9wdGlvbilcbiAgICAgICAgKi9cbiAgICAgICAgY2xvc2VPdGhlcnM6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICQoJy5lZGl0YWJsZS1vcGVuJykuZWFjaChmdW5jdGlvbihpLCBlbCl7XG4gICAgICAgICAgICAgICAgLy9kbyBub3RoaW5nIHdpdGggcGFzc2VkIGVsZW1lbnQgYW5kIGl0J3MgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBpZihlbCA9PT0gZWxlbWVudCB8fCAkKGVsKS5maW5kKGVsZW1lbnQpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9vdGhlcndpc2UgY2FuY2VsIG9yIHN1Ym1pdCBhbGwgb3BlbiBjb250YWluZXJzIFxuICAgICAgICAgICAgICAgIHZhciAkZWwgPSAkKGVsKSxcbiAgICAgICAgICAgICAgICBlYyA9ICRlbC5kYXRhKCdlZGl0YWJsZUNvbnRhaW5lcicpO1xuXG4gICAgICAgICAgICAgICAgaWYoIWVjKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihlYy5vcHRpb25zLm9uYmx1ciA9PT0gJ2NhbmNlbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgJGVsLmRhdGEoJ2VkaXRhYmxlQ29udGFpbmVyJykuaGlkZSgnb25ibHVyJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKGVjLm9wdGlvbnMub25ibHVyID09PSAnc3VibWl0Jykge1xuICAgICAgICAgICAgICAgICAgICAkZWwuZGF0YSgnZWRpdGFibGVDb250YWluZXInKS50aXAoKS5maW5kKCdmb3JtJykuc3VibWl0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBBY3RpdmF0ZXMgaW5wdXQgb2YgdmlzaWJsZSBjb250YWluZXIgKGUuZy4gc2V0IGZvY3VzKVxuICAgICAgICBAbWV0aG9kIGFjdGl2YXRlKClcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKHRoaXMudGlwICYmIHRoaXMudGlwKCkuaXMoJzp2aXNpYmxlJykgJiYgdGhpcy4kZm9ybSkge1xuICAgICAgICAgICAgICAgdGhpcy4kZm9ybS5kYXRhKCdlZGl0YWJsZWZvcm0nKS5pbnB1dC5hY3RpdmF0ZSgpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBcblxuICAgIH07XG5cbiAgICAvKipcbiAgICBqUXVlcnkgbWV0aG9kIHRvIGluaXRpYWxpemUgZWRpdGFibGVDb250YWluZXIuXG4gICAgXG4gICAgQG1ldGhvZCAkKCkuZWRpdGFibGVDb250YWluZXIob3B0aW9ucylcbiAgICBAcGFyYW1zIHtPYmplY3R9IG9wdGlvbnNcbiAgICBAZXhhbXBsZVxuICAgICQoJyNlZGl0JykuZWRpdGFibGVDb250YWluZXIoe1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIHVybDogJy9wb3N0JyxcbiAgICAgICAgcGs6IDEsXG4gICAgICAgIHZhbHVlOiAnaGVsbG8nXG4gICAgfSk7XG4gICAgKiovICBcbiAgICAkLmZuLmVkaXRhYmxlQ29udGFpbmVyID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxuICAgICAgICAgICAgZGF0YUtleSA9ICdlZGl0YWJsZUNvbnRhaW5lcicsIFxuICAgICAgICAgICAgZGF0YSA9ICR0aGlzLmRhdGEoZGF0YUtleSksXG4gICAgICAgICAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PT0gJ29iamVjdCcgJiYgb3B0aW9uLFxuICAgICAgICAgICAgQ29uc3RydWN0b3IgPSAob3B0aW9ucy5tb2RlID09PSAnaW5saW5lJykgPyBJbmxpbmUgOiBQb3B1cDsgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICR0aGlzLmRhdGEoZGF0YUtleSwgKGRhdGEgPSBuZXcgQ29uc3RydWN0b3IodGhpcywgb3B0aW9ucykpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdzdHJpbmcnKSB7IC8vY2FsbCBtZXRob2QgXG4gICAgICAgICAgICAgICAgZGF0YVtvcHRpb25dLmFwcGx5KGRhdGEsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcbiAgICAgICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgfSk7XG4gICAgfTsgICAgIFxuXG4gICAgLy9zdG9yZSBjb25zdHJ1Y3RvcnNcbiAgICAkLmZuLmVkaXRhYmxlQ29udGFpbmVyLlBvcHVwID0gUG9wdXA7XG4gICAgJC5mbi5lZGl0YWJsZUNvbnRhaW5lci5JbmxpbmUgPSBJbmxpbmU7XG5cbiAgICAvL2RlZmF1bHRzXG4gICAgJC5mbi5lZGl0YWJsZUNvbnRhaW5lci5kZWZhdWx0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgIEluaXRpYWwgdmFsdWUgb2YgZm9ybSBpbnB1dFxuXG4gICAgICAgIEBwcm9wZXJ0eSB2YWx1ZSBcbiAgICAgICAgQHR5cGUgbWl4ZWRcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICBAcHJpdmF0ZVxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIFBsYWNlbWVudCBvZiBjb250YWluZXIgcmVsYXRpdmUgdG8gZWxlbWVudC4gQ2FuIGJlIDxjb2RlPnRvcHxyaWdodHxib3R0b218bGVmdDwvY29kZT4uIE5vdCB1c2VkIGZvciBpbmxpbmUgY29udGFpbmVyLlxuXG4gICAgICAgIEBwcm9wZXJ0eSBwbGFjZW1lbnQgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAndG9wJ1xuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgICAgICAvKipcbiAgICAgICAgV2hldGhlciB0byBoaWRlIGNvbnRhaW5lciBvbiBzYXZlL2NhbmNlbC5cblxuICAgICAgICBAcHJvcGVydHkgYXV0b2hpZGUgXG4gICAgICAgIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgQGRlZmF1bHQgdHJ1ZVxuICAgICAgICBAcHJpdmF0ZSBcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgYXV0b2hpZGU6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICBBY3Rpb24gd2hlbiB1c2VyIGNsaWNrcyBvdXRzaWRlIHRoZSBjb250YWluZXIuIENhbiBiZSA8Y29kZT5jYW5jZWx8c3VibWl0fGlnbm9yZTwvY29kZT4uICBcbiAgICAgICAgU2V0dGluZyA8Y29kZT5pZ25vcmU8L2NvZGU+IGFsbG93cyB0byBoYXZlIHNldmVyYWwgY29udGFpbmVycyBvcGVuLiBcblxuICAgICAgICBAcHJvcGVydHkgb25ibHVyIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgJ2NhbmNlbCdcbiAgICAgICAgQHNpbmNlIDEuMS4xXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIG9uYmx1cjogJ2NhbmNlbCcsXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgQW5pbWF0aW9uIHNwZWVkIChpbmxpbmUgbW9kZSBvbmx5KVxuICAgICAgICBAcHJvcGVydHkgYW5pbSBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIGFuaW06IGZhbHNlLFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIE1vZGUgb2YgZWRpdGFibGUsIGNhbiBiZSBgcG9wdXBgIG9yIGBpbmxpbmVgIFxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IG1vZGUgXG4gICAgICAgIEB0eXBlIHN0cmluZyAgICAgICAgIFxuICAgICAgICBAZGVmYXVsdCAncG9wdXAnXG4gICAgICAgIEBzaW5jZSAxLjQuMCAgICAgICAgXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIG1vZGU6ICdwb3B1cCcgICAgICAgIFxuICAgIH07XG5cbiAgICAvKiBcbiAgICAqIHdvcmthcm91bmQgdG8gaGF2ZSAnZGVzdHJveWVkJyBldmVudCB0byBkZXN0cm95IHBvcG92ZXIgd2hlbiBlbGVtZW50IGlzIGRlc3Ryb3llZFxuICAgICogc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjIwMDQ5NC9qcXVlcnktdHJpZ2dlci1ldmVudC13aGVuLWFuLWVsZW1lbnQtaXMtcmVtb3ZlZC1mcm9tLXRoZS1kb21cbiAgICAqL1xuICAgIGpRdWVyeS5ldmVudC5zcGVjaWFsLmRlc3Ryb3llZCA9IHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgICBpZiAoby5oYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgby5oYW5kbGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9OyAgICBcblxufSh3aW5kb3cualF1ZXJ5KSk7XG5cbi8qKlxuKiBFZGl0YWJsZSBJbmxpbmUgXG4qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFxuICAgIC8vY29weSBwcm90b3R5cGUgZnJvbSBFZGl0YWJsZUNvbnRhaW5lclxuICAgIC8vZXh0ZW5kIG1ldGhvZHNcbiAgICAkLmV4dGVuZCgkLmZuLmVkaXRhYmxlQ29udGFpbmVyLklubGluZS5wcm90b3R5cGUsICQuZm4uZWRpdGFibGVDb250YWluZXIuUG9wdXAucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnRhaW5lck5hbWU6ICdlZGl0YWJsZWZvcm0nLFxuICAgICAgICBpbm5lckNzczogJy5lZGl0YWJsZS1pbmxpbmUnLFxuICAgICAgICBjb250YWluZXJDbGFzczogJ2VkaXRhYmxlLWNvbnRhaW5lciBlZGl0YWJsZS1pbmxpbmUnLCAvL2NzcyBjbGFzcyBhcHBsaWVkIHRvIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICAgICAgICAgICAgIFxuICAgICAgICBpbml0Q29udGFpbmVyOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgLy9jb250YWluZXIgaXMgPHNwYW4+IGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuJHRpcCA9ICQoJzxzcGFuPjwvc3Bhbj4nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9jb252ZXJ0IGFuaW0gdG8gbWlsaXNlY29uZHMgKGludClcbiAgICAgICAgICAgIGlmKCF0aGlzLm9wdGlvbnMuYW5pbSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hbmltID0gMDtcbiAgICAgICAgICAgIH0gICAgICAgICBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHNwbGl0T3B0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvL2FsbCBvcHRpb25zIGFyZSBwYXNzZWQgdG8gZm9ybVxuICAgICAgICAgICAgdGhpcy5jb250YWluZXJPcHRpb25zID0ge307XG4gICAgICAgICAgICB0aGlzLmZvcm1PcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgdGlwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuJHRpcDsgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBpbm5lclNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuaGlkZSgpO1xuICAgICAgICAgICAgdGhpcy50aXAoKS5pbnNlcnRBZnRlcih0aGlzLiRlbGVtZW50KS5zaG93KCk7XG4gICAgICAgIH0sIFxuICAgICAgICBcbiAgICAgICAgaW5uZXJIaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLiR0aXAuaGlkZSh0aGlzLm9wdGlvbnMuYW5pbSwgJC5wcm94eShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnNob3coKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlubmVyRGVzdHJveSgpO1xuICAgICAgICAgICAgfSwgdGhpcykpOyBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGlubmVyRGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLnRpcCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aXAoKS5lbXB0eSgpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IFxuICAgIH0pO1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcbi8qKlxuTWFrZXMgZWRpdGFibGUgYW55IEhUTUwgZWxlbWVudCBvbiB0aGUgcGFnZS4gQXBwbGllZCBhcyBqUXVlcnkgbWV0aG9kLlxuXG5AY2xhc3MgZWRpdGFibGVcbkB1c2VzIGVkaXRhYmxlQ29udGFpbmVyXG4qKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIEVkaXRhYmxlID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgICAgIC8vZGF0YS0qIGhhcyBtb3JlIHByaW9yaXR5IG92ZXIganMgb3B0aW9uczogYmVjYXVzZSBkeW5hbWljYWxseSBjcmVhdGVkIGVsZW1lbnRzIG1heSBjaGFuZ2UgZGF0YS0qIFxuICAgICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZS5kZWZhdWx0cywgb3B0aW9ucywgJC5mbi5lZGl0YWJsZXV0aWxzLmdldENvbmZpZ0RhdGEodGhpcy4kZWxlbWVudCkpOyAgXG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5zZWxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5pbml0TGl2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vY2hlY2sgZm9yIHRyYW5zaXRpb24gc3VwcG9ydFxuICAgICAgICBpZih0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0ICYmICEkLmZuLmVkaXRhYmxldXRpbHMuc3VwcG9ydHNUcmFuc2l0aW9ucygpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRWRpdGFibGUucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogRWRpdGFibGUsIFxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaXNWYWx1ZUJ5VGV4dCA9IGZhbHNlLCBcbiAgICAgICAgICAgICAgICBkb0F1dG90ZXh0LCBmaW5hbGl6ZTtcblxuICAgICAgICAgICAgLy9uYW1lXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHRoaXMub3B0aW9ucy5uYW1lIHx8IHRoaXMuJGVsZW1lbnQuYXR0cignaWQnKTtcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vY3JlYXRlIGlucHV0IG9mIHNwZWNpZmllZCB0eXBlLiBJbnB1dCBuZWVkZWQgYWxyZWFkeSBoZXJlIHRvIGNvbnZlcnQgdmFsdWUgZm9yIGluaXRpYWwgZGlzcGxheSAoZS5nLiBzaG93IHRleHQgYnkgaWQgZm9yIHNlbGVjdClcbiAgICAgICAgICAgIC8vYWxzbyB3ZSBzZXQgc2NvcGUgb3B0aW9uIHRvIGhhdmUgYWNjZXNzIHRvIGVsZW1lbnQgaW5zaWRlIGlucHV0IHNwZWNpZmljIGNhbGxiYWNrcyAoZS4gZy4gc291cmNlIGFzIGZ1bmN0aW9uKVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNjb3BlID0gdGhpcy4kZWxlbWVudFswXTsgXG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gJC5mbi5lZGl0YWJsZXV0aWxzLmNyZWF0ZUlucHV0KHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICBpZighdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgXG4gICAgICAgICAgICB9ICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIC8vc2V0IHZhbHVlIGZyb20gc2V0dGluZ3Mgb3IgYnkgZWxlbWVudCdzIHRleHRcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5pbnB1dC5odG1sMnZhbHVlKCQudHJpbSh0aGlzLiRlbGVtZW50Lmh0bWwoKSkpO1xuICAgICAgICAgICAgICAgIGlzVmFsdWVCeVRleHQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgdmFsdWUgY2FuIGJlIHN0cmluZyB3aGVuIHJlY2VpdmVkIGZyb20gJ2RhdGEtdmFsdWUnIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgZm9yIGNvbXBsZXh0IG9iamVjdHMgdmFsdWUgY2FuIGJlIHNldCBhcyBqc29uIHN0cmluZyBpbiBkYXRhLXZhbHVlIGF0dHJpYnV0ZSwgXG4gICAgICAgICAgICAgICAgICBlLmcuIGRhdGEtdmFsdWU9XCJ7Y2l0eTogJ01vc2NvdycsIHN0cmVldDogJ0xlbmluYSd9XCJcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy52YWx1ZSA9ICQuZm4uZWRpdGFibGV1dGlscy50cnlQYXJzZUpzb24odGhpcy5vcHRpb25zLnZhbHVlLCB0cnVlKTsgXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIHRoaXMub3B0aW9ucy52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuaW5wdXQuc3RyMnZhbHVlKHRoaXMub3B0aW9ucy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMub3B0aW9ucy52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vYWRkICdlZGl0YWJsZScgY2xhc3MgdG8gZXZlcnkgZWRpdGFibGUgZWxlbWVudFxuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnZWRpdGFibGUnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9zcGVjaWZpY2FsbHkgZm9yIFwidGV4dGFyZWFcIiBhZGQgY2xhc3MgLmVkaXRhYmxlLXByZS13cmFwcGVkIHRvIGtlZXAgbGluZWJyZWFrc1xuICAgICAgICAgICAgaWYodGhpcy5pbnB1dC50eXBlID09PSAndGV4dGFyZWEnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnZWRpdGFibGUtcHJlLXdyYXBwZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9hdHRhY2ggaGFuZGxlciBhY3RpdmF0aW5nIGVkaXRhYmxlLiBJbiBkaXNhYmxlZCBtb2RlIGl0IGp1c3QgcHJldmVudCBkZWZhdWx0IGFjdGlvbiAodXNlZnVsIGZvciBsaW5rcylcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy50b2dnbGUgIT09ICdtYW51YWwnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnZWRpdGFibGUtY2xpY2snKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKHRoaXMub3B0aW9ucy50b2dnbGUgKyAnLmVkaXRhYmxlJywgJC5wcm94eShmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IGZvbGxvd2luZyBsaW5rIGlmIGVkaXRhYmxlIGVuYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgaWYoIXRoaXMub3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL3N0b3AgcHJvcGFnYXRpb24gbm90IHJlcXVpcmVkIGJlY2F1c2UgaW4gZG9jdW1lbnQgY2xpY2sgaGFuZGxlciBpdCBjaGVja3MgZXZlbnQgdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIC8vZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy50b2dnbGUgPT09ICdtb3VzZWVudGVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9mb3IgaG92ZXIgb25seSBzaG93IGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3doZW4gdG9nZ2xlPSdjbGljaycgd2Ugc2hvdWxkIG5vdCBjbG9zZSBhbGwgb3RoZXIgY29udGFpbmVycyBhcyB0aGV5IHdpbGwgYmUgY2xvc2VkIGF1dG9tYXRpY2FsbHkgaW4gZG9jdW1lbnQgY2xpY2sgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbG9zZUFsbCA9ICh0aGlzLm9wdGlvbnMudG9nZ2xlICE9PSAnY2xpY2snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlKGNsb3NlQWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCd0YWJpbmRleCcsIC0xKTsgLy9kbyBub3Qgc3RvcCBmb2N1cyBvbiBlbGVtZW50IHdoZW4gdG9nZ2xlZCBtYW51YWxseVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2lmIGRpc3BsYXkgaXMgZnVuY3Rpb24gaXQncyBmYXIgbW9yZSBjb252aW5pZW50IHRvIGhhdmUgYXV0b3RleHQgPSBhbHdheXMgdG8gcmVuZGVyIGNvcnJlY3RseSBvbiBpbml0XG4gICAgICAgICAgICAvL3NlZSBodHRwczovL2dpdGh1Yi5jb20vdml0YWxldHMveC1lZGl0YWJsZS15aWkvaXNzdWVzLzM0XG4gICAgICAgICAgICBpZih0eXBlb2YgdGhpcy5vcHRpb25zLmRpc3BsYXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuYXV0b3RleHQgPSAnYWx3YXlzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9jaGVjayBjb25kaXRpb25zIGZvciBhdXRvdGV4dDpcbiAgICAgICAgICAgIHN3aXRjaCh0aGlzLm9wdGlvbnMuYXV0b3RleHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAnYWx3YXlzJzpcbiAgICAgICAgICAgICAgIGRvQXV0b3RleHQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnYXV0byc6XG4gICAgICAgICAgICAgICAgLy9pZiBlbGVtZW50IHRleHQgaXMgZW1wdHkgYW5kIHZhbHVlIGlzIGRlZmluZWQgYW5kIHZhbHVlIG5vdCBnZW5lcmF0ZWQgYnkgdGV4dCAtLT4gcnVuIGF1dG90ZXh0XG4gICAgICAgICAgICAgICAgZG9BdXRvdGV4dCA9ICEkLnRyaW0odGhpcy4kZWxlbWVudC50ZXh0KCkpLmxlbmd0aCAmJiB0aGlzLnZhbHVlICE9PSBudWxsICYmIHRoaXMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhaXNWYWx1ZUJ5VGV4dDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICBkb0F1dG90ZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZGVwZW5kaW5nIG9uIGF1dG90ZXh0IHJ1biByZW5kZXIoKSBvciBqdXN0IGZpbmlsaXplIGluaXRcbiAgICAgICAgICAgICQud2hlbihkb0F1dG90ZXh0ID8gdGhpcy5yZW5kZXIoKSA6IHRydWUpLnRoZW4oJC5wcm94eShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmFibGUoKTsgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgLyoqICAgICAgICBcbiAgICAgICAgICAgICAgIEZpcmVkIHdoZW4gZWxlbWVudCB3YXMgaW5pdGlhbGl6ZWQgYnkgYCQoKS5lZGl0YWJsZSgpYCBtZXRob2QuIFxuICAgICAgICAgICAgICAgUGxlYXNlIG5vdGUgdGhhdCB5b3Ugc2hvdWxkIHNldHVwIGBpbml0YCBoYW5kbGVyICoqYmVmb3JlKiogYXBwbHlpbmcgYGVkaXRhYmxlYC4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgIEBldmVudCBpbml0IFxuICAgICAgICAgICAgICAgQHBhcmFtIHtPYmplY3R9IGV2ZW50IGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgICAgQHBhcmFtIHtPYmplY3R9IGVkaXRhYmxlIGVkaXRhYmxlIGluc3RhbmNlIChhcyBoZXJlIGl0IGNhbm5vdCBhY2Nlc3NlZCB2aWEgZGF0YSgnZWRpdGFibGUnKSlcbiAgICAgICAgICAgICAgIEBzaW5jZSAxLjIuMFxuICAgICAgICAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgICAgICAgICQoJyN1c2VybmFtZScpLm9uKCdpbml0JywgZnVuY3Rpb24oZSwgZWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICBhbGVydCgnaW5pdGlhbGl6ZWQgJyArIGVkaXRhYmxlLm9wdGlvbnMubmFtZSk7XG4gICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICQoJyN1c2VybmFtZScpLmVkaXRhYmxlKCk7XG4gICAgICAgICAgICAgICAqKi8gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXJIYW5kbGVyKCdpbml0JywgdGhpcyk7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgIEluaXRpYWxpemVzIHBhcmVudCBlbGVtZW50IGZvciBsaXZlIGVkaXRhYmxlcyBcbiAgICAgICAgKi9cbiAgICAgICAgaW5pdExpdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAvL3N0b3JlIHNlbGVjdG9yIFxuICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLm9wdGlvbnMuc2VsZWN0b3I7XG4gICAgICAgICAgIC8vbW9kaWZ5IG9wdGlvbnMgZm9yIGNoaWxkIGVsZW1lbnRzXG4gICAgICAgICAgIHRoaXMub3B0aW9ucy5zZWxlY3RvciA9IGZhbHNlOyBcbiAgICAgICAgICAgdGhpcy5vcHRpb25zLmF1dG90ZXh0ID0gJ25ldmVyJztcbiAgICAgICAgICAgLy9saXN0ZW4gdG9nZ2xlIGV2ZW50c1xuICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKHRoaXMub3B0aW9ucy50b2dnbGUgKyAnLmVkaXRhYmxlJywgc2VsZWN0b3IsICQucHJveHkoZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICB2YXIgJHRhcmdldCA9ICQoZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgaWYoISR0YXJnZXQuZGF0YSgnZWRpdGFibGUnKSkge1xuICAgICAgICAgICAgICAgICAgIC8vaWYgZGVsZWdhdGVkIGVsZW1lbnQgaW5pdGlhbGx5IGVtcHR5LCB3ZSBuZWVkIHRvIGNsZWFyIGl0J3MgdGV4dCAodGhhdCB3YXMgbWFudWFsbHkgc2V0IHRvIGBlbXB0eWAgYnkgdXNlcilcbiAgICAgICAgICAgICAgICAgICAvL3NlZSBodHRwczovL2dpdGh1Yi5jb20vdml0YWxldHMveC1lZGl0YWJsZS9pc3N1ZXMvMTM3IFxuICAgICAgICAgICAgICAgICAgIGlmKCR0YXJnZXQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLmVtcHR5Y2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHRhcmdldC5lbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAkdGFyZ2V0LmVkaXRhYmxlKHRoaXMub3B0aW9ucykudHJpZ2dlcihlKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfSwgdGhpcykpOyBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgIFJlbmRlcnMgdmFsdWUgaW50byBlbGVtZW50J3MgdGV4dC5cbiAgICAgICAgQ2FuIGNhbGwgY3VzdG9tIGRpc3BsYXkgbWV0aG9kIGZyb20gb3B0aW9ucy5cbiAgICAgICAgQ2FuIHJldHVybiBkZWZlcnJlZCBvYmplY3QuXG4gICAgICAgIEBtZXRob2QgcmVuZGVyKClcbiAgICAgICAgQHBhcmFtIHttaXhlZH0gcmVzcG9uc2Ugc2VydmVyIHJlc3BvbnNlIChpZiBleGlzdCkgdG8gcGFzcyBpbnRvIGRpc3BsYXkgZnVuY3Rpb25cbiAgICAgICAgKi8gICAgICAgICAgXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIC8vZG8gbm90IGRpc3BsYXkgYW55dGhpbmdcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5kaXNwbGF5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pZiBpbnB1dCBoYXMgYHZhbHVlMmh0bWxGaW5hbGAgbWV0aG9kLCB3ZSBwYXNzIGNhbGxiYWNrIGluIHRoaXJkIHBhcmFtIHRvIGJlIGNhbGxlZCB3aGVuIHNvdXJjZSBpcyBsb2FkZWRcbiAgICAgICAgICAgIGlmKHRoaXMuaW5wdXQudmFsdWUyaHRtbEZpbmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQudmFsdWUyaHRtbCh0aGlzLnZhbHVlLCB0aGlzLiRlbGVtZW50WzBdLCB0aGlzLm9wdGlvbnMuZGlzcGxheSwgcmVzcG9uc2UpOyBcbiAgICAgICAgICAgIC8vaWYgZGlzcGxheSBtZXRob2QgZGVmaW5lZCAtLT4gdXNlIGl0ICAgIFxuICAgICAgICAgICAgfSBlbHNlIGlmKHR5cGVvZiB0aGlzLm9wdGlvbnMuZGlzcGxheSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZGlzcGxheS5jYWxsKHRoaXMuJGVsZW1lbnRbMF0sIHRoaXMudmFsdWUsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIC8vZWxzZSB1c2UgaW5wdXQncyBvcmlnaW5hbCB2YWx1ZTJodG1sKCkgbWV0aG9kICAgIFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC52YWx1ZTJodG1sKHRoaXMudmFsdWUsIHRoaXMuJGVsZW1lbnRbMF0pOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBFbmFibGVzIGVkaXRhYmxlXG4gICAgICAgIEBtZXRob2QgZW5hYmxlKClcbiAgICAgICAgKiovICAgICAgICAgIFxuICAgICAgICBlbmFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdlZGl0YWJsZS1kaXNhYmxlZCcpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFbXB0eSh0aGlzLmlzRW1wdHkpO1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnRvZ2dsZSAhPT0gJ21hbnVhbCcpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLiRlbGVtZW50LmF0dHIoJ3RhYmluZGV4JykgPT09ICctMScpIHsgICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQXR0cigndGFiaW5kZXgnKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBEaXNhYmxlcyBlZGl0YWJsZVxuICAgICAgICBAbWV0aG9kIGRpc2FibGUoKVxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgPSB0cnVlOyBcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpOyAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKCdlZGl0YWJsZS1kaXNhYmxlZCcpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFbXB0eSh0aGlzLmlzRW1wdHkpO1xuICAgICAgICAgICAgLy9kbyBub3Qgc3RvcCBmb2N1cyBvbiB0aGlzIGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cigndGFiaW5kZXgnLCAtMSk7ICAgICAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIFRvZ2dsZXMgZW5hYmxlZCAvIGRpc2FibGVkIHN0YXRlIG9mIGVkaXRhYmxlIGVsZW1lbnRcbiAgICAgICAgQG1ldGhvZCB0b2dnbGVEaXNhYmxlZCgpXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICB0b2dnbGVEaXNhYmxlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHsgXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCk7IFxuICAgICAgICAgICAgfVxuICAgICAgICB9LCAgXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgU2V0cyBuZXcgb3B0aW9uXG4gICAgICAgIFxuICAgICAgICBAbWV0aG9kIG9wdGlvbihrZXksIHZhbHVlKVxuICAgICAgICBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IGtleSBvcHRpb24gbmFtZSBvciBvYmplY3Qgd2l0aCBzZXZlcmFsIG9wdGlvbnNcbiAgICAgICAgQHBhcmFtIHttaXhlZH0gdmFsdWUgb3B0aW9uIG5ldyB2YWx1ZVxuICAgICAgICBAZXhhbXBsZVxuICAgICAgICAkKCcuZWRpdGFibGUnKS5lZGl0YWJsZSgnb3B0aW9uJywgJ3BrJywgMik7XG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgb3B0aW9uOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAvL3NldCBvcHRpb24ocykgYnkgb2JqZWN0XG4gICAgICAgICAgICBpZihrZXkgJiYgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICQuZWFjaChrZXksICQucHJveHkoZnVuY3Rpb24oaywgdil7XG4gICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbigkLnRyaW0oayksIHYpOyBcbiAgICAgICAgICAgICAgIH0sIHRoaXMpKTsgXG4gICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vc2V0IG9wdGlvbiBieSBzdHJpbmcgICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vZGlzYWJsZWRcbiAgICAgICAgICAgIGlmKGtleSA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gdGhpcy5kaXNhYmxlKCkgOiB0aGlzLmVuYWJsZSgpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy92YWx1ZVxuICAgICAgICAgICAgaWYoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vdHJhbnNmZXIgbmV3IG9wdGlvbiB0byBjb250YWluZXIhIFxuICAgICAgICAgICAgaWYodGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5vcHRpb24oa2V5LCB2YWx1ZSk7ICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vcGFzcyBvcHRpb24gdG8gaW5wdXQgZGlyZWN0bHkgKGFzIGl0IHBvaW50cyB0byB0aGUgc2FtZSBpbiBmb3JtKVxuICAgICAgICAgICAgaWYodGhpcy5pbnB1dC5vcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0Lm9wdGlvbihrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9LCAgICAgICAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICAqIHNldCBlbXB0eXRleHQgaWYgZWxlbWVudCBpcyBlbXB0eVxuICAgICAgICAqL1xuICAgICAgICBoYW5kbGVFbXB0eTogZnVuY3Rpb24gKGlzRW1wdHkpIHtcbiAgICAgICAgICAgIC8vZG8gbm90IGhhbmRsZSBlbXB0eSBpZiB3ZSBkbyBub3QgZGlzcGxheSBhbnl0aGluZ1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmRpc3BsYXkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBcbiAgICAgICAgICAgIGlzRW1wdHkgbWF5IGJlIHNldCBkaXJlY3RseSBhcyBwYXJhbSBvZiBtZXRob2QuXG4gICAgICAgICAgICBJdCBpcyByZXF1aXJlZCB3aGVuIHdlIGVuYWJsZS9kaXNhYmxlIGZpZWxkIGFuZCBjYW4ndCByZWx5IG9uIGNvbnRlbnQgXG4gICAgICAgICAgICBhcyBub2RlIGNvbnRlbnQgaXMgdGV4dDogXCJFbXB0eVwiIHRoYXQgaXMgbm90IGVtcHR5ICUpXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYoaXNFbXB0eSAhPT0gdW5kZWZpbmVkKSB7IFxuICAgICAgICAgICAgICAgIHRoaXMuaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vZGV0ZWN0IGVtcHR5XG4gICAgICAgICAgICAgICAgLy9mb3Igc29tZSBpbnB1dHMgd2UgbmVlZCBtb3JlIHNtYXJ0IGNoZWNrXG4gICAgICAgICAgICAgICAgLy9lLmcuIHd5c2lodG1sNSBtYXkgaGF2ZSA8YnI+LCA8cD48L3A+LCA8aW1nPlxuICAgICAgICAgICAgICAgIGlmKHR5cGVvZih0aGlzLmlucHV0LmlzRW1wdHkpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNFbXB0eSA9IHRoaXMuaW5wdXQuaXNFbXB0eSh0aGlzLiRlbGVtZW50KTsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNFbXB0eSA9ICQudHJpbSh0aGlzLiRlbGVtZW50Lmh0bWwoKSkgPT09ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2VtcHR5dGV4dCBzaG93biBvbmx5IGZvciBlbmFibGVkXG4gICAgICAgICAgICBpZighdGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50Lmh0bWwodGhpcy5vcHRpb25zLmVtcHR5dGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5lbXB0eWNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5lbXB0eWNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZih0aGlzLm9wdGlvbnMuZW1wdHljbGFzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5lbXB0eWNsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vYmVsb3cgcmVxdWlyZWQgaWYgZWxlbWVudCBkaXNhYmxlIHByb3BlcnR5IHdhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgaWYodGhpcy5pc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmVtcHR5Y2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmVtcHR5Y2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgU2hvd3MgY29udGFpbmVyIHdpdGggZm9ybVxuICAgICAgICBAbWV0aG9kIHNob3coKVxuICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IGNsb3NlQWxsIFdoZXRoZXIgdG8gY2xvc2UgYWxsIG90aGVyIGVkaXRhYmxlIGNvbnRhaW5lcnMgd2hlbiBzaG93aW5nIHRoaXMgb25lLiBEZWZhdWx0IHRydWUuXG4gICAgICAgICoqLyAgXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uIChjbG9zZUFsbCkge1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2luaXQgZWRpdGFibGVDb250YWluZXI6IHBvcG92ZXIsIHRvb2x0aXAsIGlubGluZSwgZXRjLi5cbiAgICAgICAgICAgIGlmKCF0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJPcHRpb25zID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRoaXMuaW5wdXQgLy9wYXNzIGlucHV0IHRvIGZvcm0gKGFzIGl0IGlzIGFscmVhZHkgY3JlYXRlZClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LmVkaXRhYmxlQ29udGFpbmVyKGNvbnRhaW5lck9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIC8vbGlzdGVuIGBzYXZlYCBldmVudCBcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKFwic2F2ZS5pbnRlcm5hbFwiLCAkLnByb3h5KHRoaXMuc2F2ZSwgdGhpcykpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy4kZWxlbWVudC5kYXRhKCdlZGl0YWJsZUNvbnRhaW5lcicpOyBcbiAgICAgICAgICAgIH0gZWxzZSBpZih0aGlzLmNvbnRhaW5lci50aXAoKS5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9zaG93IGNvbnRhaW5lclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc2hvdyhjbG9zZUFsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgSGlkZXMgY29udGFpbmVyIHdpdGggZm9ybVxuICAgICAgICBAbWV0aG9kIGhpZGUoKVxuICAgICAgICAqKi8gICAgICAgXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHsgICBcbiAgICAgICAgICAgIGlmKHRoaXMuY29udGFpbmVyKSB7ICBcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgVG9nZ2xlcyBjb250YWluZXIgdmlzaWJpbGl0eSAoc2hvdyAvIGhpZGUpXG4gICAgICAgIEBtZXRob2QgdG9nZ2xlKClcbiAgICAgICAgQHBhcmFtIHtib29sZWFufSBjbG9zZUFsbCBXaGV0aGVyIHRvIGNsb3NlIGFsbCBvdGhlciBlZGl0YWJsZSBjb250YWluZXJzIHdoZW4gc2hvd2luZyB0aGlzIG9uZS4gRGVmYXVsdCB0cnVlLlxuICAgICAgICAqKi8gIFxuICAgICAgICB0b2dnbGU6IGZ1bmN0aW9uKGNsb3NlQWxsKSB7XG4gICAgICAgICAgICBpZih0aGlzLmNvbnRhaW5lciAmJiB0aGlzLmNvbnRhaW5lci50aXAoKS5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3coY2xvc2VBbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgKiBjYWxsZWQgd2hlbiBmb3JtIHdhcyBzdWJtaXR0ZWRcbiAgICAgICAgKi8gICAgICAgICAgXG4gICAgICAgIHNhdmU6IGZ1bmN0aW9uKGUsIHBhcmFtcykge1xuICAgICAgICAgICAgLy9tYXJrIGVsZW1lbnQgd2l0aCB1bnNhdmVkIGNsYXNzIGlmIG5lZWRlZFxuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnVuc2F2ZWRjbGFzcykge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgIEFkZCB1bnNhdmVkIGNzcyB0byBlbGVtZW50IGlmOlxuICAgICAgICAgICAgICAgICAgLSB1cmwgaXMgbm90IHVzZXIncyBmdW5jdGlvbiBcbiAgICAgICAgICAgICAgICAgIC0gdmFsdWUgd2FzIG5vdCBzZW50IHRvIHNlcnZlclxuICAgICAgICAgICAgICAgICAgLSBwYXJhbXMucmVzcG9uc2UgPT09IHVuZGVmaW5lZCwgdGhhdCBtZWFucyBkYXRhIHdhcyBub3Qgc2VudFxuICAgICAgICAgICAgICAgICAgLSB2YWx1ZSBjaGFuZ2VkIFxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIHNlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzZW50ID0gc2VudCB8fCB0eXBlb2YgdGhpcy5vcHRpb25zLnVybCA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgICAgICAgICBzZW50ID0gc2VudCB8fCB0aGlzLm9wdGlvbnMuZGlzcGxheSA9PT0gZmFsc2U7IFxuICAgICAgICAgICAgICAgIHNlbnQgPSBzZW50IHx8IHBhcmFtcy5yZXNwb25zZSAhPT0gdW5kZWZpbmVkOyBcbiAgICAgICAgICAgICAgICBzZW50ID0gc2VudCB8fCAodGhpcy5vcHRpb25zLnNhdmVub2NoYW5nZSAmJiB0aGlzLmlucHV0LnZhbHVlMnN0cih0aGlzLnZhbHVlKSAhPT0gdGhpcy5pbnB1dC52YWx1ZTJzdHIocGFyYW1zLm5ld1ZhbHVlKSk7IFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMudW5zYXZlZGNsYXNzKTsgXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMudW5zYXZlZGNsYXNzKTsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9oaWdobGlnaHQgd2hlbiBzYXZpbmdcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgJGUgPSB0aGlzLiRlbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yID0gJGUuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJyk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICRlLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIHRoaXMub3B0aW9ucy5oaWdobGlnaHQpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoYmdDb2xvciA9PT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmdDb2xvciA9ICcnOyBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkZS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBiZ0NvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgJGUuYWRkQ2xhc3MoJ2VkaXRhYmxlLWJnLXRyYW5zaXRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAkZS5yZW1vdmVDbGFzcygnZWRpdGFibGUtYmctdHJhbnNpdGlvbicpOyAgXG4gICAgICAgICAgICAgICAgICAgIH0sIDE3MDApO1xuICAgICAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9zZXQgbmV3IHZhbHVlXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKHBhcmFtcy5uZXdWYWx1ZSwgZmFsc2UsIHBhcmFtcy5yZXNwb25zZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8qKiAgICAgICAgXG4gICAgICAgICAgICBGaXJlZCB3aGVuIG5ldyB2YWx1ZSB3YXMgc3VibWl0dGVkLiBZb3UgY2FuIHVzZSA8Y29kZT4kKHRoaXMpLmRhdGEoJ2VkaXRhYmxlJyk8L2NvZGU+IHRvIGFjY2VzcyB0byBlZGl0YWJsZSBpbnN0YW5jZVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBAZXZlbnQgc2F2ZSBcbiAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBldmVudCBldmVudCBvYmplY3RcbiAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgYWRkaXRpb25hbCBwYXJhbXNcbiAgICAgICAgICAgIEBwYXJhbSB7bWl4ZWR9IHBhcmFtcy5uZXdWYWx1ZSBzdWJtaXR0ZWQgdmFsdWVcbiAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMucmVzcG9uc2UgYWpheCByZXNwb25zZVxuICAgICAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgICAgICQoJyN1c2VybmFtZScpLm9uKCdzYXZlJywgZnVuY3Rpb24oZSwgcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgYWxlcnQoJ1NhdmVkIHZhbHVlOiAnICsgcGFyYW1zLm5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKiovXG4gICAgICAgICAgICAvL2V2ZW50IGl0c2VsZiBpcyB0cmlnZ2VyZWQgYnkgZWRpdGFibGVDb250YWluZXIuIERlc2NyaXB0aW9uIGhlcmUgaXMgb25seSBmb3IgZG9jdW1lbnRhdGlvbiAgICAgICAgICAgICAgXG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnZhbGlkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy52YWxpZGF0ZS5jYWxsKHRoaXMsIHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIFNldHMgbmV3IHZhbHVlIG9mIGVkaXRhYmxlXG4gICAgICAgIEBtZXRob2Qgc2V0VmFsdWUodmFsdWUsIGNvbnZlcnRTdHIpXG4gICAgICAgIEBwYXJhbSB7bWl4ZWR9IHZhbHVlIG5ldyB2YWx1ZSBcbiAgICAgICAgQHBhcmFtIHtib29sZWFufSBjb252ZXJ0U3RyIHdoZXRoZXIgdG8gY29udmVydCB2YWx1ZSBmcm9tIHN0cmluZyB0byBpbnRlcm5hbCBmb3JtYXRcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgY29udmVydFN0ciwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmKGNvbnZlcnRTdHIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5pbnB1dC5zdHIydmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLm9wdGlvbigndmFsdWUnLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICQud2hlbih0aGlzLnJlbmRlcihyZXNwb25zZSkpXG4gICAgICAgICAgICAudGhlbigkLnByb3h5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRW1wdHkoKTtcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBBY3RpdmF0ZXMgaW5wdXQgb2YgdmlzaWJsZSBjb250YWluZXIgKGUuZy4gc2V0IGZvY3VzKVxuICAgICAgICBAbWV0aG9kIGFjdGl2YXRlKClcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hY3RpdmF0ZSgpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBSZW1vdmVzIGVkaXRhYmxlIGZlYXR1cmUgZnJvbSBlbGVtZW50XG4gICAgICAgIEBtZXRob2QgZGVzdHJveSgpXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5kZXN0cm95KCk7IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcblxuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnRvZ2dsZSAhPT0gJ21hbnVhbCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdlZGl0YWJsZS1jbGljaycpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKHRoaXMub3B0aW9ucy50b2dnbGUgKyAnLmVkaXRhYmxlJyk7XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZihcInNhdmUuaW50ZXJuYWxcIik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2VkaXRhYmxlIGVkaXRhYmxlLW9wZW4gZWRpdGFibGUtZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlRGF0YSgnZWRpdGFibGUnKTtcbiAgICAgICAgfSAgICAgICAgXG4gICAgfTtcblxuICAgIC8qIEVESVRBQkxFIFBMVUdJTiBERUZJTklUSU9OXG4gICAgKiA9PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICAgLyoqXG4gICAgalF1ZXJ5IG1ldGhvZCB0byBpbml0aWFsaXplIGVkaXRhYmxlIGVsZW1lbnQuXG4gICAgXG4gICAgQG1ldGhvZCAkKCkuZWRpdGFibGUob3B0aW9ucylcbiAgICBAcGFyYW1zIHtPYmplY3R9IG9wdGlvbnNcbiAgICBAZXhhbXBsZVxuICAgICQoJyN1c2VybmFtZScpLmVkaXRhYmxlKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICB1cmw6ICcvcG9zdCcsXG4gICAgICAgIHBrOiAxXG4gICAgfSk7XG4gICAgKiovXG4gICAgJC5mbi5lZGl0YWJsZSA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgLy9zcGVjaWFsIEFQSSBtZXRob2RzIHJldHVybmluZyBub24tanF1ZXJ5IG9iamVjdFxuICAgICAgICB2YXIgcmVzdWx0ID0ge30sIGFyZ3MgPSBhcmd1bWVudHMsIGRhdGFrZXkgPSAnZWRpdGFibGUnO1xuICAgICAgICBzd2l0Y2ggKG9wdGlvbikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBSdW5zIGNsaWVudC1zaWRlIHZhbGlkYXRpb24gZm9yIGFsbCBtYXRjaGVkIGVkaXRhYmxlc1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBAbWV0aG9kIHZhbGlkYXRlKClcbiAgICAgICAgICAgIEByZXR1cm5zIHtPYmplY3R9IHZhbGlkYXRpb24gZXJyb3JzIG1hcFxuICAgICAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgICAgICQoJyN1c2VybmFtZSwgI2Z1bGxuYW1lJykuZWRpdGFibGUoJ3ZhbGlkYXRlJyk7XG4gICAgICAgICAgICAvLyBwb3NzaWJsZSByZXN1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHVzZXJuYW1lOiBcInVzZXJuYW1lIGlzIHJlcXVpcmVkXCIsXG4gICAgICAgICAgICAgIGZ1bGxuYW1lOiBcImZ1bGxuYW1lIHNob3VsZCBiZSBtaW5pbXVtIDMgbGV0dGVycyBsZW5ndGhcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKiovXG4gICAgICAgICAgICBjYXNlICd2YWxpZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSwgZGF0YSA9ICR0aGlzLmRhdGEoZGF0YWtleSksIGVycm9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiAoZXJyb3IgPSBkYXRhLnZhbGlkYXRlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbZGF0YS5vcHRpb25zLm5hbWVdID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgUmV0dXJucyBjdXJyZW50IHZhbHVlcyBvZiBlZGl0YWJsZSBlbGVtZW50cy4gICBcbiAgICAgICAgICAgIE5vdGUgdGhhdCBpdCByZXR1cm5zIGFuICoqb2JqZWN0Kiogd2l0aCBuYW1lLXZhbHVlIHBhaXJzLCBub3QgYSB2YWx1ZSBpdHNlbGYuIEl0IGFsbG93cyB0byBnZXQgZGF0YSBmcm9tIHNldmVyYWwgZWxlbWVudHMuICAgIFxuICAgICAgICAgICAgSWYgdmFsdWUgb2Ygc29tZSBlZGl0YWJsZSBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgaXQgaXMgZXhjbHVkZWQgZnJvbSByZXN1bHQgb2JqZWN0LlxuICAgICAgICAgICAgV2hlbiBwYXJhbSBgaXNTaW5nbGVgIGlzIHNldCB0byAqKnRydWUqKiAtIGl0IGlzIHN1cHBvc2VkIHlvdSBoYXZlIHNpbmdsZSBlbGVtZW50IGFuZCB3aWxsIHJldHVybiB2YWx1ZSBvZiBlZGl0YWJsZSBpbnN0ZWFkIG9mIG9iamVjdC4gICBcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgIEBtZXRob2QgZ2V0VmFsdWUoKVxuICAgICAgICAgICAgQHBhcmFtIHtib29sfSBpc1NpbmdsZSB3aGV0aGVyIHRvIHJldHVybiBqdXN0IHZhbHVlIG9mIHNpbmdsZSBlbGVtZW50XG4gICAgICAgICAgICBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3Qgb2YgZWxlbWVudCBuYW1lcyBhbmQgdmFsdWVzXG4gICAgICAgICAgICBAZXhhbXBsZVxuICAgICAgICAgICAgJCgnI3VzZXJuYW1lLCAjZnVsbG5hbWUnKS5lZGl0YWJsZSgnZ2V0VmFsdWUnKTtcbiAgICAgICAgICAgIC8vcmVzdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgdXNlcm5hbWU6IFwic3VwZXJ1c2VyXCIsXG4gICAgICAgICAgICBmdWxsbmFtZTogXCJKb2huXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaXNTaW5nbGUgPSB0cnVlXG4gICAgICAgICAgICAkKCcjdXNlcm5hbWUnKS5lZGl0YWJsZSgnZ2V0VmFsdWUnLCB0cnVlKTtcbiAgICAgICAgICAgIC8vcmVzdWx0IFwic3VwZXJ1c2VyXCIgXG4gICAgICAgICAgICAqKi9cbiAgICAgICAgICAgIGNhc2UgJ2dldFZhbHVlJzpcbiAgICAgICAgICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIGFyZ3VtZW50c1sxXSA9PT0gdHJ1ZSkgeyAvL2lzU2luZ2xlID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmVxKDApLmRhdGEoZGF0YWtleSkudmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksIGRhdGEgPSAkdGhpcy5kYXRhKGRhdGFrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGRhdGEudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbZGF0YS5vcHRpb25zLm5hbWVdID0gZGF0YS5pbnB1dC52YWx1ZTJzdWJtaXQoZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgVGhpcyBtZXRob2QgY29sbGVjdHMgdmFsdWVzIGZyb20gc2V2ZXJhbCBlZGl0YWJsZSBlbGVtZW50cyBhbmQgc3VibWl0IHRoZW0gYWxsIHRvIHNlcnZlci4gICBcbiAgICAgICAgICAgIEludGVybmFsbHkgaXQgcnVucyBjbGllbnQtc2lkZSB2YWxpZGF0aW9uIGZvciBhbGwgZmllbGRzIGFuZCBzdWJtaXRzIG9ubHkgaW4gY2FzZSBvZiBzdWNjZXNzLiAgXG4gICAgICAgICAgICBTZWUgPGEgaHJlZj1cIiNuZXdyZWNvcmRcIj5jcmVhdGluZyBuZXcgcmVjb3JkczwvYT4gZm9yIGRldGFpbHMuICBcbiAgICAgICAgICAgIFNpbmNlIDEuNS4xIGBzdWJtaXRgIGNhbiBiZSBhcHBsaWVkIHRvIHNpbmdsZSBlbGVtZW50IHRvIHNlbmQgZGF0YSBwcm9ncmFtbWF0aWNhbGx5LiBJbiB0aGF0IGNhc2VcbiAgICAgICAgICAgIGB1cmxgLCBgc3VjY2Vzc2AgYW5kIGBlcnJvcmAgaXMgdGFrZW4gZnJvbSBpbml0aWFsIG9wdGlvbnMgYW5kIHlvdSBjYW4ganVzdCBjYWxsIGAkKCcjdXNlcm5hbWUnKS5lZGl0YWJsZSgnc3VibWl0JylgLiBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgQG1ldGhvZCBzdWJtaXQob3B0aW9ucylcbiAgICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIFxuICAgICAgICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudXJsIHVybCB0byBzdWJtaXQgZGF0YSBcbiAgICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmRhdGEgYWRkaXRpb25hbCBkYXRhIHRvIHN1Ym1pdFxuICAgICAgICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuYWpheE9wdGlvbnMgYWRkaXRpb25hbCBhamF4IG9wdGlvbnNcbiAgICAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuZXJyb3Iob2JqKSBlcnJvciBoYW5kbGVyIFxuICAgICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5zdWNjZXNzKG9iaixjb25maWcpIHN1Y2Nlc3MgaGFuZGxlclxuICAgICAgICAgICAgQHJldHVybnMge09iamVjdH0galF1ZXJ5IG9iamVjdFxuICAgICAgICAgICAgKiovXG4gICAgICAgICAgICBjYXNlICdzdWJtaXQnOiAgLy9jb2xsZWN0cyB2YWx1ZSwgdmFsaWRhdGUgYW5kIHN1Ym1pdCB0byBzZXJ2ZXIgZm9yIGNyZWF0aW5nIG5ldyByZWNvcmRcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gYXJndW1lbnRzWzFdIHx8IHt9LFxuICAgICAgICAgICAgICAgICRlbGVtcyA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZXJyb3JzID0gdGhpcy5lZGl0YWJsZSgndmFsaWRhdGUnKTtcblxuICAgICAgICAgICAgICAgIC8vIHZhbGlkYXRpb24gb2tcbiAgICAgICAgICAgICAgICBpZigkLmlzRW1wdHlPYmplY3QoZXJyb3JzKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWpheE9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBmb3Igc2luZ2xlIGVsZW1lbnQgdXNlIHVybCwgc3VjY2VzcyBldGMgZnJvbSBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIGlmKCRlbGVtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlZGl0YWJsZSA9ICRlbGVtcy5kYXRhKCdlZGl0YWJsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9zdGFuZGFyZCBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZWRpdGFibGUub3B0aW9ucy5uYW1lIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlZGl0YWJsZS5pbnB1dC52YWx1ZTJzdWJtaXQoZWRpdGFibGUudmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrOiAodHlwZW9mIGVkaXRhYmxlLm9wdGlvbnMucGsgPT09ICdmdW5jdGlvbicpID8gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlLm9wdGlvbnMucGsuY2FsbChlZGl0YWJsZS5vcHRpb25zLnNjb3BlKSA6IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZS5vcHRpb25zLnBrIFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hZGRpdGlvbmFsIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGVkaXRhYmxlLm9wdGlvbnMucGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gZWRpdGFibGUub3B0aW9ucy5wYXJhbXMuY2FsbChlZGl0YWJsZS5vcHRpb25zLnNjb3BlLCBwYXJhbXMpOyAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ5IHBhcnNlIGpzb24gaW4gc2luZ2xlIHF1b3RlcyAoZnJvbSBkYXRhLXBhcmFtcyBhdHRyaWJ1dGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdGFibGUub3B0aW9ucy5wYXJhbXMgPSAkLmZuLmVkaXRhYmxldXRpbHMudHJ5UGFyc2VKc29uKGVkaXRhYmxlLm9wdGlvbnMucGFyYW1zLCB0cnVlKTsgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZChwYXJhbXMsIGVkaXRhYmxlLm9wdGlvbnMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYWpheE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBlZGl0YWJsZS5vcHRpb25zLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1BPU1QnICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSBzdWNjZXNzIC8gZXJyb3IgZnJvbSBvcHRpb25zIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnN1Y2Nlc3MgPSBjb25maWcuc3VjY2VzcyB8fCBlZGl0YWJsZS5vcHRpb25zLnN1Y2Nlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZXJyb3IgPSBjb25maWcuZXJyb3IgfHwgZWRpdGFibGUub3B0aW9ucy5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBtdWx0aXBsZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZWRpdGFibGUoJ2dldFZhbHVlJyk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBhamF4T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGNvbmZpZy51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdmFsdWVzLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUE9TVCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH07ICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFqYXggc3VjY2VzcyBjYWxsYWJjayAocmVzcG9uc2UgMjAwIE9LKVxuICAgICAgICAgICAgICAgICAgICBhamF4T3B0aW9ucy5zdWNjZXNzID0gdHlwZW9mIGNvbmZpZy5zdWNjZXNzID09PSAnZnVuY3Rpb24nID8gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuc3VjY2Vzcy5jYWxsKCRlbGVtcywgcmVzcG9uc2UsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IDogJC5ub29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBhamF4IGVycm9yIGNhbGxhYmNrXG4gICAgICAgICAgICAgICAgICAgIGFqYXhPcHRpb25zLmVycm9yID0gdHlwZW9mIGNvbmZpZy5lcnJvciA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZXJyb3IuYXBwbHkoJGVsZW1zLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSA6ICQubm9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4dGVuZCBhamF4T3B0aW9ucyAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYoY29uZmlnLmFqYXhPcHRpb25zKSB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQoYWpheE9wdGlvbnMsIGNvbmZpZy5hamF4T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4dHJhIGRhdGEgXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvbmZpZy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZChhamF4T3B0aW9ucy5kYXRhLCBjb25maWcuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIHBlcmZvcm0gYWpheCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICQuYWpheChhamF4T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy9jbGllbnQtc2lkZSB2YWxpZGF0aW9uIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBjb25maWcuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5lcnJvci5jYWxsKCRlbGVtcywgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9yZXR1cm4ganF1ZXJ5IG9iamVjdFxuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksIFxuICAgICAgICAgICAgICAgIGRhdGEgPSAkdGhpcy5kYXRhKGRhdGFrZXkpLCBcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PT0gJ29iamVjdCcgJiYgb3B0aW9uO1xuXG4gICAgICAgICAgICAvL2ZvciBkZWxlZ2F0ZWQgdGFyZ2V0cyBkbyBub3Qgc3RvcmUgYGVkaXRhYmxlYCBvYmplY3QgZm9yIGVsZW1lbnRcbiAgICAgICAgICAgIC8vaXQncyBhbGxvd3Mgc2V2ZXJhbCBkaWZmZXJlbnQgc2VsZWN0b3JzLlxuICAgICAgICAgICAgLy9zZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS92aXRhbGV0cy94LWVkaXRhYmxlL2lzc3Vlcy8zMTIgICAgXG4gICAgICAgICAgICBpZihvcHRpb25zICYmIG9wdGlvbnMuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gbmV3IEVkaXRhYmxlKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybjsgXG4gICAgICAgICAgICB9ICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5kYXRhKGRhdGFrZXksIChkYXRhID0gbmV3IEVkaXRhYmxlKHRoaXMsIG9wdGlvbnMpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnc3RyaW5nJykgeyAvL2NhbGwgbWV0aG9kIFxuICAgICAgICAgICAgICAgIGRhdGFbb3B0aW9uXS5hcHBseShkYXRhLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG4gICAgICAgICAgICB9IFxuICAgICAgICB9KTtcbiAgICB9OyAgICBcbiAgICAgICAgICAgIFxuXG4gICAgJC5mbi5lZGl0YWJsZS5kZWZhdWx0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgIFR5cGUgb2YgaW5wdXQuIENhbiBiZSA8Y29kZT50ZXh0fHRleHRhcmVhfHNlbGVjdHxkYXRlfGNoZWNrbGlzdDwvY29kZT4gYW5kIG1vcmVcblxuICAgICAgICBAcHJvcGVydHkgdHlwZSBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICd0ZXh0J1xuICAgICAgICAqKi9cbiAgICAgICAgdHlwZTogJ3RleHQnLCAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBTZXRzIGRpc2FibGVkIHN0YXRlIG9mIGVkaXRhYmxlXG5cbiAgICAgICAgQHByb3BlcnR5IGRpc2FibGVkIFxuICAgICAgICBAdHlwZSBib29sZWFuXG4gICAgICAgIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICBIb3cgdG8gdG9nZ2xlIGVkaXRhYmxlLiBDYW4gYmUgPGNvZGU+Y2xpY2t8ZGJsY2xpY2t8bW91c2VlbnRlcnxtYW51YWw8L2NvZGU+LiAgIFxuICAgICAgICBXaGVuIHNldCB0byA8Y29kZT5tYW51YWw8L2NvZGU+IHlvdSBzaG91bGQgbWFudWFsbHkgY2FsbCA8Y29kZT5zaG93L2hpZGU8L2NvZGU+IG1ldGhvZHMgb2YgZWRpdGFibGUuICAgIFxuICAgICAgICAqKk5vdGUqKjogaWYgeW91IGNhbGwgPGNvZGU+c2hvdzwvY29kZT4gb3IgPGNvZGU+dG9nZ2xlPC9jb2RlPiBpbnNpZGUgKipjbGljayoqIGhhbmRsZXIgb2Ygc29tZSBET00gZWxlbWVudCwgXG4gICAgICAgIHlvdSBuZWVkIHRvIGFwcGx5IDxjb2RlPmUuc3RvcFByb3BhZ2F0aW9uKCk8L2NvZGU+IGJlY2F1c2UgY29udGFpbmVycyBhcmUgYmVpbmcgY2xvc2VkIG9uIGFueSBjbGljayBvbiBkb2N1bWVudC5cbiAgICAgICAgXG4gICAgICAgIEBleGFtcGxlXG4gICAgICAgICQoJyNlZGl0LWJ1dHRvbicpLmNsaWNrKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAkKCcjdXNlcm5hbWUnKS5lZGl0YWJsZSgndG9nZ2xlJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIEBwcm9wZXJ0eSB0b2dnbGUgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAnY2xpY2snXG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgdG9nZ2xlOiAnY2xpY2snLFxuICAgICAgICAvKipcbiAgICAgICAgVGV4dCBzaG93biB3aGVuIGVsZW1lbnQgaXMgZW1wdHkuXG5cbiAgICAgICAgQHByb3BlcnR5IGVtcHR5dGV4dCBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICdFbXB0eSdcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGVtcHR5dGV4dDogJ0VtcHR5JyxcbiAgICAgICAgLyoqXG4gICAgICAgIEFsbG93cyB0byBhdXRvbWF0aWNhbGx5IHNldCBlbGVtZW50J3MgdGV4dCBiYXNlZCBvbiBpdCdzIHZhbHVlLiBDYW4gYmUgPGNvZGU+YXV0b3xhbHdheXN8bmV2ZXI8L2NvZGU+LiBVc2VmdWwgZm9yIHNlbGVjdCBhbmQgZGF0ZS5cbiAgICAgICAgRm9yIGV4YW1wbGUsIGlmIGRyb3Bkb3duIGxpc3QgaXMgPGNvZGU+ezE6ICdhJywgMjogJ2InfTwvY29kZT4gYW5kIGVsZW1lbnQncyB2YWx1ZSBzZXQgdG8gPGNvZGU+MTwvY29kZT4sIGl0J3MgaHRtbCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIDxjb2RlPidhJzwvY29kZT4uICBcbiAgICAgICAgPGNvZGU+YXV0bzwvY29kZT4gLSB0ZXh0IHdpbGwgYmUgYXV0b21hdGljYWxseSBzZXQgb25seSBpZiBlbGVtZW50IGlzIGVtcHR5LiAgXG4gICAgICAgIDxjb2RlPmFsd2F5c3xuZXZlcjwvY29kZT4gLSBhbHdheXMobmV2ZXIpIHRyeSB0byBzZXQgZWxlbWVudCdzIHRleHQuXG5cbiAgICAgICAgQHByb3BlcnR5IGF1dG90ZXh0IFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgJ2F1dG8nXG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgYXV0b3RleHQ6ICdhdXRvJywgXG4gICAgICAgIC8qKlxuICAgICAgICBJbml0aWFsIHZhbHVlIG9mIGlucHV0LiBJZiBub3Qgc2V0LCB0YWtlbiBmcm9tIGVsZW1lbnQncyB0ZXh0LiAgXG4gICAgICAgIE5vdGUsIHRoYXQgaWYgZWxlbWVudCdzIHRleHQgaXMgZW1wdHkgLSB0ZXh0IGlzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGZyb20gdmFsdWUgYW5kIGNhbiBiZSBjdXN0b21pemVkIChzZWUgYGF1dG90ZXh0YCBvcHRpb24pLiAgXG4gICAgICAgIEZvciBleGFtcGxlLCB0byBkaXNwbGF5IGN1cnJlbmN5IHNpZ246XG4gICAgICAgIEBleGFtcGxlXG4gICAgICAgIDxhIGlkPVwicHJpY2VcIiBkYXRhLXR5cGU9XCJ0ZXh0XCIgZGF0YS12YWx1ZT1cIjEwMFwiPjwvYT5cbiAgICAgICAgPHNjcmlwdD5cbiAgICAgICAgJCgnI3ByaWNlJykuZWRpdGFibGUoe1xuICAgICAgICAgICAgLi4uXG4gICAgICAgICAgICBkaXNwbGF5OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAkKHRoaXMpLnRleHQodmFsdWUgKyAnJCcpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgfSkgXG4gICAgICAgIDwvc2NyaXB0PlxuICAgICAgICAgICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgdmFsdWUgXG4gICAgICAgIEB0eXBlIG1peGVkXG4gICAgICAgIEBkZWZhdWx0IGVsZW1lbnQncyB0ZXh0XG4gICAgICAgICoqL1xuICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIENhbGxiYWNrIHRvIHBlcmZvcm0gY3VzdG9tIGRpc3BsYXlpbmcgb2YgdmFsdWUgaW4gZWxlbWVudCdzIHRleHQuICBcbiAgICAgICAgSWYgYG51bGxgLCBkZWZhdWx0IGlucHV0J3MgZGlzcGxheSB1c2VkLiAgXG4gICAgICAgIElmIGBmYWxzZWAsIG5vIGRpc3BsYXlpbmcgbWV0aG9kcyB3aWxsIGJlIGNhbGxlZCwgZWxlbWVudCdzIHRleHQgd2lsbCBuZXZlciBjaGFuZ2UuICBcbiAgICAgICAgUnVucyB1bmRlciBlbGVtZW50J3Mgc2NvcGUuICBcbiAgICAgICAgXyoqUGFyYW1ldGVyczoqKl8gIFxuICAgICAgICBcbiAgICAgICAgKiBgdmFsdWVgIGN1cnJlbnQgdmFsdWUgdG8gYmUgZGlzcGxheWVkXG4gICAgICAgICogYHJlc3BvbnNlYCBzZXJ2ZXIgcmVzcG9uc2UgKGlmIGRpc3BsYXkgY2FsbGVkIGFmdGVyIGFqYXggc3VibWl0KSwgc2luY2UgMS40LjBcbiAgICAgICAgIFxuICAgICAgICBGb3IgX2lucHV0cyB3aXRoIHNvdXJjZV8gKHNlbGVjdCwgY2hlY2tsaXN0KSBwYXJhbWV0ZXJzIGFyZSBkaWZmZXJlbnQ6ICBcbiAgICAgICAgICBcbiAgICAgICAgKiBgdmFsdWVgIGN1cnJlbnQgdmFsdWUgdG8gYmUgZGlzcGxheWVkXG4gICAgICAgICogYHNvdXJjZURhdGFgIGFycmF5IG9mIGl0ZW1zIGZvciBjdXJyZW50IGlucHV0IChlLmcuIGRyb3Bkb3duIGl0ZW1zKSBcbiAgICAgICAgKiBgcmVzcG9uc2VgIHNlcnZlciByZXNwb25zZSAoaWYgZGlzcGxheSBjYWxsZWQgYWZ0ZXIgYWpheCBzdWJtaXQpLCBzaW5jZSAxLjQuMFxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgIFRvIGdldCBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbXMgdXNlIGAkLmZuLmVkaXRhYmxldXRpbHMuaXRlbXNCeVZhbHVlKHZhbHVlLCBzb3VyY2VEYXRhKWAuXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgZGlzcGxheSBcbiAgICAgICAgQHR5cGUgZnVuY3Rpb258Ym9vbGVhblxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBzaW5jZSAxLjIuMFxuICAgICAgICBAZXhhbXBsZVxuICAgICAgICBkaXNwbGF5OiBmdW5jdGlvbih2YWx1ZSwgc291cmNlRGF0YSkge1xuICAgICAgICAgICAvL2Rpc3BsYXkgY2hlY2tsaXN0IGFzIGNvbW1hLXNlcGFyYXRlZCB2YWx1ZXNcbiAgICAgICAgICAgdmFyIGh0bWwgPSBbXSxcbiAgICAgICAgICAgICAgIGNoZWNrZWQgPSAkLmZuLmVkaXRhYmxldXRpbHMuaXRlbXNCeVZhbHVlKHZhbHVlLCBzb3VyY2VEYXRhKTtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICBpZihjaGVja2VkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgJC5lYWNoKGNoZWNrZWQsIGZ1bmN0aW9uKGksIHYpIHsgaHRtbC5wdXNoKCQuZm4uZWRpdGFibGV1dGlscy5lc2NhcGUodi50ZXh0KSk7IH0pO1xuICAgICAgICAgICAgICAgJCh0aGlzKS5odG1sKGh0bWwuam9pbignLCAnKSk7XG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAkKHRoaXMpLmVtcHR5KCk7IFxuICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKiovICAgICAgICAgIFxuICAgICAgICBkaXNwbGF5OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgQ3NzIGNsYXNzIGFwcGxpZWQgd2hlbiBlZGl0YWJsZSB0ZXh0IGlzIGVtcHR5LlxuXG4gICAgICAgIEBwcm9wZXJ0eSBlbXB0eWNsYXNzIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQHNpbmNlIDEuNC4xICAgICAgICBcbiAgICAgICAgQGRlZmF1bHQgZWRpdGFibGUtZW1wdHlcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgZW1wdHljbGFzczogJ2VkaXRhYmxlLWVtcHR5JyxcbiAgICAgICAgLyoqXG4gICAgICAgIENzcyBjbGFzcyBhcHBsaWVkIHdoZW4gdmFsdWUgd2FzIHN0b3JlZCBidXQgbm90IHNlbnQgdG8gc2VydmVyIChgcGtgIGlzIGVtcHR5IG9yIGBzZW5kID0gJ25ldmVyJ2ApLiAgXG4gICAgICAgIFlvdSBtYXkgc2V0IGl0IHRvIGBudWxsYCBpZiB5b3Ugd29yayB3aXRoIGVkaXRhYmxlcyBsb2NhbGx5IGFuZCBzdWJtaXQgdGhlbSB0b2dldGhlci4gIFxuXG4gICAgICAgIEBwcm9wZXJ0eSB1bnNhdmVkY2xhc3MgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAc2luY2UgMS40LjEgICAgICAgIFxuICAgICAgICBAZGVmYXVsdCBlZGl0YWJsZS11bnNhdmVkXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIHVuc2F2ZWRjbGFzczogJ2VkaXRhYmxlLXVuc2F2ZWQnLFxuICAgICAgICAvKipcbiAgICAgICAgSWYgc2VsZWN0b3IgaXMgcHJvdmlkZWQsIGVkaXRhYmxlIHdpbGwgYmUgZGVsZWdhdGVkIHRvIHRoZSBzcGVjaWZpZWQgdGFyZ2V0cy4gIFxuICAgICAgICBVc2VmdWxsIGZvciBkeW5hbWljYWxseSBnZW5lcmF0ZWQgRE9NIGVsZW1lbnRzLiAgXG4gICAgICAgICoqUGxlYXNlIG5vdGUqKiwgdGhhdCBkZWxlZ2F0ZWQgdGFyZ2V0cyBjYW4ndCBiZSBpbml0aWFsaXplZCB3aXRoIGBlbXB0eXRleHRgIGFuZCBgYXV0b3RleHRgIG9wdGlvbnMsIFxuICAgICAgICBhcyB0aGV5IGFjdHVhbGx5IGJlY29tZSBlZGl0YWJsZSBvbmx5IGFmdGVyIGZpcnN0IGNsaWNrLiAgXG4gICAgICAgIFlvdSBzaG91bGQgbWFudWFsbHkgc2V0IGNsYXNzIGBlZGl0YWJsZS1jbGlja2AgdG8gdGhlc2UgZWxlbWVudHMuICBcbiAgICAgICAgQWxzbywgaWYgZWxlbWVudCBvcmlnaW5hbGx5IGVtcHR5IHlvdSBzaG91bGQgYWRkIGNsYXNzIGBlZGl0YWJsZS1lbXB0eWAsIHNldCBgZGF0YS12YWx1ZT1cIlwiYCBhbmQgd3JpdGUgZW1wdHl0ZXh0IGludG8gZWxlbWVudDpcblxuICAgICAgICBAcHJvcGVydHkgc2VsZWN0b3IgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAc2luY2UgMS40LjEgICAgICAgIFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBleGFtcGxlXG4gICAgICAgIDxkaXYgaWQ9XCJ1c2VyXCI+XG4gICAgICAgICAgPCEtLSBlbXB0eSAtLT5cbiAgICAgICAgICA8YSBocmVmPVwiI1wiIGRhdGEtbmFtZT1cInVzZXJuYW1lXCIgZGF0YS10eXBlPVwidGV4dFwiIGNsYXNzPVwiZWRpdGFibGUtY2xpY2sgZWRpdGFibGUtZW1wdHlcIiBkYXRhLXZhbHVlPVwiXCIgdGl0bGU9XCJVc2VybmFtZVwiPkVtcHR5PC9hPlxuICAgICAgICAgIDwhLS0gbm9uLWVtcHR5IC0tPlxuICAgICAgICAgIDxhIGhyZWY9XCIjXCIgZGF0YS1uYW1lPVwiZ3JvdXBcIiBkYXRhLXR5cGU9XCJzZWxlY3RcIiBkYXRhLXNvdXJjZT1cIi9ncm91cHNcIiBkYXRhLXZhbHVlPVwiMVwiIGNsYXNzPVwiZWRpdGFibGUtY2xpY2tcIiB0aXRsZT1cIkdyb3VwXCI+T3BlcmF0b3I8L2E+XG4gICAgICAgIDwvZGl2PiAgICAgXG4gICAgICAgIFxuICAgICAgICA8c2NyaXB0PlxuICAgICAgICAkKCcjdXNlcicpLmVkaXRhYmxlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnYScsXG4gICAgICAgICAgICB1cmw6ICcvcG9zdCcsXG4gICAgICAgICAgICBwazogMVxuICAgICAgICB9KTtcbiAgICAgICAgPC9zY3JpcHQ+XG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBzZWxlY3RvcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIENvbG9yIHVzZWQgdG8gaGlnaGxpZ2h0IGVsZW1lbnQgYWZ0ZXIgdXBkYXRlLiBJbXBsZW1lbnRlZCB2aWEgQ1NTMyB0cmFuc2l0aW9uLCB3b3JrcyBpbiBtb2Rlcm4gYnJvd3NlcnMuXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgaGlnaGxpZ2h0IFxuICAgICAgICBAdHlwZSBzdHJpbmd8Ym9vbGVhblxuICAgICAgICBAc2luY2UgMS40LjUgICAgICAgIFxuICAgICAgICBAZGVmYXVsdCAjRkZGRjgwIFxuICAgICAgICAqKi9cbiAgICAgICAgaGlnaGxpZ2h0OiAnI0ZGRkY4MCdcbiAgICB9O1xuICAgIFxufSh3aW5kb3cualF1ZXJ5KSk7XG5cbi8qKlxuQWJzdHJhY3RJbnB1dCAtIGJhc2UgY2xhc3MgZm9yIGFsbCBlZGl0YWJsZSBpbnB1dHMuXG5JdCBkZWZpbmVzIGludGVyZmFjZSB0byBiZSBpbXBsZW1lbnRlZCBieSBhbnkgaW5wdXQgdHlwZS5cblRvIGNyZWF0ZSB5b3VyIG93biBpbnB1dCB5b3UgY2FuIGluaGVyaXQgZnJvbSB0aGlzIGNsYXNzLlxuXG5AY2xhc3MgYWJzdHJhY3RpbnB1dFxuKiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vdHlwZXNcbiAgICAkLmZuLmVkaXRhYmxldHlwZXMgPSB7fTtcblxuICAgIHZhciBBYnN0cmFjdElucHV0ID0gZnVuY3Rpb24gKCkgeyB9O1xuXG4gICAgQWJzdHJhY3RJbnB1dC5wcm90b3R5cGUgPSB7XG4gICAgICAgLyoqXG4gICAgICAgIEluaXRpYWxpemVzIGlucHV0XG5cbiAgICAgICAgQG1ldGhvZCBpbml0KCkgXG4gICAgICAgICoqL1xuICAgICAgIGluaXQ6IGZ1bmN0aW9uKHR5cGUsIG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAgfSxcblxuICAgICAgIC8qXG4gICAgICAgdGhpcyBtZXRob2QgY2FsbGVkIGJlZm9yZSByZW5kZXIgdG8gaW5pdCAkdHBsIHRoYXQgaXMgaW5zZXJ0ZWQgaW4gRE9NXG4gICAgICAgKi9cbiAgICAgICBwcmVyZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICB0aGlzLiR0cGwgPSAkKHRoaXMub3B0aW9ucy50cGwpOyAvL3dob2xlIHRwbCBhcyBqcXVlcnkgb2JqZWN0ICAgIFxuICAgICAgICAgICB0aGlzLiRpbnB1dCA9IHRoaXMuJHRwbDsgICAgICAgICAvL2NvbnRyb2wgaXRzZWxmLCBjYW4gYmUgY2hhbmdlZCBpbiByZW5kZXIgbWV0aG9kXG4gICAgICAgICAgIHRoaXMuJGNsZWFyID0gbnVsbDsgICAgICAgICAgICAgIC8vY2xlYXIgYnV0dG9uXG4gICAgICAgICAgIHRoaXMuZXJyb3IgPSBudWxsOyAgICAgICAgICAgICAgIC8vZXJyb3IgbWVzc2FnZSwgaWYgaW5wdXQgY2Fubm90IGJlIHJlbmRlcmVkICAgICAgICAgICBcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qKlxuICAgICAgICBSZW5kZXJzIGlucHV0IGZyb20gdHBsLiBDYW4gcmV0dXJuIGpRdWVyeSBkZWZlcnJlZCBvYmplY3QuXG4gICAgICAgIENhbiBiZSBvdmVyd3JpdHRlbiBpbiBjaGlsZCBvYmplY3RzXG5cbiAgICAgICAgQG1ldGhvZCByZW5kZXIoKVxuICAgICAgICoqL1xuICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICB9LCBcblxuICAgICAgIC8qKlxuICAgICAgICBTZXRzIGVsZW1lbnQncyBodG1sIGJ5IHZhbHVlLiBcblxuICAgICAgICBAbWV0aG9kIHZhbHVlMmh0bWwodmFsdWUsIGVsZW1lbnQpXG4gICAgICAgIEBwYXJhbSB7bWl4ZWR9IHZhbHVlXG4gICAgICAgIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudFxuICAgICAgICoqL1xuICAgICAgIHZhbHVlMmh0bWw6IGZ1bmN0aW9uKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgICAgICAgICQoZWxlbWVudClbdGhpcy5vcHRpb25zLmVzY2FwZSA/ICd0ZXh0JyA6ICdodG1sJ10oJC50cmltKHZhbHVlKSk7XG4gICAgICAgfSxcblxuICAgICAgIC8qKlxuICAgICAgICBDb252ZXJ0cyBlbGVtZW50J3MgaHRtbCB0byB2YWx1ZVxuXG4gICAgICAgIEBtZXRob2QgaHRtbDJ2YWx1ZShodG1sKVxuICAgICAgICBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICAgICAgICBAcmV0dXJucyB7bWl4ZWR9XG4gICAgICAgKiovXG4gICAgICAgaHRtbDJ2YWx1ZTogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICByZXR1cm4gJCgnPGRpdj4nKS5odG1sKGh0bWwpLnRleHQoKTtcbiAgICAgICB9LFxuXG4gICAgICAgLyoqXG4gICAgICAgIENvbnZlcnRzIHZhbHVlIHRvIHN0cmluZyAoZm9yIGludGVybmFsIGNvbXBhcmUpLiBGb3Igc3VibWl0dGluZyB0byBzZXJ2ZXIgdXNlZCB2YWx1ZTJzdWJtaXQoKS5cblxuICAgICAgICBAbWV0aG9kIHZhbHVlMnN0cih2YWx1ZSkgXG4gICAgICAgIEBwYXJhbSB7bWl4ZWR9IHZhbHVlXG4gICAgICAgIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgKiovXG4gICAgICAgdmFsdWUyc3RyOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgfSwgXG5cbiAgICAgICAvKipcbiAgICAgICAgQ29udmVydHMgc3RyaW5nIHJlY2VpdmVkIGZyb20gc2VydmVyIGludG8gdmFsdWUuIFVzdWFsbHkgZnJvbSBgZGF0YS12YWx1ZWAgYXR0cmlidXRlLlxuXG4gICAgICAgIEBtZXRob2Qgc3RyMnZhbHVlKHN0cilcbiAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAgICBAcmV0dXJucyB7bWl4ZWR9XG4gICAgICAgKiovXG4gICAgICAgc3RyMnZhbHVlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICB9LCBcbiAgICAgICBcbiAgICAgICAvKipcbiAgICAgICAgQ29udmVydHMgdmFsdWUgZm9yIHN1Ym1pdHRpbmcgdG8gc2VydmVyLiBSZXN1bHQgY2FuIGJlIHN0cmluZyBvciBvYmplY3QuXG5cbiAgICAgICAgQG1ldGhvZCB2YWx1ZTJzdWJtaXQodmFsdWUpIFxuICAgICAgICBAcGFyYW0ge21peGVkfSB2YWx1ZVxuICAgICAgICBAcmV0dXJucyB7bWl4ZWR9XG4gICAgICAgKiovXG4gICAgICAgdmFsdWUyc3VibWl0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgfSxcblxuICAgICAgIC8qKlxuICAgICAgICBTZXRzIHZhbHVlIG9mIGlucHV0LlxuXG4gICAgICAgIEBtZXRob2QgdmFsdWUyaW5wdXQodmFsdWUpIFxuICAgICAgICBAcGFyYW0ge21peGVkfSB2YWx1ZVxuICAgICAgICoqL1xuICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICB0aGlzLiRpbnB1dC52YWwodmFsdWUpO1xuICAgICAgIH0sXG5cbiAgICAgICAvKipcbiAgICAgICAgUmV0dXJucyB2YWx1ZSBvZiBpbnB1dC4gVmFsdWUgY2FuIGJlIG9iamVjdCAoZS5nLiBkYXRlcGlja2VyKVxuXG4gICAgICAgIEBtZXRob2QgaW5wdXQydmFsdWUoKSBcbiAgICAgICAqKi9cbiAgICAgICBpbnB1dDJ2YWx1ZTogZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICByZXR1cm4gdGhpcy4kaW5wdXQudmFsKCk7XG4gICAgICAgfSwgXG5cbiAgICAgICAvKipcbiAgICAgICAgQWN0aXZhdGVzIGlucHV0LiBGb3IgdGV4dCBpdCBzZXRzIGZvY3VzLlxuXG4gICAgICAgIEBtZXRob2QgYWN0aXZhdGUoKSBcbiAgICAgICAqKi9cbiAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIGlmKHRoaXMuJGlucHV0LmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5mb2N1cygpO1xuICAgICAgICAgICB9XG4gICAgICAgfSxcblxuICAgICAgIC8qKlxuICAgICAgICBDcmVhdGVzIGlucHV0LlxuXG4gICAgICAgIEBtZXRob2QgY2xlYXIoKSBcbiAgICAgICAqKi8gICAgICAgIFxuICAgICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgdGhpcy4kaW5wdXQudmFsKG51bGwpO1xuICAgICAgIH0sXG5cbiAgICAgICAvKipcbiAgICAgICAgbWV0aG9kIHRvIGVzY2FwZSBodG1sLlxuICAgICAgICoqL1xuICAgICAgIGVzY2FwZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgIHJldHVybiAkKCc8ZGl2PicpLnRleHQoc3RyKS5odG1sKCk7XG4gICAgICAgfSxcbiAgICAgICBcbiAgICAgICAvKipcbiAgICAgICAgYXR0YWNoIGhhbmRsZXIgdG8gYXV0b21hdGljYWxseSBzdWJtaXQgZm9ybSB3aGVuIHZhbHVlIGNoYW5nZWQgKHVzZWZ1bCB3aGVuIGJ1dHRvbnMgbm90IHNob3duKVxuICAgICAgICoqL1xuICAgICAgIGF1dG9zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qKlxuICAgICAgIEFkZGl0aW9uYWwgYWN0aW9ucyB3aGVuIGRlc3Ryb3lpbmcgZWxlbWVudCBcbiAgICAgICAqKi9cbiAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICB9LFxuXG4gICAgICAgLy8gLS0tLS0tLS0gaGVscGVyIGZ1bmN0aW9ucyAtLS0tLS0tLVxuICAgICAgIHNldENsYXNzOiBmdW5jdGlvbigpIHsgICAgICAgICAgXG4gICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5pbnB1dGNsYXNzKSB7XG4gICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuaW5wdXRjbGFzcyk7IFxuICAgICAgICAgICB9IFxuICAgICAgIH0sXG5cbiAgICAgICBzZXRBdHRyOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNbYXR0cl0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnNbYXR0cl0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgIHRoaXMuJGlucHV0LmF0dHIoYXR0ciwgdGhpcy5vcHRpb25zW2F0dHJdKTtcbiAgICAgICAgICAgfSBcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIG9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICB9XG4gICAgICAgXG4gICAgfTtcbiAgICAgICAgXG4gICAgQWJzdHJhY3RJbnB1dC5kZWZhdWx0cyA9IHsgIFxuICAgICAgICAvKipcbiAgICAgICAgSFRNTCB0ZW1wbGF0ZSBvZiBpbnB1dC4gTm9ybWFsbHkgeW91IHNob3VsZCBub3QgY2hhbmdlIGl0LlxuXG4gICAgICAgIEBwcm9wZXJ0eSB0cGwgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAnJ1xuICAgICAgICAqKi8gICBcbiAgICAgICAgdHBsOiAnJyxcbiAgICAgICAgLyoqXG4gICAgICAgIENTUyBjbGFzcyBhdXRvbWF0aWNhbGx5IGFwcGxpZWQgdG8gaW5wdXRcbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBpbnB1dGNsYXNzIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgaW5wdXRjbGFzczogbnVsbCxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBJZiBgdHJ1ZWAgLSBodG1sIHdpbGwgYmUgZXNjYXBlZCBpbiBjb250ZW50IG9mIGVsZW1lbnQgdmlhICQudGV4dCgpIG1ldGhvZC4gIFxuICAgICAgICBJZiBgZmFsc2VgIC0gaHRtbCB3aWxsIG5vdCBiZSBlc2NhcGVkLCAkLmh0bWwoKSB1c2VkLiAgXG4gICAgICAgIFdoZW4geW91IHVzZSBvd24gYGRpc3BsYXlgIGZ1bmN0aW9uLCB0aGlzIG9wdGlvbiBvYnZpb3NseSBoYXMgbm8gZWZmZWN0LlxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IGVzY2FwZSBcbiAgICAgICAgQHR5cGUgYm9vbGVhblxuICAgICAgICBAc2luY2UgMS41LjBcbiAgICAgICAgQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgZXNjYXBlOiB0cnVlLFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAvL3Njb3BlIGZvciBleHRlcm5hbCBtZXRob2RzIChlLmcuIHNvdXJjZSBkZWZpbmVkIGFzIGZ1bmN0aW9uKVxuICAgICAgICAvL2ZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAgICAgICBzY29wZTogbnVsbCxcbiAgICAgICAgXG4gICAgICAgIC8vbmVlZCB0byByZS1kZWNsYXJlIHNob3didXR0b25zIGhlcmUgdG8gZ2V0IGl0J3MgdmFsdWUgZnJvbSBjb21tb24gY29uZmlnIChwYXNzZWQgb25seSBvcHRpb25zIGV4aXN0aW5nIGluIGRlZmF1bHRzKVxuICAgICAgICBzaG93YnV0dG9uczogdHJ1ZSBcbiAgICB9O1xuICAgIFxuICAgICQuZXh0ZW5kKCQuZm4uZWRpdGFibGV0eXBlcywge2Fic3RyYWN0aW5wdXQ6IEFic3RyYWN0SW5wdXR9KTtcbiAgICAgICAgXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG5MaXN0IC0gYWJzdHJhY3QgY2xhc3MgZm9yIGlucHV0cyB0aGF0IGhhdmUgc291cmNlIG9wdGlvbiBsb2FkZWQgZnJvbSBqcyBhcnJheSBvciB2aWEgYWpheFxuXG5AY2xhc3MgbGlzdFxuQGV4dGVuZHMgYWJzdHJhY3RpbnB1dFxuKiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBcbiAgICB2YXIgTGlzdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgXG4gICAgfTtcblxuICAgICQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KExpc3QsICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0KTtcblxuICAgICQuZXh0ZW5kKExpc3QucHJvdG90eXBlLCB7XG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpO1xuXG4gICAgICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMub25Tb3VyY2VSZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMaXN0KCk7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB0aGlzLm9wdGlvbnMuc291cmNlRXJyb3I7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaHRtbDJ2YWx1ZTogZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvL2Nhbid0IHNldCB2YWx1ZSBieSB0ZXh0XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICB2YWx1ZTJodG1sOiBmdW5jdGlvbiAodmFsdWUsIGVsZW1lbnQsIGRpc3BsYXksIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCksXG4gICAgICAgICAgICAgICAgc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGRpc3BsYXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY3VzdG9tIGRpc3BsYXkgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LmNhbGwoZWxlbWVudCwgdmFsdWUsIHRoaXMuc291cmNlRGF0YSwgcmVzcG9uc2UpOyBcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUyaHRtbEZpbmFsKHZhbHVlLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2ZvciBudWxsIHZhbHVlIGp1c3QgY2FsbCBzdWNjZXNzIHdpdGhvdXQgbG9hZGluZyBzb3VyY2VcbiAgICAgICAgICAgIGlmKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICBzdWNjZXNzLmNhbGwodGhpcyk7ICAgXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgdGhpcy5vblNvdXJjZVJlYWR5KHN1Y2Nlc3MsIGZ1bmN0aW9uICgpIHsgZGVmZXJyZWQucmVzb2x2ZSgpOyB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcbiAgICAgICAgfSwgIFxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0gYWRkaXRpb25hbCBmdW5jdGlvbnMgLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgb25Tb3VyY2VSZWFkeTogZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgICAvL3J1biBzb3VyY2UgaWYgaXQgZnVuY3Rpb25cbiAgICAgICAgICAgIHZhciBzb3VyY2U7XG4gICAgICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5zb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgc291cmNlID0gdGhpcy5vcHRpb25zLnNvdXJjZS5jYWxsKHRoaXMub3B0aW9ucy5zY29wZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvL25vdGU6IGlmIGZ1bmN0aW9uIHJldHVybnMgdGhlIHNhbWUgc291cmNlIGFzIFVSTCAtIHNvdXJjZURhdGEgd2lsbCBiZSB0YWtlbiBmcm9tIGNhaGNlIGFuZCBubyBleHRyYSByZXF1ZXN0IHBlcmZvcm1lZFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSB0aGlzLm9wdGlvbnMuc291cmNlO1xuICAgICAgICAgICAgfSAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2lmIGFsbHJlYWR5IGxvYWRlZCBqdXN0IGNhbGwgc3VjY2Vzc1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnNvdXJjZUNhY2hlICYmICQuaXNBcnJheSh0aGlzLnNvdXJjZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgc3VjY2Vzcy5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybjsgXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vdHJ5IHBhcnNlIGpzb24gaW4gc2luZ2xlIHF1b3RlcyAoZm9yIGRvdWJsZSBxdW90ZXMganF1ZXJ5IGRvZXMgYXV0b21hdGljYWxseSlcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc291cmNlID0gJC5mbi5lZGl0YWJsZXV0aWxzLnRyeVBhcnNlSnNvbihzb3VyY2UsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9sb2FkaW5nIGZyb20gdXJsXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL3RyeSB0byBnZXQgc291cmNlRGF0YSBmcm9tIGNhY2hlXG4gICAgICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnNvdXJjZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWNoZUlEID0gc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBjYWNoZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoISQoZG9jdW1lbnQpLmRhdGEoY2FjaGVJRCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLmRhdGEoY2FjaGVJRCwge30pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlID0gJChkb2N1bWVudCkuZGF0YShjYWNoZUlEKTtcblxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGZvciBjYWNoZWQgZGF0YVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGUubG9hZGluZyA9PT0gZmFsc2UgJiYgY2FjaGUuc291cmNlRGF0YSkgeyAvL3Rha2Ugc291cmNlIGZyb20gY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc291cmNlRGF0YSA9IGNhY2hlLnNvdXJjZURhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvUHJlcGVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzcy5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNhY2hlLmxvYWRpbmcgPT09IHRydWUpIHsgLy9jYWNoZSBpcyBsb2FkaW5nLCBwdXQgY2FsbGJhY2sgaW4gc3RhY2sgdG8gYmUgY2FsbGVkIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5jYWxsYmFja3MucHVzaCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZURhdGEgPSBjYWNoZS5zb3VyY2VEYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9QcmVwZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzcy5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2Fsc28gY29sbGVjdGluZyBlcnJvciBjYWxsYmFja3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLmVycl9jYWxsYmFja3MucHVzaCgkLnByb3h5KGVycm9yLCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vbm8gY2FjaGUgeWV0LCBhY3RpdmF0ZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5jYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLmVycl9jYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL2FqYXhPcHRpb25zIGZvciBzb3VyY2UuIENhbiBiZSBvdmVyd3JpdHRlbiBidCBvcHRpb25zLnNvdXJjZU9wdGlvbnNcbiAgICAgICAgICAgICAgICB2YXIgYWpheE9wdGlvbnMgPSAkLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgIHVybDogc291cmNlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZ2V0JyxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiAkLnByb3h5KGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc291cmNlRGF0YSA9IHRoaXMubWFrZUFycmF5KGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoJC5pc0FycmF5KHRoaXMuc291cmNlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3N0b3JlIHJlc3VsdCBpbiBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zb3VyY2VEYXRhID0gdGhpcy5zb3VyY2VEYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3J1biBzdWNjZXNzIGNhbGxiYWNrcyBmb3Igb3RoZXIgZmllbGRzIHdhaXRpbmcgZm9yIHRoaXMgc291cmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChjYWNoZS5jYWxsYmFja3MsIGZ1bmN0aW9uICgpIHsgdGhpcy5jYWxsKCk7IH0pOyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1ByZXBlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ydW4gZXJyb3IgY2FsbGJhY2tzIGZvciBvdGhlciBmaWVsZHMgd2FpdGluZyBmb3IgdGhpcyBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKGNhY2hlLmVycl9jYWxsYmFja3MsIGZ1bmN0aW9uICgpIHsgdGhpcy5jYWxsKCk7IH0pOyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogJC5wcm94eShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3J1biBlcnJvciBjYWxsYmFja3MgZm9yIG90aGVyIGZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goY2FjaGUuZXJyX2NhbGxiYWNrcywgZnVuY3Rpb24gKCkgeyB0aGlzLmNhbGwoKTsgfSk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKVxuICAgICAgICAgICAgICAgIH0sIHRoaXMub3B0aW9ucy5zb3VyY2VPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL2xvYWRpbmcgc291cmNlRGF0YSBmcm9tIHNlcnZlclxuICAgICAgICAgICAgICAgICQuYWpheChhamF4T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9IGVsc2UgeyAvL29wdGlvbnMgYXMganNvbi9hcnJheVxuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlRGF0YSA9IHRoaXMubWFrZUFycmF5KHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKCQuaXNBcnJheSh0aGlzLnNvdXJjZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9QcmVwZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MuY2FsbCh0aGlzKTsgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkb1ByZXBlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5wcmVwZW5kID09PSBudWxsIHx8IHRoaXMub3B0aW9ucy5wcmVwZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47ICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoISQuaXNBcnJheSh0aGlzLnByZXBlbmREYXRhKSkge1xuICAgICAgICAgICAgICAgIC8vcnVuIHByZXBlbmQgaWYgaXQgaXMgZnVuY3Rpb24gKG9uY2UpXG4gICAgICAgICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMucHJlcGVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnByZXBlbmQgPSB0aGlzLm9wdGlvbnMucHJlcGVuZC5jYWxsKHRoaXMub3B0aW9ucy5zY29wZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL3RyeSBwYXJzZSBqc29uIGluIHNpbmdsZSBxdW90ZXNcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucHJlcGVuZCA9ICQuZm4uZWRpdGFibGV1dGlscy50cnlQYXJzZUpzb24odGhpcy5vcHRpb25zLnByZXBlbmQsIHRydWUpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vY29udmVydCBwcmVwZW5kIGZyb20gc3RyaW5nIHRvIG9iamVjdFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnByZXBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wcmVwZW5kID0geycnOiB0aGlzLm9wdGlvbnMucHJlcGVuZH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMucHJlcGVuZERhdGEgPSB0aGlzLm1ha2VBcnJheSh0aGlzLm9wdGlvbnMucHJlcGVuZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCQuaXNBcnJheSh0aGlzLnByZXBlbmREYXRhKSAmJiAkLmlzQXJyYXkodGhpcy5zb3VyY2VEYXRhKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlRGF0YSA9IHRoaXMucHJlcGVuZERhdGEuY29uY2F0KHRoaXMuc291cmNlRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgIHJlbmRlcnMgaW5wdXQgbGlzdFxuICAgICAgICAqL1xuICAgICAgICByZW5kZXJMaXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVyd3JpdHRlbiBpbiBjaGlsZCBjbGFzc1xuICAgICAgICB9LFxuICAgICAgIFxuICAgICAgICAgLypcbiAgICAgICAgIHNldCBlbGVtZW50J3MgaHRtbCBieSB2YWx1ZVxuICAgICAgICAqL1xuICAgICAgICB2YWx1ZTJodG1sRmluYWw6IGZ1bmN0aW9uKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAvLyB0aGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcndyaXR0ZW4gaW4gY2hpbGQgY2xhc3NcbiAgICAgICAgfSwgICAgICAgIFxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIGNvbnZlcnQgZGF0YSB0byBhcnJheSBzdWl0YWJsZSBmb3Igc291cmNlRGF0YSwgZS5nLiBbe3ZhbHVlOiAxLCB0ZXh0OiAnYWJjJ30sIHsuLi59XVxuICAgICAgICAqL1xuICAgICAgICBtYWtlQXJyYXk6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjb3VudCwgb2JqLCByZXN1bHQgPSBbXSwgaXRlbSwgaXRlcmF0ZUl0ZW07XG4gICAgICAgICAgICBpZighZGF0YSB8fCB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCQuaXNBcnJheShkYXRhKSkgeyAvL2FycmF5XG4gICAgICAgICAgICAgICAgLyogXG4gICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdG8gaXRlcmF0ZSBpbnNpZGUgaXRlbSBvZiBhcnJheSBpZiBpdGVtIGlzIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICBDYWNsdWxhdGVzIGNvdW50IG9mIGtleXMgaW4gaXRlbSBhbmQgc3RvcmUgaW4gb2JqLiBcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGl0ZXJhdGVJdGVtID0gZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0ge3ZhbHVlOiBrLCB0ZXh0OiB2fTtcbiAgICAgICAgICAgICAgICAgICAgaWYoY291bnQrKyA+PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7Ly8gZXhpdCBmcm9tIGBlYWNoYCBpZiBpdGVtIGhhcyBtb3JlIHRoYW4gb25lIGtleS5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtID0gZGF0YVtpXTsgXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgPSAwOyAvL2NvdW50IG9mIGtleXMgaW5zaWRlIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChpdGVtLCBpdGVyYXRlSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2Nhc2U6IFt7dmFsMTogJ3RleHQxJ30sIHt2YWwyOiAndGV4dDJ9IC4uLl1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNvdW50ID09PSAxKSB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9iaik7IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2FzZTogW3t2YWx1ZTogMSwgdGV4dDogJ3RleHQxJ30sIHt2YWx1ZTogMiwgdGV4dDogJ3RleHQyJ30sIC4uLl1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihjb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZWQgY2hlY2sgb2YgZXhpc3RhbmNlOiBpdGVtLmhhc093blByb3BlcnR5KCd2YWx1ZScpICYmIGl0ZW0uaGFzT3duUHJvcGVydHkoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jaGlsZHJlbiA9IHRoaXMubWFrZUFycmF5KGl0ZW0uY2hpbGRyZW4pOyAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2FzZTogWyd0ZXh0MScsICd0ZXh0MicgLi4uXVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe3ZhbHVlOiBpdGVtLCB0ZXh0OiBpdGVtfSk7IFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHsgIC8vY2FzZToge3ZhbDE6ICd0ZXh0MScsIHZhbDI6ICd0ZXh0MiwgLi4ufVxuICAgICAgICAgICAgICAgICQuZWFjaChkYXRhLCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7dmFsdWU6IGssIHRleHQ6IHZ9KTtcbiAgICAgICAgICAgICAgICB9KTsgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIG9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmKGtleSA9PT0gJ3NvdXJjZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZURhdGEgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoa2V5ID09PSAncHJlcGVuZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXBlbmREYXRhID0gbnVsbDtcbiAgICAgICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgfSAgICAgICAgXG5cbiAgICB9KTsgICAgICBcblxuICAgIExpc3QuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQuZGVmYXVsdHMsIHtcbiAgICAgICAgLyoqXG4gICAgICAgIFNvdXJjZSBkYXRhIGZvciBsaXN0LiAgXG4gICAgICAgIElmICoqYXJyYXkqKiAtIGl0IHNob3VsZCBiZSBpbiBmb3JtYXQ6IGBbe3ZhbHVlOiAxLCB0ZXh0OiBcInRleHQxXCJ9LCB7dmFsdWU6IDIsIHRleHQ6IFwidGV4dDJcIn0sIC4uLl1gICBcbiAgICAgICAgRm9yIGNvbXBhYmlsaXR5LCBvYmplY3QgZm9ybWF0IGlzIGFsc28gc3VwcG9ydGVkOiBge1wiMVwiOiBcInRleHQxXCIsIFwiMlwiOiBcInRleHQyXCIgLi4ufWAgYnV0IGl0IGRvZXMgbm90IGd1YXJhbnRlZSBlbGVtZW50cyBvcmRlci5cbiAgICAgICAgXG4gICAgICAgIElmICoqc3RyaW5nKiogLSBjb25zaWRlcmVkIGFqYXggdXJsIHRvIGxvYWQgaXRlbXMuIEluIHRoYXQgY2FzZSByZXN1bHRzIHdpbGwgYmUgY2FjaGVkIGZvciBmaWVsZHMgd2l0aCB0aGUgc2FtZSBzb3VyY2UgYW5kIG5hbWUuIFNlZSBhbHNvIGBzb3VyY2VDYWNoZWAgb3B0aW9uLlxuICAgICAgICAgIFxuICAgICAgICBJZiAqKmZ1bmN0aW9uKiosIGl0IHNob3VsZCByZXR1cm4gZGF0YSBpbiBmb3JtYXQgYWJvdmUgKHNpbmNlIDEuNC4wKS5cbiAgICAgICAgXG4gICAgICAgIFNpbmNlIDEuNC4xIGtleSBgY2hpbGRyZW5gIHN1cHBvcnRlZCB0byByZW5kZXIgT1BUR1JPVVAgKGZvciAqKnNlbGVjdCoqIGlucHV0IG9ubHkpLiAgXG4gICAgICAgIGBbe3RleHQ6IFwiZ3JvdXAxXCIsIGNoaWxkcmVuOiBbe3ZhbHVlOiAxLCB0ZXh0OiBcInRleHQxXCJ9LCB7dmFsdWU6IDIsIHRleHQ6IFwidGV4dDJcIn1dfSwgLi4uXWAgXG5cblx0XHRcbiAgICAgICAgQHByb3BlcnR5IHNvdXJjZSBcbiAgICAgICAgQHR5cGUgc3RyaW5nIHwgYXJyYXkgfCBvYmplY3QgfCBmdW5jdGlvblxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBzb3VyY2U6IG51bGwsIFxuICAgICAgICAvKipcbiAgICAgICAgRGF0YSBhdXRvbWF0aWNhbGx5IHByZXBlbmRlZCB0byB0aGUgYmVnaW5uaW5nIG9mIGRyb3Bkb3duIGxpc3QuXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgcHJlcGVuZCBcbiAgICAgICAgQHR5cGUgc3RyaW5nIHwgYXJyYXkgfCBvYmplY3QgfCBmdW5jdGlvblxuICAgICAgICBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgcHJlcGVuZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICBFcnJvciBtZXNzYWdlIHdoZW4gbGlzdCBjYW5ub3QgYmUgbG9hZGVkIChlLmcuIGFqYXggZXJyb3IpXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgc291cmNlRXJyb3IgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCBFcnJvciB3aGVuIGxvYWRpbmcgbGlzdFxuICAgICAgICAqKi8gICAgICAgICAgXG4gICAgICAgIHNvdXJjZUVycm9yOiAnRXJyb3Igd2hlbiBsb2FkaW5nIGxpc3QnLFxuICAgICAgICAvKipcbiAgICAgICAgaWYgPGNvZGU+dHJ1ZTwvY29kZT4gYW5kIHNvdXJjZSBpcyAqKnN0cmluZyB1cmwqKiAtIHJlc3VsdHMgd2lsbCBiZSBjYWNoZWQgZm9yIGZpZWxkcyB3aXRoIHRoZSBzYW1lIHNvdXJjZS4gICAgXG4gICAgICAgIFVzZWZ1bGwgZm9yIGVkaXRhYmxlIGNvbHVtbiBpbiBncmlkIHRvIHByZXZlbnQgZXh0cmEgcmVxdWVzdHMuXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgc291cmNlQ2FjaGUgXG4gICAgICAgIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgQGRlZmF1bHQgdHJ1ZVxuICAgICAgICBAc2luY2UgMS4yLjBcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgc291cmNlQ2FjaGU6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICBBZGRpdGlvbmFsIGFqYXggb3B0aW9ucyB0byBiZSB1c2VkIGluICQuYWpheCgpIHdoZW4gbG9hZGluZyBsaXN0IGZyb20gc2VydmVyLlxuICAgICAgICBVc2VmdWwgdG8gc2VuZCBleHRyYSBwYXJhbWV0ZXJzIChgZGF0YWAga2V5KSBvciBjaGFuZ2UgcmVxdWVzdCBtZXRob2QgKGB0eXBlYCBrZXkpLlxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IHNvdXJjZU9wdGlvbnMgXG4gICAgICAgIEB0eXBlIG9iamVjdHxmdW5jdGlvblxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBzaW5jZSAxLjUuMFxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBzb3VyY2VPcHRpb25zOiBudWxsXG4gICAgfSk7XG5cbiAgICAkLmZuLmVkaXRhYmxldHlwZXMubGlzdCA9IExpc3Q7ICAgICAgXG5cbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKipcblRleHQgaW5wdXRcblxuQGNsYXNzIHRleHRcbkBleHRlbmRzIGFic3RyYWN0aW5wdXRcbkBmaW5hbFxuQGV4YW1wbGVcbjxhIGhyZWY9XCIjXCIgaWQ9XCJ1c2VybmFtZVwiIGRhdGEtdHlwZT1cInRleHRcIiBkYXRhLXBrPVwiMVwiPmF3ZXNvbWU8L2E+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgICQoJyN1c2VybmFtZScpLmVkaXRhYmxlKHtcbiAgICAgICAgdXJsOiAnL3Bvc3QnLFxuICAgICAgICB0aXRsZTogJ0VudGVyIHVzZXJuYW1lJ1xuICAgIH0pO1xufSk7XG48L3NjcmlwdD5cbioqL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgXG4gICAgdmFyIFRleHQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ3RleHQnLCBvcHRpb25zLCBUZXh0LmRlZmF1bHRzKTtcbiAgICB9O1xuXG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoVGV4dCwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQpO1xuXG4gICAgJC5leHRlbmQoVGV4dC5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgdGhpcy5yZW5kZXJDbGVhcigpO1xuICAgICAgICAgICB0aGlzLnNldENsYXNzKCk7XG4gICAgICAgICAgIHRoaXMuc2V0QXR0cigncGxhY2Vob2xkZXInKTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuJGlucHV0LmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAkLmZuLmVkaXRhYmxldXRpbHMuc2V0Q3Vyc29yUG9zaXRpb24odGhpcy4kaW5wdXQuZ2V0KDApLCB0aGlzLiRpbnB1dC52YWwoKS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmKHRoaXMudG9nZ2xlQ2xlYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2dnbGVDbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8vcmVuZGVyIGNsZWFyIGJ1dHRvblxuICAgICAgICByZW5kZXJDbGVhcjogIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNsZWFyKSB7XG4gICAgICAgICAgICAgICB0aGlzLiRjbGVhciA9ICQoJzxzcGFuIGNsYXNzPVwiZWRpdGFibGUtY2xlYXIteFwiPjwvc3Bhbj4nKTtcbiAgICAgICAgICAgICAgIHRoaXMuJGlucHV0LmFmdGVyKHRoaXMuJGNsZWFyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuY3NzKCdwYWRkaW5nLXJpZ2h0JywgMjQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5rZXl1cCgkLnByb3h5KGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYXJyb3dzLCBlbnRlciwgdGFiLCBldGNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKH4kLmluQXJyYXkoZS5rZXlDb2RlLCBbNDAsMzgsOSwxMywyN10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC50b2dnbGVDbGVhcihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5wYXJlbnQoKS5jc3MoJ3Bvc2l0aW9uJywgJ3JlbGF0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgdGhpcy4kY2xlYXIuY2xpY2soJC5wcm94eSh0aGlzLmNsZWFyLCB0aGlzKSk7ICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgfSAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgcG9zdHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgLy9ub3cgYGNsZWFyYCBpcyBwb3NpdGlvbmVkIHZpYSBjc3NcbiAgICAgICAgICAgIGlmKHRoaXMuJGNsZWFyKSB7XG4gICAgICAgICAgICAgICAgLy9jYW4gcG9zaXRpb24gY2xlYXIgYnV0dG9uIG9ubHkgaGVyZSwgd2hlbiBmb3JtIGlzIHNob3duIGFuZCBoZWlnaHQgY2FuIGJlIGNhbGN1bGF0ZWRcbi8vICAgICAgICAgICAgICAgIHZhciBoID0gdGhpcy4kaW5wdXQub3V0ZXJIZWlnaHQodHJ1ZSkgfHwgMjAsXG4gICAgICAgICAgICAgICAgdmFyIGggPSB0aGlzLiRjbGVhci5wYXJlbnQoKS5oZWlnaHQoKSxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSAoaCAtIHRoaXMuJGNsZWFyLmhlaWdodCgpKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vdGhpcy4kY2xlYXIuY3NzKHtib3R0b206IGRlbHRhLCByaWdodDogZGVsdGF9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICovIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLy9zaG93IC8gaGlkZSBjbGVhciBidXR0b25cbiAgICAgICAgdG9nZ2xlQ2xlYXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmKCF0aGlzLiRjbGVhcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMuJGlucHV0LnZhbCgpLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB2aXNpYmxlID0gdGhpcy4kY2xlYXIuaXMoJzp2aXNpYmxlJyk7XG4gICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYobGVuICYmICF2aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2xlYXIuc2hvdygpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIWxlbiAmJiB2aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2xlYXIuaGlkZSgpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgdGhpcy4kY2xlYXIuaGlkZSgpO1xuICAgICAgICAgICB0aGlzLiRpbnB1dC52YWwoJycpLmZvY3VzKCk7XG4gICAgICAgIH0gICAgICAgICAgXG4gICAgfSk7XG5cbiAgICBUZXh0LmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0LmRlZmF1bHRzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgdHBsIFxuICAgICAgICBAZGVmYXVsdCA8aW5wdXQgdHlwZT1cInRleHRcIj5cbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHRwbDogJzxpbnB1dCB0eXBlPVwidGV4dFwiPicsXG4gICAgICAgIC8qKlxuICAgICAgICBQbGFjZWhvbGRlciBhdHRyaWJ1dGUgb2YgaW5wdXQuIFNob3duIHdoZW4gaW5wdXQgaXMgZW1wdHkuXG5cbiAgICAgICAgQHByb3BlcnR5IHBsYWNlaG9sZGVyIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi8gICAgICAgICAgICAgXG4gICAgICAgIHBsYWNlaG9sZGVyOiBudWxsLFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIFdoZXRoZXIgdG8gc2hvdyBgY2xlYXJgIGJ1dHRvbiBcbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBjbGVhciBcbiAgICAgICAgQHR5cGUgYm9vbGVhblxuICAgICAgICBAZGVmYXVsdCB0cnVlICAgICAgICBcbiAgICAgICAgKiovXG4gICAgICAgIGNsZWFyOiB0cnVlXG4gICAgfSk7XG5cbiAgICAkLmZuLmVkaXRhYmxldHlwZXMudGV4dCA9IFRleHQ7XG5cbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKipcblRleHRhcmVhIGlucHV0XG5cbkBjbGFzcyB0ZXh0YXJlYVxuQGV4dGVuZHMgYWJzdHJhY3RpbnB1dFxuQGZpbmFsXG5AZXhhbXBsZVxuPGEgaHJlZj1cIiNcIiBpZD1cImNvbW1lbnRzXCIgZGF0YS10eXBlPVwidGV4dGFyZWFcIiBkYXRhLXBrPVwiMVwiPmF3ZXNvbWUgY29tbWVudCE8L2E+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgICQoJyNjb21tZW50cycpLmVkaXRhYmxlKHtcbiAgICAgICAgdXJsOiAnL3Bvc3QnLFxuICAgICAgICB0aXRsZTogJ0VudGVyIGNvbW1lbnRzJyxcbiAgICAgICAgcm93czogMTBcbiAgICB9KTtcbn0pO1xuPC9zY3JpcHQ+XG4qKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFxuICAgIHZhciBUZXh0YXJlYSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdCgndGV4dGFyZWEnLCBvcHRpb25zLCBUZXh0YXJlYS5kZWZhdWx0cyk7XG4gICAgfTtcblxuICAgICQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KFRleHRhcmVhLCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dCk7XG5cbiAgICAkLmV4dGVuZChUZXh0YXJlYS5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNldENsYXNzKCk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3BsYWNlaG9sZGVyJyk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3Jvd3MnKTsgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9jdHJsICsgZW50ZXJcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LmtleWRvd24oZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5jdHJsS2V5ICYmIGUud2hpY2ggPT09IDEzKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykuY2xvc2VzdCgnZm9ybScpLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAvL3VzaW5nIGB3aGl0ZS1zcGFjZTogcHJlLXdyYXBgIHNvbHZlcyBcXG4gIDwtLT4gQlIgY29udmVyc2lvbiB2ZXJ5IGVsZWdhbnQhXG4gICAgICAgLyogXG4gICAgICAgdmFsdWUyaHRtbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBodG1sID0gJycsIGxpbmVzO1xuICAgICAgICAgICAgaWYodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBsaW5lcyA9IHZhbHVlLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZXNbaV0gPSAkKCc8ZGl2PicpLnRleHQobGluZXNbaV0pLmh0bWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaHRtbCA9IGxpbmVzLmpvaW4oJzxicj4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICQoZWxlbWVudCkuaHRtbChodG1sKTtcbiAgICAgICAgfSxcbiAgICAgICBcbiAgICAgICAgaHRtbDJ2YWx1ZTogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICAgaWYoIWh0bWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoU3RyaW5nLmZyb21DaGFyQ29kZSgxMCksICdnJyk7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSBodG1sLnNwbGl0KC88YnJcXHMqXFwvPz4vaSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSAkKCc8ZGl2PicpLmh0bWwobGluZXNbaV0pLnRleHQoKTtcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBuZXdsaW5lIGNoYXJhY3RlcnMgKFxcbikgdG8gYXZvaWQgdGhlbSBiZWluZyBjb252ZXJ0ZWQgYnkgdmFsdWUyaHRtbCgpIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIHRodXMgYWRkaW5nIGV4dHJhIDxicj4gdGFnc1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UocmVnZXgsICcnKTtcblxuICAgICAgICAgICAgICAgIGxpbmVzW2ldID0gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgICAgICB9LFxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQucHJvdG90eXBlLmFjdGl2YXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIFRleHRhcmVhLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0LmRlZmF1bHRzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgdHBsXG4gICAgICAgIEBkZWZhdWx0IDx0ZXh0YXJlYT48L3RleHRhcmVhPlxuICAgICAgICAqKi9cbiAgICAgICAgdHBsOic8dGV4dGFyZWE+PC90ZXh0YXJlYT4nLFxuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IGlucHV0Y2xhc3NcbiAgICAgICAgQGRlZmF1bHQgaW5wdXQtbGFyZ2VcbiAgICAgICAgKiovXG4gICAgICAgIGlucHV0Y2xhc3M6ICdpbnB1dC1sYXJnZScsXG4gICAgICAgIC8qKlxuICAgICAgICBQbGFjZWhvbGRlciBhdHRyaWJ1dGUgb2YgaW5wdXQuIFNob3duIHdoZW4gaW5wdXQgaXMgZW1wdHkuXG5cbiAgICAgICAgQHByb3BlcnR5IHBsYWNlaG9sZGVyXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqL1xuICAgICAgICBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIE51bWJlciBvZiByb3dzIGluIHRleHRhcmVhXG5cbiAgICAgICAgQHByb3BlcnR5IHJvd3NcbiAgICAgICAgQHR5cGUgaW50ZWdlclxuICAgICAgICBAZGVmYXVsdCA3XG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIHJvd3M6IDcgICAgICAgIFxuICAgIH0pO1xuXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHRhcmVhID0gVGV4dGFyZWE7XG5cbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKipcblNlbGVjdCAoZHJvcGRvd24pXG5cbkBjbGFzcyBzZWxlY3RcbkBleHRlbmRzIGxpc3RcbkBmaW5hbFxuQGV4YW1wbGVcbjxhIGhyZWY9XCIjXCIgaWQ9XCJzdGF0dXNcIiBkYXRhLXR5cGU9XCJzZWxlY3RcIiBkYXRhLXBrPVwiMVwiIGRhdGEtdXJsPVwiL3Bvc3RcIiBkYXRhLXRpdGxlPVwiU2VsZWN0IHN0YXR1c1wiPjwvYT5cbjxzY3JpcHQ+XG4kKGZ1bmN0aW9uKCl7XG4gICAgJCgnI3N0YXR1cycpLmVkaXRhYmxlKHtcbiAgICAgICAgdmFsdWU6IDIsICAgIFxuICAgICAgICBzb3VyY2U6IFtcbiAgICAgICAgICAgICAge3ZhbHVlOiAxLCB0ZXh0OiAnQWN0aXZlJ30sXG4gICAgICAgICAgICAgIHt2YWx1ZTogMiwgdGV4dDogJ0Jsb2NrZWQnfSxcbiAgICAgICAgICAgICAge3ZhbHVlOiAzLCB0ZXh0OiAnRGVsZXRlZCd9XG4gICAgICAgICAgIF1cbiAgICB9KTtcbn0pO1xuPC9zY3JpcHQ+XG4qKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFxuICAgIHZhciBTZWxlY3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ3NlbGVjdCcsIG9wdGlvbnMsIFNlbGVjdC5kZWZhdWx0cyk7XG4gICAgfTtcblxuICAgICQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KFNlbGVjdCwgJC5mbi5lZGl0YWJsZXR5cGVzLmxpc3QpO1xuXG4gICAgJC5leHRlbmQoU2VsZWN0LnByb3RvdHlwZSwge1xuICAgICAgICByZW5kZXJMaXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LmVtcHR5KCk7XG5cbiAgICAgICAgICAgIHZhciBmaWxsSXRlbXMgPSBmdW5jdGlvbigkZWwsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cjtcbiAgICAgICAgICAgICAgICBpZigkLmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ciA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGF0YVtpXS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIubGFiZWwgPSBkYXRhW2ldLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGVsLmFwcGVuZChmaWxsSXRlbXMoJCgnPG9wdGdyb3VwPicsIGF0dHIpLCBkYXRhW2ldLmNoaWxkcmVuKSk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyLnZhbHVlID0gZGF0YVtpXS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihkYXRhW2ldLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkZWwuYXBwZW5kKCQoJzxvcHRpb24+JywgYXR0cikudGV4dChkYXRhW2ldLnRleHQpKTsgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICRlbDtcbiAgICAgICAgICAgIH07ICAgICAgICBcblxuICAgICAgICAgICAgZmlsbEl0ZW1zKHRoaXMuJGlucHV0LCB0aGlzLnNvdXJjZURhdGEpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnNldENsYXNzKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vZW50ZXIgc3VibWl0XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5vbigna2V5ZG93bi5lZGl0YWJsZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IDEzKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykuY2xvc2VzdCgnZm9ybScpLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pOyAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgIFxuICAgICAgICB2YWx1ZTJodG1sRmluYWw6IGZ1bmN0aW9uKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9ICcnLCBcbiAgICAgICAgICAgICAgICBpdGVtcyA9ICQuZm4uZWRpdGFibGV1dGlscy5pdGVtc0J5VmFsdWUodmFsdWUsIHRoaXMuc291cmNlRGF0YSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gaXRlbXNbMF0udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8kKGVsZW1lbnQpLnRleHQodGV4dCk7XG4gICAgICAgICAgICAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dC5wcm90b3R5cGUudmFsdWUyaHRtbC5jYWxsKHRoaXMsIHRleHQsIGVsZW1lbnQpO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgYXV0b3N1Ym1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5vZmYoJ2tleWRvd24uZWRpdGFibGUnKS5vbignY2hhbmdlLmVkaXRhYmxlJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKS5zdWJtaXQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7ICAgICAgXG5cbiAgICBTZWxlY3QuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLmxpc3QuZGVmYXVsdHMsIHtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSB0cGwgXG4gICAgICAgIEBkZWZhdWx0IDxzZWxlY3Q+PC9zZWxlY3Q+XG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICB0cGw6JzxzZWxlY3Q+PC9zZWxlY3Q+J1xuICAgIH0pO1xuXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLnNlbGVjdCA9IFNlbGVjdDsgICAgICBcblxufSh3aW5kb3cualF1ZXJ5KSk7XG5cbi8qKlxuTGlzdCBvZiBjaGVja2JveGVzLiBcbkludGVybmFsbHkgdmFsdWUgc3RvcmVkIGFzIGphdmFzY3JpcHQgYXJyYXkgb2YgdmFsdWVzLlxuXG5AY2xhc3MgY2hlY2tsaXN0XG5AZXh0ZW5kcyBsaXN0XG5AZmluYWxcbkBleGFtcGxlXG48YSBocmVmPVwiI1wiIGlkPVwib3B0aW9uc1wiIGRhdGEtdHlwZT1cImNoZWNrbGlzdFwiIGRhdGEtcGs9XCIxXCIgZGF0YS11cmw9XCIvcG9zdFwiIGRhdGEtdGl0bGU9XCJTZWxlY3Qgb3B0aW9uc1wiPjwvYT5cbjxzY3JpcHQ+XG4kKGZ1bmN0aW9uKCl7XG4gICAgJCgnI29wdGlvbnMnKS5lZGl0YWJsZSh7XG4gICAgICAgIHZhbHVlOiBbMiwgM10sICAgIFxuICAgICAgICBzb3VyY2U6IFtcbiAgICAgICAgICAgICAge3ZhbHVlOiAxLCB0ZXh0OiAnb3B0aW9uMSd9LFxuICAgICAgICAgICAgICB7dmFsdWU6IDIsIHRleHQ6ICdvcHRpb24yJ30sXG4gICAgICAgICAgICAgIHt2YWx1ZTogMywgdGV4dDogJ29wdGlvbjMnfVxuICAgICAgICAgICBdXG4gICAgfSk7XG59KTtcbjwvc2NyaXB0PlxuKiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBcbiAgICB2YXIgQ2hlY2tsaXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCdjaGVja2xpc3QnLCBvcHRpb25zLCBDaGVja2xpc3QuZGVmYXVsdHMpO1xuICAgIH07XG5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChDaGVja2xpc3QsICQuZm4uZWRpdGFibGV0eXBlcy5saXN0KTtcblxuICAgICQuZXh0ZW5kKENoZWNrbGlzdC5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVuZGVyTGlzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgJGxhYmVsLCAkZGl2O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiR0cGwuZW1wdHkoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoISQuaXNBcnJheSh0aGlzLnNvdXJjZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTx0aGlzLnNvdXJjZURhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAkbGFiZWwgPSAkKCc8bGFiZWw+JykuYXBwZW5kKCQoJzxpbnB1dD4nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zb3VyY2VEYXRhW2ldLnZhbHVlIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJCgnPHNwYW4+JykudGV4dCgnICcrdGhpcy5zb3VyY2VEYXRhW2ldLnRleHQpKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAkKCc8ZGl2PicpLmFwcGVuZCgkbGFiZWwpLmFwcGVuZFRvKHRoaXMuJHRwbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJGlucHV0ID0gdGhpcy4kdHBsLmZpbmQoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScpO1xuICAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuICAgICAgICB9LFxuICAgICAgIFxuICAgICAgIHZhbHVlMnN0cjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgcmV0dXJuICQuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5zb3J0KCkuam9pbigkLnRyaW0odGhpcy5vcHRpb25zLnNlcGFyYXRvcikpIDogJyc7XG4gICAgICAgfSwgIFxuICAgICAgIFxuICAgICAgIC8vcGFyc2Ugc2VwYXJhdGVkIHN0cmluZ1xuICAgICAgICBzdHIydmFsdWU6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICB2YXIgcmVnLCB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnICYmIHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgIHJlZyA9IG5ldyBSZWdFeHAoJ1xcXFxzKicrJC50cmltKHRoaXMub3B0aW9ucy5zZXBhcmF0b3IpKydcXFxccyonKTtcbiAgICAgICAgICAgICAgIHZhbHVlID0gc3RyLnNwbGl0KHJlZyk7XG4gICAgICAgICAgIH0gZWxzZSBpZigkLmlzQXJyYXkoc3RyKSkge1xuICAgICAgICAgICAgICAgdmFsdWUgPSBzdHI7IFxuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgdmFsdWUgPSBbc3RyXTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sICAgICAgIFxuICAgICAgIFxuICAgICAgIC8vc2V0IGNoZWNrZWQgb24gcmVxdWlyZWQgY2hlY2tib3hlc1xuICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQucHJvcCgnY2hlY2tlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmKCQuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5lYWNoKGZ1bmN0aW9uKGksIGVsKSB7XG4gICAgICAgICAgICAgICAgICAgdmFyICRlbCA9ICQoZWwpO1xuICAgICAgICAgICAgICAgICAgIC8vIGNhbm5vdCB1c2UgJC5pbkFycmF5IGFzIGl0IHBlcmZvcm1zIHN0cmljdCBjb21wYXJpc29uXG4gICAgICAgICAgICAgICAgICAgJC5lYWNoKHZhbHVlLCBmdW5jdGlvbihqLCB2YWwpe1xuICAgICAgICAgICAgICAgICAgICAgICAvKmpzbGludCBlcWVxOiB0cnVlKi9cbiAgICAgICAgICAgICAgICAgICAgICAgaWYoJGVsLnZhbCgpID09IHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAvKmpzbGludCBlcWVxOiBmYWxzZSovICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAkZWwucHJvcCgnY2hlY2tlZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICB9KTsgXG4gICAgICAgICAgICB9ICBcbiAgICAgICAgfSwgIFxuICAgICAgICBcbiAgICAgICBpbnB1dDJ2YWx1ZTogZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICB2YXIgY2hlY2tlZCA9IFtdO1xuICAgICAgICAgICB0aGlzLiRpbnB1dC5maWx0ZXIoJzpjaGVja2VkJykuZWFjaChmdW5jdGlvbihpLCBlbCkge1xuICAgICAgICAgICAgICAgY2hlY2tlZC5wdXNoKCQoZWwpLnZhbCgpKTtcbiAgICAgICAgICAgfSk7XG4gICAgICAgICAgIHJldHVybiBjaGVja2VkO1xuICAgICAgIH0sICAgICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgLy9jb2xsZWN0IHRleHQgb2YgY2hlY2tlZCBib3hlc1xuICAgICAgICB2YWx1ZTJodG1sRmluYWw6IGZ1bmN0aW9uKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgICAgICAgIHZhciBodG1sID0gW10sXG4gICAgICAgICAgICAgICBjaGVja2VkID0gJC5mbi5lZGl0YWJsZXV0aWxzLml0ZW1zQnlWYWx1ZSh2YWx1ZSwgdGhpcy5zb3VyY2VEYXRhKSxcbiAgICAgICAgICAgICAgIGVzY2FwZSA9IHRoaXMub3B0aW9ucy5lc2NhcGU7XG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgaWYoY2hlY2tlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICQuZWFjaChjaGVja2VkLCBmdW5jdGlvbihpLCB2KSB7XG4gICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBlc2NhcGUgPyAkLmZuLmVkaXRhYmxldXRpbHMuZXNjYXBlKHYudGV4dCkgOiB2LnRleHQ7IFxuICAgICAgICAgICAgICAgICAgIGh0bWwucHVzaCh0ZXh0KTsgXG4gICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICQoZWxlbWVudCkuaHRtbChodG1sLmpvaW4oJzxicj4nKSk7XG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAkKGVsZW1lbnQpLmVtcHR5KCk7IFxuICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgIGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgdGhpcy4kaW5wdXQuZmlyc3QoKS5mb2N1cygpO1xuICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgYXV0b3N1Ym1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIHRoaXMuJGlucHV0Lm9uKCdrZXlkb3duJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICBpZiAoZS53aGljaCA9PT0gMTMpIHtcbiAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKS5zdWJtaXQoKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfSk7XG4gICAgICAgfVxuICAgIH0pOyAgICAgIFxuXG4gICAgQ2hlY2tsaXN0LmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5saXN0LmRlZmF1bHRzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgdHBsIFxuICAgICAgICBAZGVmYXVsdCA8ZGl2PjwvZGl2PlxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgdHBsOic8ZGl2IGNsYXNzPVwiZWRpdGFibGUtY2hlY2tsaXN0XCI+PC9kaXY+JyxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgaW5wdXRjbGFzcyBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGlucHV0Y2xhc3M6IG51bGwsICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBTZXBhcmF0b3Igb2YgdmFsdWVzIHdoZW4gcmVhZGluZyBmcm9tIGBkYXRhLXZhbHVlYCBhdHRyaWJ1dGVcblxuICAgICAgICBAcHJvcGVydHkgc2VwYXJhdG9yIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgJywnXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBzZXBhcmF0b3I6ICcsJ1xuICAgIH0pO1xuXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLmNoZWNrbGlzdCA9IENoZWNrbGlzdDsgICAgICBcblxufSh3aW5kb3cualF1ZXJ5KSk7XG5cbi8qKlxuSFRNTDUgaW5wdXQgdHlwZXMuXG5Gb2xsb3dpbmcgdHlwZXMgYXJlIHN1cHBvcnRlZDpcblxuKiBwYXNzd29yZFxuKiBlbWFpbFxuKiB1cmxcbiogdGVsXG4qIG51bWJlclxuKiByYW5nZVxuKiB0aW1lXG5cbkxlYXJuIG1vcmUgYWJvdXQgaHRtbDUgaW5wdXRzOiAgXG5odHRwOi8vd3d3LnczLm9yZy93aWtpL0hUTUw1X2Zvcm1fYWRkaXRpb25zICBcblRvIGNoZWNrIGJyb3dzZXIgY29tcGF0aWJpbGl0eSBwbGVhc2Ugc2VlOiAgXG5odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0hUTUwvRWxlbWVudC9JbnB1dFxuICAgICAgICAgICAgXG5AY2xhc3MgaHRtbDV0eXBlcyBcbkBleHRlbmRzIHRleHRcbkBmaW5hbFxuQHNpbmNlIDEuMy4wXG5AZXhhbXBsZVxuPGEgaHJlZj1cIiNcIiBpZD1cImVtYWlsXCIgZGF0YS10eXBlPVwiZW1haWxcIiBkYXRhLXBrPVwiMVwiPmFkbWluQGV4YW1wbGUuY29tPC9hPlxuPHNjcmlwdD5cbiQoZnVuY3Rpb24oKXtcbiAgICAkKCcjZW1haWwnKS5lZGl0YWJsZSh7XG4gICAgICAgIHVybDogJy9wb3N0JyxcbiAgICAgICAgdGl0bGU6ICdFbnRlciBlbWFpbCdcbiAgICB9KTtcbn0pO1xuPC9zY3JpcHQ+XG4qKi9cblxuLyoqXG5AcHJvcGVydHkgdHBsIFxuQGRlZmF1bHQgZGVwZW5kcyBvbiB0eXBlXG4qKi8gXG5cbi8qXG5QYXNzd29yZFxuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFxuICAgIHZhciBQYXNzd29yZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdCgncGFzc3dvcmQnLCBvcHRpb25zLCBQYXNzd29yZC5kZWZhdWx0cyk7XG4gICAgfTtcbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChQYXNzd29yZCwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQpO1xuICAgICQuZXh0ZW5kKFBhc3N3b3JkLnByb3RvdHlwZSwge1xuICAgICAgIC8vZG8gbm90IGRpc3BsYXkgcGFzc3dvcmQsIHNob3cgJ1toaWRkZW5dJyBpbnN0ZWFkXG4gICAgICAgdmFsdWUyaHRtbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgaWYodmFsdWUpIHtcbiAgICAgICAgICAgICAgICQoZWxlbWVudCkudGV4dCgnW2hpZGRlbl0nKTtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICQoZWxlbWVudCkuZW1wdHkoKTsgXG4gICAgICAgICAgIH1cbiAgICAgICB9LFxuICAgICAgIC8vYXMgcGFzc3dvcmQgbm90IGRpc3BsYXllZCwgc2hvdWxkIG5vdCBzZXQgdmFsdWUgYnkgaHRtbFxuICAgICAgIGh0bWwydmFsdWU6IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgfSAgICAgICBcbiAgICB9KTsgICAgXG4gICAgUGFzc3dvcmQuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQuZGVmYXVsdHMsIHtcbiAgICAgICAgdHBsOiAnPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiPidcbiAgICB9KTtcbiAgICAkLmZuLmVkaXRhYmxldHlwZXMucGFzc3dvcmQgPSBQYXNzd29yZDtcbn0od2luZG93LmpRdWVyeSkpO1xuXG5cbi8qXG5FbWFpbFxuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFxuICAgIHZhciBFbWFpbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdCgnZW1haWwnLCBvcHRpb25zLCBFbWFpbC5kZWZhdWx0cyk7XG4gICAgfTtcbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChFbWFpbCwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQpO1xuICAgIEVtYWlsLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0LmRlZmF1bHRzLCB7XG4gICAgICAgIHRwbDogJzxpbnB1dCB0eXBlPVwiZW1haWxcIj4nXG4gICAgfSk7XG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLmVtYWlsID0gRW1haWw7XG59KHdpbmRvdy5qUXVlcnkpKTtcblxuXG4vKlxuVXJsXG4qL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgXG4gICAgdmFyIFVybCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdCgndXJsJywgb3B0aW9ucywgVXJsLmRlZmF1bHRzKTtcbiAgICB9O1xuICAgICQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KFVybCwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQpO1xuICAgIFVybC5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxldHlwZXMudGV4dC5kZWZhdWx0cywge1xuICAgICAgICB0cGw6ICc8aW5wdXQgdHlwZT1cInVybFwiPidcbiAgICB9KTtcbiAgICAkLmZuLmVkaXRhYmxldHlwZXMudXJsID0gVXJsO1xufSh3aW5kb3cualF1ZXJ5KSk7XG5cblxuLypcblRlbFxuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFxuICAgIHZhciBUZWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ3RlbCcsIG9wdGlvbnMsIFRlbC5kZWZhdWx0cyk7XG4gICAgfTtcbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChUZWwsICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0KTtcbiAgICBUZWwuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQuZGVmYXVsdHMsIHtcbiAgICAgICAgdHBsOiAnPGlucHV0IHR5cGU9XCJ0ZWxcIj4nXG4gICAgfSk7XG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLnRlbCA9IFRlbDtcbn0od2luZG93LmpRdWVyeSkpO1xuXG5cbi8qXG5OdW1iZXJcbiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBcbiAgICB2YXIgTnVtYmVySW5wdXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ251bWJlcicsIG9wdGlvbnMsIE51bWJlcklucHV0LmRlZmF1bHRzKTtcbiAgICB9O1xuICAgICQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KE51bWJlcklucHV0LCAkLmZuLmVkaXRhYmxldHlwZXMudGV4dCk7XG4gICAgJC5leHRlbmQoTnVtYmVySW5wdXQucHJvdG90eXBlLCB7XG4gICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIE51bWJlcklucHV0LnN1cGVyY2xhc3MucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ21pbicpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdtYXgnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignc3RlcCcpO1xuICAgICAgICB9LFxuICAgICAgICBwb3N0cmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuJGNsZWFyKSB7XG4gICAgICAgICAgICAgICAgLy9pbmNyZWFzZSByaWdodCBmZnNldCAgZm9yIHVwL2Rvd24gYXJyb3dzXG4gICAgICAgICAgICAgICAgdGhpcy4kY2xlYXIuY3NzKHtyaWdodDogMjR9KTtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIC8vY2FuIHBvc2l0aW9uIGNsZWFyIGJ1dHRvbiBvbmx5IGhlcmUsIHdoZW4gZm9ybSBpcyBzaG93biBhbmQgaGVpZ2h0IGNhbiBiZSBjYWxjdWxhdGVkXG4gICAgICAgICAgICAgICAgdmFyIGggPSB0aGlzLiRpbnB1dC5vdXRlckhlaWdodCh0cnVlKSB8fCAyMCxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSAoaCAtIHRoaXMuJGNsZWFyLmhlaWdodCgpKSAvIDI7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9hZGQgMTJweCB0byBvZmZzZXQgcmlnaHQgZm9yIHVwL2Rvd24gYXJyb3dzICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyLmNzcyh7dG9wOiBkZWx0YSwgcmlnaHQ6IGRlbHRhICsgMTZ9KTtcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgfSBcbiAgICAgICAgfSAgICAgICAgXG4gICAgfSk7ICAgICBcbiAgICBOdW1iZXJJbnB1dC5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxldHlwZXMudGV4dC5kZWZhdWx0cywge1xuICAgICAgICB0cGw6ICc8aW5wdXQgdHlwZT1cIm51bWJlclwiPicsXG4gICAgICAgIGlucHV0Y2xhc3M6ICdpbnB1dC1taW5pJyxcbiAgICAgICAgbWluOiBudWxsLFxuICAgICAgICBtYXg6IG51bGwsXG4gICAgICAgIHN0ZXA6IG51bGxcbiAgICB9KTtcbiAgICAkLmZuLmVkaXRhYmxldHlwZXMubnVtYmVyID0gTnVtYmVySW5wdXQ7XG59KHdpbmRvdy5qUXVlcnkpKTtcblxuXG4vKlxuUmFuZ2UgKGluaGVyaXQgZnJvbSBudW1iZXIpXG4qL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgXG4gICAgdmFyIFJhbmdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCdyYW5nZScsIG9wdGlvbnMsIFJhbmdlLmRlZmF1bHRzKTtcbiAgICB9O1xuICAgICQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KFJhbmdlLCAkLmZuLmVkaXRhYmxldHlwZXMubnVtYmVyKTtcbiAgICAkLmV4dGVuZChSYW5nZS5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dCA9IHRoaXMuJHRwbC5maWx0ZXIoJ2lucHV0Jyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3MoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignbWluJyk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ21heCcpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdzdGVwJyk7ICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kaW5wdXQub24oJ2lucHV0JywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnNpYmxpbmdzKCdvdXRwdXQnKS50ZXh0KCQodGhpcykudmFsKCkpOyBcbiAgICAgICAgICAgIH0pOyAgXG4gICAgICAgIH0sXG4gICAgICAgIGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LmZvY3VzKCk7XG4gICAgICAgIH0gICAgICAgICBcbiAgICB9KTtcbiAgICBSYW5nZS5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxldHlwZXMubnVtYmVyLmRlZmF1bHRzLCB7XG4gICAgICAgIHRwbDogJzxpbnB1dCB0eXBlPVwicmFuZ2VcIj48b3V0cHV0IHN0eWxlPVwid2lkdGg6IDMwcHg7IGRpc3BsYXk6IGlubGluZS1ibG9ja1wiPjwvb3V0cHV0PicsXG4gICAgICAgIGlucHV0Y2xhc3M6ICdpbnB1dC1tZWRpdW0nXG4gICAgfSk7XG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLnJhbmdlID0gUmFuZ2U7XG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLypcblRpbWVcbiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBUaW1lID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCd0aW1lJywgb3B0aW9ucywgVGltZS5kZWZhdWx0cyk7XG4gICAgfTtcbiAgICAvL2luaGVyaXQgZnJvbSBhYnN0cmFjdCwgYXMgaW5oZXJpdGFuY2UgZnJvbSB0ZXh0IGdpdmVzIHNlbGVjdGlvbiBlcnJvci5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChUaW1lLCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dCk7XG4gICAgJC5leHRlbmQoVGltZS5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuICAgICAgICB9ICAgICAgICBcbiAgICB9KTtcbiAgICBUaW1lLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0LmRlZmF1bHRzLCB7XG4gICAgICAgIHRwbDogJzxpbnB1dCB0eXBlPVwidGltZVwiPidcbiAgICB9KTtcbiAgICAkLmZuLmVkaXRhYmxldHlwZXMudGltZSA9IFRpbWU7XG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG5TZWxlY3QyIGlucHV0LiBCYXNlZCBvbiBhbWF6aW5nIHdvcmsgb2YgSWdvciBWYXluYmVyZyBodHRwczovL2dpdGh1Yi5jb20vaXZheW5iZXJnL3NlbGVjdDIuICBcblBsZWFzZSBzZWUgW29yaWdpbmFsIHNlbGVjdDIgZG9jc10oaHR0cDovL2l2YXluYmVyZy5naXRodWIuY29tL3NlbGVjdDIpIGZvciBkZXRhaWxlZCBkZXNjcmlwdGlvbiBhbmQgb3B0aW9ucy4gIFxuIFxuWW91IHNob3VsZCBtYW51YWxseSBkb3dubG9hZCBhbmQgaW5jbHVkZSBzZWxlY3QyIGRpc3RyaWJ1dGl2ZTogIFxuXG4gICAgPGxpbmsgaHJlZj1cInNlbGVjdDIvc2VsZWN0Mi5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCIgdHlwZT1cInRleHQvY3NzXCI+PC9saW5rPiAgXG4gICAgPHNjcmlwdCBzcmM9XCJzZWxlY3QyL3NlbGVjdDIuanNcIj48L3NjcmlwdD4gIFxuICAgIFxuVG8gbWFrZSBpdCAqKmJvb3RzdHJhcC1zdHlsZWQqKiB5b3UgY2FuIHVzZSBjc3MgZnJvbSBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL3QwbS9zZWxlY3QyLWJvb3RzdHJhcC1jc3MpOiBcblxuICAgIDxsaW5rIGhyZWY9XCJzZWxlY3QyLWJvb3RzdHJhcC5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCIgdHlwZT1cInRleHQvY3NzXCI+PC9saW5rPiAgICBcbiAgICBcbioqTm90ZToqKiBjdXJyZW50bHkgYGF1dG90ZXh0YCBmZWF0dXJlIGRvZXMgbm90IHdvcmsgZm9yIHNlbGVjdDIgd2l0aCBgYWpheGAgcmVtb3RlIHNvdXJjZS4gICAgXG5Zb3UgbmVlZCBpbml0aWFsbHkgcHV0IGJvdGggYGRhdGEtdmFsdWVgIGFuZCBlbGVtZW50J3MgdGV4dCB5b3VzZWxmOiAgICBcblxuICAgIDxhIGhyZWY9XCIjXCIgZGF0YS10eXBlPVwic2VsZWN0MlwiIGRhdGEtdmFsdWU9XCIxXCI+VGV4dDE8L2E+XG4gICAgXG4gICAgXG5AY2xhc3Mgc2VsZWN0MlxuQGV4dGVuZHMgYWJzdHJhY3RpbnB1dFxuQHNpbmNlIDEuNC4xXG5AZmluYWxcbkBleGFtcGxlXG48YSBocmVmPVwiI1wiIGlkPVwiY291bnRyeVwiIGRhdGEtdHlwZT1cInNlbGVjdDJcIiBkYXRhLXBrPVwiMVwiIGRhdGEtdmFsdWU9XCJydVwiIGRhdGEtdXJsPVwiL3Bvc3RcIiBkYXRhLXRpdGxlPVwiU2VsZWN0IGNvdW50cnlcIj48L2E+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgIC8vbG9jYWwgc291cmNlXG4gICAgJCgnI2NvdW50cnknKS5lZGl0YWJsZSh7XG4gICAgICAgIHNvdXJjZTogW1xuICAgICAgICAgICAgICB7aWQ6ICdnYicsIHRleHQ6ICdHcmVhdCBCcml0YWluJ30sXG4gICAgICAgICAgICAgIHtpZDogJ3VzJywgdGV4dDogJ1VuaXRlZCBTdGF0ZXMnfSxcbiAgICAgICAgICAgICAge2lkOiAncnUnLCB0ZXh0OiAnUnVzc2lhJ31cbiAgICAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0Mjoge1xuICAgICAgICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy9yZW1vdGUgc291cmNlIChzaW1wbGUpXG4gICAgJCgnI2NvdW50cnknKS5lZGl0YWJsZSh7XG4gICAgICAgIHNvdXJjZTogJy9nZXRDb3VudHJpZXMnLFxuICAgICAgICBzZWxlY3QyOiB7XG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogJ1NlbGVjdCBDb3VudHJ5JyxcbiAgICAgICAgICAgIG1pbmltdW1JbnB1dExlbmd0aDogMVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy9yZW1vdGUgc291cmNlIChhZHZhbmNlZClcbiAgICAkKCcjY291bnRyeScpLmVkaXRhYmxlKHtcbiAgICAgICAgc2VsZWN0Mjoge1xuICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdTZWxlY3QgQ291bnRyeScsXG4gICAgICAgICAgICBhbGxvd0NsZWFyOiB0cnVlLFxuICAgICAgICAgICAgbWluaW11bUlucHV0TGVuZ3RoOiAzLFxuICAgICAgICAgICAgaWQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uQ291bnRyeUlkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFqYXg6IHtcbiAgICAgICAgICAgICAgICB1cmw6ICcvZ2V0Q291bnRyaWVzJyxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgIGRhdGE6IGZ1bmN0aW9uICh0ZXJtLCBwYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHF1ZXJ5OiB0ZXJtIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXN1bHRzOiBmdW5jdGlvbiAoZGF0YSwgcGFnZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHRzOiBkYXRhIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcm1hdFJlc3VsdDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5Db3VudHJ5TmFtZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JtYXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uQ291bnRyeU5hbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5pdFNlbGVjdGlvbjogZnVuY3Rpb24gKGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQuZ2V0KCcvZ2V0Q291bnRyeUJ5SWQnLCB7IHF1ZXJ5OiBlbGVtZW50LnZhbCgpIH0sIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgfSAgXG4gICAgfSk7XG59KTtcbjwvc2NyaXB0PlxuKiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBcbiAgICB2YXIgQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ3NlbGVjdDInLCBvcHRpb25zLCBDb25zdHJ1Y3Rvci5kZWZhdWx0cyk7XG5cbiAgICAgICAgb3B0aW9ucy5zZWxlY3QyID0gb3B0aW9ucy5zZWxlY3QyIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuc291cmNlRGF0YSA9IG51bGw7XG4gICAgICAgIFxuICAgICAgICAvL3BsYWNlaG9sZGVyXG4gICAgICAgIGlmKG9wdGlvbnMucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2VsZWN0Mi5wbGFjZWhvbGRlciA9IG9wdGlvbnMucGxhY2Vob2xkZXI7XG4gICAgICAgIH1cbiAgICAgICBcbiAgICAgICAgLy9pZiBub3QgYHRhZ3NgIG1vZGUsIHVzZSBzb3VyY2VcbiAgICAgICAgaWYoIW9wdGlvbnMuc2VsZWN0Mi50YWdzICYmIG9wdGlvbnMuc291cmNlKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gb3B0aW9ucy5zb3VyY2U7XG4gICAgICAgICAgICAvL2lmIHNvdXJjZSBpcyBmdW5jdGlvbiwgY2FsbCBpdCAob25jZSEpXG4gICAgICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKG9wdGlvbnMuc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IG9wdGlvbnMuc291cmNlLmNhbGwob3B0aW9ucy5zY29wZSk7XG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2VsZWN0Mi5hamF4ID0gb3B0aW9ucy5zZWxlY3QyLmFqYXggfHwge307XG4gICAgICAgICAgICAgICAgLy9zb21lIGRlZmF1bHQgYWpheCBwYXJhbXNcbiAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5zZWxlY3QyLmFqYXguZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNlbGVjdDIuYWpheC5kYXRhID0gZnVuY3Rpb24odGVybSkge3JldHVybiB7IHF1ZXJ5OnRlcm0gfTt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5zZWxlY3QyLmFqYXgucmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNlbGVjdDIuYWpheC5yZXN1bHRzID0gZnVuY3Rpb24oZGF0YSkgeyByZXR1cm4ge3Jlc3VsdHM6ZGF0YSB9O307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2VsZWN0Mi5hamF4LnVybCA9IHNvdXJjZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9jaGVjayBmb3JtYXQgYW5kIGNvbnZlcnQgeC1lZGl0YWJsZSBmb3JtYXQgdG8gc2VsZWN0MiBmb3JtYXQgKGlmIG5lZWRlZClcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZURhdGEgPSB0aGlzLmNvbnZlcnRTb3VyY2Uoc291cmNlKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNlbGVjdDIuZGF0YSA9IHRoaXMuc291cmNlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBcblxuICAgICAgICAvL292ZXJyaWRpbmcgb2JqZWN0cyBpbiBjb25maWcgKGFzIGJ5IGRlZmF1bHQgalF1ZXJ5IGV4dGVuZCgpIGlzIG5vdCByZWN1cnNpdmUpXG4gICAgICAgIHRoaXMub3B0aW9ucy5zZWxlY3QyID0gJC5leHRlbmQoe30sIENvbnN0cnVjdG9yLmRlZmF1bHRzLnNlbGVjdDIsIG9wdGlvbnMuc2VsZWN0Mik7XG5cbiAgICAgICAgLy9kZXRlY3Qgd2hldGhlciBpdCBpcyBtdWx0aS12YWx1ZWRcbiAgICAgICAgdGhpcy5pc011bHRpcGxlID0gdGhpcy5vcHRpb25zLnNlbGVjdDIudGFncyB8fCB0aGlzLm9wdGlvbnMuc2VsZWN0Mi5tdWx0aXBsZTtcbiAgICAgICAgdGhpcy5pc1JlbW90ZSA9ICgnYWpheCcgaW4gdGhpcy5vcHRpb25zLnNlbGVjdDIpO1xuXG4gICAgICAgIC8vc3RvcmUgZnVuY3Rpb24gcmV0dXJuaW5nIElEIG9mIGl0ZW1cbiAgICAgICAgLy9zaG91bGQgYmUgaGVyZSBhcyB1c2VkIGluYXV0b3RleHQgZm9yIGxvY2FsIHNvdXJjZVxuICAgICAgICB0aGlzLmlkRnVuYyA9IHRoaXMub3B0aW9ucy5zZWxlY3QyLmlkO1xuICAgICAgICBpZiAodHlwZW9mKHRoaXMuaWRGdW5jKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YXIgaWRLZXkgPSB0aGlzLmlkRnVuYyB8fCAnaWQnO1xuICAgICAgICAgICAgdGhpcy5pZEZ1bmMgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZVtpZEtleV07IH07XG4gICAgICAgIH1cblxuICAgICAgICAvL3N0b3JlIGZ1bmN0aW9uIHRoYXQgcmVuZGVycyB0ZXh0IGluIHNlbGVjdDJcbiAgICAgICAgdGhpcy5mb3JtYXRTZWxlY3Rpb24gPSB0aGlzLm9wdGlvbnMuc2VsZWN0Mi5mb3JtYXRTZWxlY3Rpb247XG4gICAgICAgIGlmICh0eXBlb2YodGhpcy5mb3JtYXRTZWxlY3Rpb24pICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0U2VsZWN0aW9uID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUudGV4dDsgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChDb25zdHJ1Y3RvciwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQpO1xuXG4gICAgJC5leHRlbmQoQ29uc3RydWN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnNldENsYXNzKCk7XG5cbiAgICAgICAgICAgIC8vY2FuIG5vdCBhcHBseSBzZWxlY3QyIGhlcmUgYXMgaXQgY2FsbHMgaW5pdFNlbGVjdGlvbiBcbiAgICAgICAgICAgIC8vb3ZlciBpbnB1dCB0aGF0IGRvZXMgbm90IGhhdmUgY29ycmVjdCB2YWx1ZSB5ZXQuXG4gICAgICAgICAgICAvL2FwcGx5IHNlbGVjdDIgb25seSBpbiB2YWx1ZTJpbnB1dFxuICAgICAgICAgICAgLy90aGlzLiRpbnB1dC5zZWxlY3QyKHRoaXMub3B0aW9ucy5zZWxlY3QyKTtcblxuICAgICAgICAgICAgLy93aGVuIGRhdGEgaXMgbG9hZGVkIHZpYSBhamF4LCB3ZSBuZWVkIHRvIGtub3cgd2hlbiBpdCdzIGRvbmUgdG8gcG9wdWxhdGUgbGlzdERhdGFcbiAgICAgICAgICAgIGlmKHRoaXMuaXNSZW1vdGUpIHtcbiAgICAgICAgICAgICAgICAvL2xpc3RlbiB0byBsb2FkZWQgZXZlbnQgdG8gcG9wdWxhdGUgZGF0YVxuICAgICAgICAgICAgICAgIHRoaXMuJGlucHV0Lm9uKCdzZWxlY3QyLWxvYWRlZCcsICQucHJveHkoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZURhdGEgPSBlLml0ZW1zLnJlc3VsdHM7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3RyaWdnZXIgcmVzaXplIG9mIGVkaXRhYmxlZm9ybSB0byByZS1wb3NpdGlvbiBjb250YWluZXIgaW4gbXVsdGktdmFsdWVkIG1vZGVcbiAgICAgICAgICAgIGlmKHRoaXMuaXNNdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQub24oJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICQodGhpcykuY2xvc2VzdCgnZm9ybScpLnBhcmVudCgpLnRyaWdnZXJIYW5kbGVyKCdyZXNpemUnKTtcbiAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgIH0sXG5cbiAgICAgICB2YWx1ZTJodG1sOiBmdW5jdGlvbih2YWx1ZSwgZWxlbWVudCkge1xuICAgICAgICAgICB2YXIgdGV4dCA9ICcnLCBkYXRhLFxuICAgICAgICAgICAgICAgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnNlbGVjdDIudGFncykgeyAvL2luIHRhZ3MgbW9kZSBqdXN0IGFzc2lnbiB2YWx1ZVxuICAgICAgICAgICAgICBkYXRhID0gdmFsdWU7IFxuICAgICAgICAgICAgICAvL2RhdGEgPSAkLmZuLmVkaXRhYmxldXRpbHMuaXRlbXNCeVZhbHVlKHZhbHVlLCB0aGlzLm9wdGlvbnMuc2VsZWN0Mi50YWdzLCB0aGlzLmlkRnVuYyk7XG4gICAgICAgICAgIH0gZWxzZSBpZih0aGlzLnNvdXJjZURhdGEpIHtcbiAgICAgICAgICAgICAgZGF0YSA9ICQuZm4uZWRpdGFibGV1dGlscy5pdGVtc0J5VmFsdWUodmFsdWUsIHRoaXMuc291cmNlRGF0YSwgdGhpcy5pZEZ1bmMpOyBcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy9jYW4gbm90IGdldCBsaXN0IG9mIHBvc3NpYmxlIHZhbHVlcyBcbiAgICAgICAgICAgICAgLy8oZS5nLiBhdXRvdGV4dCBmb3Igc2VsZWN0MiB3aXRoIGFqYXggc291cmNlKVxuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgLy9kYXRhIG1heSBiZSBhcnJheSAod2hlbiBtdWx0aXBsZSB2YWx1ZXMgYWxsb3dlZClcbiAgICAgICAgICAgaWYoJC5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAvL2NvbGxlY3Qgc2VsZWN0ZWQgZGF0YSBhbmQgc2hvdyB3aXRoIHNlcGFyYXRvclxuICAgICAgICAgICAgICAgdGV4dCA9IFtdO1xuICAgICAgICAgICAgICAgJC5lYWNoKGRhdGEsIGZ1bmN0aW9uKGssIHYpe1xuICAgICAgICAgICAgICAgICAgIHRleHQucHVzaCh2ICYmIHR5cGVvZiB2ID09PSAnb2JqZWN0JyA/IHRoYXQuZm9ybWF0U2VsZWN0aW9uKHYpIDogdik7XG4gICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgfSBlbHNlIGlmKGRhdGEpIHtcbiAgICAgICAgICAgICAgIHRleHQgPSB0aGF0LmZvcm1hdFNlbGVjdGlvbihkYXRhKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIHRleHQgPSAkLmlzQXJyYXkodGV4dCkgPyB0ZXh0LmpvaW4odGhpcy5vcHRpb25zLnZpZXdzZXBhcmF0b3IpIDogdGV4dDtcblxuICAgICAgICAgICAvLyQoZWxlbWVudCkudGV4dCh0ZXh0KTtcbiAgICAgICAgICAgQ29uc3RydWN0b3Iuc3VwZXJjbGFzcy52YWx1ZTJodG1sLmNhbGwodGhpcywgdGV4dCwgZWxlbWVudCk7IFxuICAgICAgIH0sXG5cbiAgICAgICBodG1sMnZhbHVlOiBmdW5jdGlvbihodG1sKSB7XG4gICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc2VsZWN0Mi50YWdzID8gdGhpcy5zdHIydmFsdWUoaHRtbCwgdGhpcy5vcHRpb25zLnZpZXdzZXBhcmF0b3IpIDogbnVsbDtcbiAgICAgICB9LFxuXG4gICAgICAgdmFsdWUyaW5wdXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgIC8vIGlmIHZhbHVlIGFycmF5ID0+IGpvaW4gaXQgYW55d2F5XG4gICAgICAgICAgIGlmKCQuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5qb2luKHRoaXMuZ2V0U2VwYXJhdG9yKCkpO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgLy9mb3IgcmVtb3RlIHNvdXJjZSBqdXN0IHNldCB2YWx1ZSwgdGV4dCBpcyB1cGRhdGVkIGJ5IGluaXRTZWxlY3Rpb25cbiAgICAgICAgICAgaWYoIXRoaXMuJGlucHV0LmRhdGEoJ3NlbGVjdDInKSkge1xuICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQudmFsKHZhbHVlKTtcbiAgICAgICAgICAgICAgIHRoaXMuJGlucHV0LnNlbGVjdDIodGhpcy5vcHRpb25zLnNlbGVjdDIpO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgLy9zZWNvbmQgYXJndW1lbnQgbmVlZGVkIHRvIHNlcGFyYXRlIGluaXRpYWwgY2hhbmdlIGZyb20gdXNlcidzIGNsaWNrIChmb3IgYXV0b3N1Ym1pdCkgICBcbiAgICAgICAgICAgICAgIHRoaXMuJGlucHV0LnZhbCh2YWx1ZSkudHJpZ2dlcignY2hhbmdlJywgdHJ1ZSk7IFxuXG4gICAgICAgICAgICAgICAvL1VuY2F1Z2h0IEVycm9yOiBjYW5ub3QgY2FsbCB2YWwoKSBpZiBpbml0U2VsZWN0aW9uKCkgaXMgbm90IGRlZmluZWRcbiAgICAgICAgICAgICAgIC8vdGhpcy4kaW5wdXQuc2VsZWN0MigndmFsJywgdmFsdWUpO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgLy8gaWYgZGVmaW5lZCByZW1vdGUgc291cmNlIEFORCBubyBtdWx0aXBsZSBtb2RlIEFORCBubyB1c2VyJ3MgaW5pdFNlbGVjdGlvbiBwcm92aWRlZCAtLT4gXG4gICAgICAgICAgIC8vIHdlIHNob3VsZCBzb21laG93IGdldCB0ZXh0IGZvciBwcm92aWRlZCBpZC5cbiAgICAgICAgICAgLy8gVGhlIHNvbHV0aW9uIGlzIHRvIHVzZSBlbGVtZW50J3MgdGV4dCBhcyB0ZXh0IGZvciB0aGF0IGlkIChleGNsdWRlIGVtcHR5KVxuICAgICAgICAgICBpZih0aGlzLmlzUmVtb3RlICYmICF0aGlzLmlzTXVsdGlwbGUgJiYgIXRoaXMub3B0aW9ucy5zZWxlY3QyLmluaXRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgIC8vIGN1c3RvbUlkIGFuZCBjdXN0b21UZXh0IGFyZSBtZXRob2RzIHRvIGV4dHJhY3QgYGlkYCBhbmQgYHRleHRgIGZyb20gZGF0YSBvYmplY3RcbiAgICAgICAgICAgICAgIC8vIHdlIGNhbiB1c2UgdGhpcyB3b3JrYXJvdW5kIG9ubHkgaWYgdXNlciBkaWQgbm90IGRlZmluZSB0aGVzZSBtZXRob2RzXG4gICAgICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgY2FudCBjb25zdHJ1Y3QgZGF0YSBvYmplY3RcbiAgICAgICAgICAgICAgIHZhciBjdXN0b21JZCA9IHRoaXMub3B0aW9ucy5zZWxlY3QyLmlkLFxuICAgICAgICAgICAgICAgICAgIGN1c3RvbVRleHQgPSB0aGlzLm9wdGlvbnMuc2VsZWN0Mi5mb3JtYXRTZWxlY3Rpb247XG5cbiAgICAgICAgICAgICAgIGlmKCFjdXN0b21JZCAmJiAhY3VzdG9tVGV4dCkge1xuICAgICAgICAgICAgICAgICAgIHZhciAkZWwgPSAkKHRoaXMub3B0aW9ucy5zY29wZSk7XG4gICAgICAgICAgICAgICAgICAgaWYgKCEkZWwuZGF0YSgnZWRpdGFibGUnKS5pc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0ge2lkOiB2YWx1ZSwgdGV4dDogJGVsLnRleHQoKX07XG4gICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGlucHV0LnNlbGVjdDIoJ2RhdGEnLCBkYXRhKTsgXG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gICAgICAgfSxcbiAgICAgICBcbiAgICAgICBpbnB1dDJ2YWx1ZTogZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICByZXR1cm4gdGhpcy4kaW5wdXQuc2VsZWN0MigndmFsJyk7XG4gICAgICAgfSxcblxuICAgICAgIHN0cjJ2YWx1ZTogZnVuY3Rpb24oc3RyLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnIHx8ICF0aGlzLmlzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBzZXBhcmF0b3IgfHwgdGhpcy5nZXRTZXBhcmF0b3IoKTtcblxuICAgICAgICAgICAgdmFyIHZhbCwgaSwgbDtcblxuICAgICAgICAgICAgaWYgKHN0ciA9PT0gbnVsbCB8fCBzdHIubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsID0gc3RyLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIHZhbFtpXSA9ICQudHJpbSh2YWxbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgIH0sXG5cbiAgICAgICAgYXV0b3N1Ym1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5vbignY2hhbmdlJywgZnVuY3Rpb24oZSwgaXNJbml0aWFsKXtcbiAgICAgICAgICAgICAgICBpZighaXNJbml0aWFsKSB7XG4gICAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKS5zdWJtaXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRTZXBhcmF0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zZWxlY3QyLnNlcGFyYXRvciB8fCAkLmZuLnNlbGVjdDIuZGVmYXVsdHMuc2VwYXJhdG9yO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qXG4gICAgICAgIENvbnZlcnRzIHNvdXJjZSBmcm9tIHgtZWRpdGFibGUgZm9ybWF0OiB7dmFsdWU6IDEsIHRleHQ6IFwiMVwifSB0b1xuICAgICAgICBzZWxlY3QyIGZvcm1hdDoge2lkOiAxLCB0ZXh0OiBcIjFcIn1cbiAgICAgICAgKi9cbiAgICAgICAgY29udmVydFNvdXJjZTogZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgICAgICBpZigkLmlzQXJyYXkoc291cmNlKSAmJiBzb3VyY2UubGVuZ3RoICYmIHNvdXJjZVswXS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaTxzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoc291cmNlW2ldLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVtpXS5pZCA9IHNvdXJjZVtpXS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbaV0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLiRpbnB1dC5kYXRhKCdzZWxlY3QyJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5zZWxlY3QyKCdkZXN0cm95Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfSk7XG5cbiAgICBDb25zdHJ1Y3Rvci5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dC5kZWZhdWx0cywge1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IHRwbCBcbiAgICAgICAgQGRlZmF1bHQgPGlucHV0IHR5cGU9XCJoaWRkZW5cIj5cbiAgICAgICAgKiovXG4gICAgICAgIHRwbDonPGlucHV0IHR5cGU9XCJoaWRkZW5cIj4nLFxuICAgICAgICAvKipcbiAgICAgICAgQ29uZmlndXJhdGlvbiBvZiBzZWxlY3QyLiBbRnVsbCBsaXN0IG9mIG9wdGlvbnNdKGh0dHA6Ly9pdmF5bmJlcmcuZ2l0aHViLmNvbS9zZWxlY3QyKS5cblxuICAgICAgICBAcHJvcGVydHkgc2VsZWN0MiBcbiAgICAgICAgQHR5cGUgb2JqZWN0XG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovXG4gICAgICAgIHNlbGVjdDI6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBQbGFjZWhvbGRlciBhdHRyaWJ1dGUgb2Ygc2VsZWN0XG5cbiAgICAgICAgQHByb3BlcnR5IHBsYWNlaG9sZGVyIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi9cbiAgICAgICAgcGxhY2Vob2xkZXI6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBTb3VyY2UgZGF0YSBmb3Igc2VsZWN0LiBJdCB3aWxsIGJlIGFzc2lnbmVkIHRvIHNlbGVjdDIgYGRhdGFgIHByb3BlcnR5IGFuZCBrZXB0IGhlcmUganVzdCBmb3IgY29udmVuaWVuY2UuXG4gICAgICAgIFBsZWFzZSBub3RlLCB0aGF0IGZvcm1hdCBpcyBkaWZmZXJlbnQgZnJvbSBzaW1wbGUgYHNlbGVjdGAgaW5wdXQ6IHVzZSAnaWQnIGluc3RlYWQgb2YgJ3ZhbHVlJy5cbiAgICAgICAgRS5nLiBgW3tpZDogMSwgdGV4dDogXCJ0ZXh0MVwifSwge2lkOiAyLCB0ZXh0OiBcInRleHQyXCJ9LCAuLi5dYC5cblxuICAgICAgICBAcHJvcGVydHkgc291cmNlIFxuICAgICAgICBAdHlwZSBhcnJheXxzdHJpbmd8ZnVuY3Rpb25cbiAgICAgICAgQGRlZmF1bHQgbnVsbCAgICAgICAgXG4gICAgICAgICoqL1xuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBTZXBhcmF0b3IgdXNlZCB0byBkaXNwbGF5IHRhZ3MuXG5cbiAgICAgICAgQHByb3BlcnR5IHZpZXdzZXBhcmF0b3IgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAnLCAnICAgICAgICBcbiAgICAgICAgKiovXG4gICAgICAgIHZpZXdzZXBhcmF0b3I6ICcsICdcbiAgICB9KTtcblxuICAgICQuZm4uZWRpdGFibGV0eXBlcy5zZWxlY3QyID0gQ29uc3RydWN0b3I7XG5cbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKipcbiogQ29tYm9kYXRlIC0gMS4wLjVcbiogRHJvcGRvd24gZGF0ZSBhbmQgdGltZSBwaWNrZXIuXG4qIENvbnZlcnRzIHRleHQgaW5wdXQgaW50byBkcm9wZG93bnMgdG8gcGljayBkYXksIG1vbnRoLCB5ZWFyLCBob3VyLCBtaW51dGUgYW5kIHNlY29uZC5cbiogVXNlcyBtb21lbnRqcyBhcyBkYXRldGltZSBsaWJyYXJ5IGh0dHA6Ly9tb21lbnRqcy5jb20uXG4qIEZvciBpMThuIGluY2x1ZGUgY29ycmVzcG9uZGluZyBmaWxlIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3RpbXJ3b29kL21vbWVudC90cmVlL21hc3Rlci9sYW5nIFxuKlxuKiBDb25mdXNpb24gYXQgbm9vbiBhbmQgbWlkbmlnaHQgLSBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS8xMi1ob3VyX2Nsb2NrI0NvbmZ1c2lvbl9hdF9ub29uX2FuZF9taWRuaWdodFxuKiBJbiBjb21ib2RhdGU6IFxuKiAxMjowMCBwbSAtLT4gMTI6MDAgKDI0LWggZm9ybWF0LCBtaWRkYXkpXG4qIDEyOjAwIGFtIC0tPiAwMDowMCAoMjQtaCBmb3JtYXQsIG1pZG5pZ2h0LCBzdGFydCBvZiBkYXkpXG4qIFxuKiBEaWZmZXJzIGZyb20gbW9tZW50anMgcGFyc2UgcnVsZXM6XG4qIDAwOjAwIHBtLCAxMjowMCBwbSAtLT4gMTI6MDAgKDI0LWggZm9ybWF0LCBkYXkgbm90IGNoYW5nZSlcbiogMDA6MDAgYW0sIDEyOjAwIGFtIC0tPiAwMDowMCAoMjQtaCBmb3JtYXQsIGRheSBub3QgY2hhbmdlKVxuKiBcbiogXG4qIEF1dGhvcjogVml0YWxpeSBQb3RhcG92XG4qIFByb2plY3QgcGFnZTogaHR0cDovL2dpdGh1Yi5jb20vdml0YWxldHMvY29tYm9kYXRlXG4qIENvcHlyaWdodCAoYykgMjAxMiBWaXRhbGl5IFBvdGFwb3YuIFJlbGVhc2VkIHVuZGVyIE1JVCBMaWNlbnNlLlxuKiovXG4oZnVuY3Rpb24gKCQpIHtcblxuICAgIHZhciBDb21ib2RhdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLiRlbGVtZW50ID0gJChlbGVtZW50KTtcbiAgICAgICAgaWYoIXRoaXMuJGVsZW1lbnQuaXMoJ2lucHV0JykpIHtcbiAgICAgICAgICAgICQuZXJyb3IoJ0NvbWJvZGF0ZSBzaG91bGQgYmUgYXBwbGllZCB0byBJTlBVVCBlbGVtZW50Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sICQuZm4uY29tYm9kYXRlLmRlZmF1bHRzLCBvcHRpb25zLCB0aGlzLiRlbGVtZW50LmRhdGEoKSk7XG4gICAgICAgIHRoaXMuaW5pdCgpOyAgXG4gICAgIH07XG5cbiAgICBDb21ib2RhdGUucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogQ29tYm9kYXRlLCBcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5tYXAgPSB7XG4gICAgICAgICAgICAgICAgLy9rZXkgICByZWdleHAgICAgbW9tZW50Lm1ldGhvZFxuICAgICAgICAgICAgICAgIGRheTogICAgWydEJywgICAgJ2RhdGUnXSwgXG4gICAgICAgICAgICAgICAgbW9udGg6ICBbJ00nLCAgICAnbW9udGgnXSwgXG4gICAgICAgICAgICAgICAgeWVhcjogICBbJ1knLCAgICAneWVhciddLCBcbiAgICAgICAgICAgICAgICBob3VyOiAgIFsnW0hoXScsICdob3VycyddLFxuICAgICAgICAgICAgICAgIG1pbnV0ZTogWydtJywgICAgJ21pbnV0ZXMnXSwgXG4gICAgICAgICAgICAgICAgc2Vjb25kOiBbJ3MnLCAgICAnc2Vjb25kcyddLFxuICAgICAgICAgICAgICAgIGFtcG06ICAgWydbQWFdJywgJyddIFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kd2lkZ2V0ID0gJCgnPHNwYW4gY2xhc3M9XCJjb21ib2RhdGVcIj48L3NwYW4+JykuaHRtbCh0aGlzLmdldFRlbXBsYXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5pbml0Q29tYm9zKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vdXBkYXRlIG9yaWdpbmFsIGlucHV0IG9uIGNoYW5nZSBcbiAgICAgICAgICAgIHRoaXMuJHdpZGdldC5vbignY2hhbmdlJywgJ3NlbGVjdCcsICQucHJveHkoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQudmFsKHRoaXMuZ2V0VmFsdWUoKSkuY2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGRheXMgY291bnQgaWYgbW9udGggb3IgeWVhciBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbWFydERheXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQoZS50YXJnZXQpLmlzKCcubW9udGgnKSB8fCAkKGUudGFyZ2V0KS5pcygnLnllYXInKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxsQ29tYm8oJ2RheScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiR3aWRnZXQuZmluZCgnc2VsZWN0JykuY3NzKCd3aWR0aCcsICdhdXRvJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGhpZGUgb3JpZ2luYWwgaW5wdXQgYW5kIGluc2VydCB3aWRnZXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuaGlkZSgpLmFmdGVyKHRoaXMuJHdpZGdldCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHNldCBpbml0aWFsIHZhbHVlXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKHRoaXMuJGVsZW1lbnQudmFsKCkgfHwgdGhpcy5vcHRpb25zLnZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgICBSZXBsYWNlIHRva2VucyBpbiB0ZW1wbGF0ZSB3aXRoIDxzZWxlY3Q+IGVsZW1lbnRzIFxuICAgICAgICAqLyAgICAgICAgIFxuICAgICAgICBnZXRUZW1wbGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdHBsID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlO1xuXG4gICAgICAgICAgICAvL2ZpcnN0IHBhc3NcbiAgICAgICAgICAgICQuZWFjaCh0aGlzLm1hcCwgZnVuY3Rpb24oaywgdikge1xuICAgICAgICAgICAgICAgIHYgPSB2WzBdOyBcbiAgICAgICAgICAgICAgICB2YXIgciA9IG5ldyBSZWdFeHAodisnKycpLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHYubGVuZ3RoID4gMSA/IHYuc3Vic3RyaW5nKDEsIDIpIDogdjtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdHBsID0gdHBsLnJlcGxhY2UociwgJ3snK3Rva2VuKyd9Jyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy9yZXBsYWNlIHNwYWNlcyB3aXRoICZuYnNwO1xuICAgICAgICAgICAgdHBsID0gdHBsLnJlcGxhY2UoLyAvZywgJyZuYnNwOycpO1xuXG4gICAgICAgICAgICAvL3NlY29uZCBwYXNzXG4gICAgICAgICAgICAkLmVhY2godGhpcy5tYXAsIGZ1bmN0aW9uKGssIHYpIHtcbiAgICAgICAgICAgICAgICB2ID0gdlswXTtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSB2Lmxlbmd0aCA+IDEgPyB2LnN1YnN0cmluZygxLCAyKSA6IHY7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRwbCA9IHRwbC5yZXBsYWNlKCd7Jyt0b2tlbisnfScsICc8c2VsZWN0IGNsYXNzPVwiJytrKydcIj48L3NlbGVjdD4nKTtcbiAgICAgICAgICAgIH0pOyAgIFxuXG4gICAgICAgICAgICByZXR1cm4gdHBsO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgIEluaXRpYWxpemUgY29tYm9zIHRoYXQgcHJlc2VudHMgaW4gdGVtcGxhdGUgXG4gICAgICAgICovICAgICAgICBcbiAgICAgICAgaW5pdENvbWJvczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIHRoaXMubWFwKSB7XG4gICAgICAgICAgICAgICAgdmFyICRjID0gdGhpcy4kd2lkZ2V0LmZpbmQoJy4nK2spO1xuICAgICAgICAgICAgICAgIC8vIHNldCBwcm9wZXJ0aWVzIGxpa2UgdGhpcy4kZGF5LCB0aGlzLiRtb250aCBldGMuXG4gICAgICAgICAgICAgICAgdGhpc1snJCcra10gPSAkYy5sZW5ndGggPyAkYyA6IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gZmlsbCB3aXRoIGl0ZW1zXG4gICAgICAgICAgICAgICAgdGhpcy5maWxsQ29tYm8oayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgIEZpbGwgY29tYm8gd2l0aCBpdGVtcyBcbiAgICAgICAgKi8gICAgICAgIFxuICAgICAgICBmaWxsQ29tYm86IGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIHZhciAkY29tYm8gPSB0aGlzWyckJytrXTtcbiAgICAgICAgICAgIGlmICghJGNvbWJvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkZWZpbmUgbWV0aG9kIG5hbWUgdG8gZmlsbCBpdGVtcywgZS5nIGBmaWxsRGF5c2BcbiAgICAgICAgICAgIHZhciBmID0gJ2ZpbGwnICsgay5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGsuc2xpY2UoMSk7IFxuICAgICAgICAgICAgdmFyIGl0ZW1zID0gdGhpc1tmXSgpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gJGNvbWJvLnZhbCgpO1xuXG4gICAgICAgICAgICAkY29tYm8uZW1wdHkoKTtcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgJGNvbWJvLmFwcGVuZCgnPG9wdGlvbiB2YWx1ZT1cIicraXRlbXNbaV1bMF0rJ1wiPicraXRlbXNbaV1bMV0rJzwvb3B0aW9uPicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkY29tYm8udmFsKHZhbHVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICAgSW5pdGlhbGl6ZSBpdGVtcyBvZiBjb21ib3MuIEhhbmRsZXMgYGZpcnN0SXRlbWAgb3B0aW9uIFxuICAgICAgICAqL1xuICAgICAgICBmaWxsQ29tbW9uOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXSxcbiAgICAgICAgICAgICAgICByZWxUaW1lO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmZpcnN0SXRlbSA9PT0gJ25hbWUnKSB7XG4gICAgICAgICAgICAgICAgLy9uZWVkIGJvdGggdG8gc3VwcG9ydCBtb21lbnQgdmVyIDwgMiBhbmQgID49IDJcbiAgICAgICAgICAgICAgICByZWxUaW1lID0gbW9tZW50LnJlbGF0aXZlVGltZSB8fCBtb21lbnQubGFuZ0RhdGEoKS5fcmVsYXRpdmVUaW1lOyBcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gdHlwZW9mIHJlbFRpbWVba2V5XSA9PT0gJ2Z1bmN0aW9uJyA/IHJlbFRpbWVba2V5XSgxLCB0cnVlLCBrZXksIGZhbHNlKSA6IHJlbFRpbWVba2V5XTtcbiAgICAgICAgICAgICAgICAvL3Rha2UgbGFzdCBlbnRyeSAoc2VlIG1vbWVudGpzIGxhbmcgZmlsZXMgc3RydWN0dXJlKSBcbiAgICAgICAgICAgICAgICBoZWFkZXIgPSBoZWFkZXIuc3BsaXQoJyAnKS5yZXZlcnNlKClbMF07ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKFsnJywgaGVhZGVyXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYodGhpcy5vcHRpb25zLmZpcnN0SXRlbSA9PT0gJ2VtcHR5Jykge1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKFsnJywgJyddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH0sICBcblxuXG4gICAgICAgIC8qXG4gICAgICAgIGZpbGwgZGF5XG4gICAgICAgICovXG4gICAgICAgIGZpbGxEYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5maWxsQ29tbW9uKCdkJyksIG5hbWUsIGksXG4gICAgICAgICAgICAgICAgdHdvRGlnaXQgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUuaW5kZXhPZignREQnKSAhPT0gLTEsXG4gICAgICAgICAgICAgICAgZGF5c0NvdW50ID0gMzE7XG5cbiAgICAgICAgICAgIC8vIGRldGVjdCBkYXlzIGNvdW50IChkZXBlbmRzIG9uIG1vbnRoIGFuZCB5ZWFyKVxuICAgICAgICAgICAgLy8gb3JpZ2luYWxseSBodHRwczovL2dpdGh1Yi5jb20vdml0YWxldHMvY29tYm9kYXRlL3B1bGwvN1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbWFydERheXMgJiYgdGhpcy4kbW9udGggJiYgdGhpcy4keWVhcikge1xuICAgICAgICAgICAgICAgIHZhciBtb250aCA9IHBhcnNlSW50KHRoaXMuJG1vbnRoLnZhbCgpLCAxMCk7XG4gICAgICAgICAgICAgICAgdmFyIHllYXIgPSBwYXJzZUludCh0aGlzLiR5ZWFyLnZhbCgpLCAxMCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKG1vbnRoKSAmJiAhaXNOYU4oeWVhcikpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF5c0NvdW50ID0gbW9tZW50KFt5ZWFyLCBtb250aF0pLmRheXNJbk1vbnRoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IGRheXNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IHR3b0RpZ2l0ID8gdGhpcy5sZWFkWmVybyhpKSA6IGk7XG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChbaSwgbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zOyAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICBmaWxsIG1vbnRoXG4gICAgICAgICovXG4gICAgICAgIGZpbGxNb250aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLmZpbGxDb21tb24oJ00nKSwgbmFtZSwgaSwgXG4gICAgICAgICAgICAgICAgbG9uZ05hbWVzID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ01NTU0nKSAhPT0gLTEsXG4gICAgICAgICAgICAgICAgc2hvcnROYW1lcyA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCdNTU0nKSAhPT0gLTEsXG4gICAgICAgICAgICAgICAgdHdvRGlnaXQgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUuaW5kZXhPZignTU0nKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IoaT0wOyBpPD0xMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYobG9uZ05hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1yd29vZC9tb21lbnRqcy5jb20vcHVsbC8zNlxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gbW9tZW50KCkuZGF0ZSgxKS5tb250aChpKS5mb3JtYXQoJ01NTU0nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoc2hvcnROYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gbW9tZW50KCkuZGF0ZSgxKS5tb250aChpKS5mb3JtYXQoJ01NTScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZih0d29EaWdpdCkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gdGhpcy5sZWFkWmVybyhpKzEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBpKzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goW2ksIG5hbWVdKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgICAgIH0sICBcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgIGZpbGwgeWVhclxuICAgICAgICAqL1xuICAgICAgICBmaWxsWWVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBbXSwgbmFtZSwgaSwgXG4gICAgICAgICAgICAgICAgbG9uZ05hbWVzID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ1lZWVknKSAhPT0gLTE7XG4gICAgICAgICAgIFxuICAgICAgICAgICAgZm9yKGk9dGhpcy5vcHRpb25zLm1heFllYXI7IGk+PXRoaXMub3B0aW9ucy5taW5ZZWFyOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbG9uZ05hbWVzID8gaSA6IChpKycnKS5zdWJzdHJpbmcoMik7XG4gICAgICAgICAgICAgICAgaXRlbXNbdGhpcy5vcHRpb25zLnllYXJEZXNjZW5kaW5nID8gJ3B1c2gnIDogJ3Vuc2hpZnQnXShbaSwgbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpdGVtcyA9IHRoaXMuZmlsbENvbW1vbigneScpLmNvbmNhdChpdGVtcyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBpdGVtczsgICAgICAgICAgICAgIFxuICAgICAgICB9LCAgICBcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgIGZpbGwgaG91clxuICAgICAgICAqL1xuICAgICAgICBmaWxsSG91cjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLmZpbGxDb21tb24oJ2gnKSwgbmFtZSwgaSxcbiAgICAgICAgICAgICAgICBoMTIgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUuaW5kZXhPZignaCcpICE9PSAtMSxcbiAgICAgICAgICAgICAgICBoMjQgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUuaW5kZXhPZignSCcpICE9PSAtMSxcbiAgICAgICAgICAgICAgICB0d29EaWdpdCA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2hoJykgIT09IC0xLFxuICAgICAgICAgICAgICAgIG1pbiA9IGgxMiA/IDEgOiAwLCBcbiAgICAgICAgICAgICAgICBtYXggPSBoMTIgPyAxMiA6IDIzO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yKGk9bWluOyBpPD1tYXg7IGkrKykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSB0d29EaWdpdCA/IHRoaXMubGVhZFplcm8oaSkgOiBpO1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goW2ksIG5hbWVdKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7ICAgICAgICAgICAgICAgICBcbiAgICAgICAgfSwgICAgXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICBmaWxsIG1pbnV0ZVxuICAgICAgICAqL1xuICAgICAgICBmaWxsTWludXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IHRoaXMuZmlsbENvbW1vbignbScpLCBuYW1lLCBpLFxuICAgICAgICAgICAgICAgIHR3b0RpZ2l0ID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ21tJykgIT09IC0xO1xuXG4gICAgICAgICAgICBmb3IoaT0wOyBpPD01OTsgaSs9IHRoaXMub3B0aW9ucy5taW51dGVTdGVwKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IHR3b0RpZ2l0ID8gdGhpcy5sZWFkWmVybyhpKSA6IGk7XG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChbaSwgbmFtZV0pO1xuICAgICAgICAgICAgfSAgICBcbiAgICAgICAgICAgIHJldHVybiBpdGVtczsgICAgICAgICAgICAgIFxuICAgICAgICB9LCAgXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICBmaWxsIHNlY29uZFxuICAgICAgICAqL1xuICAgICAgICBmaWxsU2Vjb25kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IHRoaXMuZmlsbENvbW1vbigncycpLCBuYW1lLCBpLFxuICAgICAgICAgICAgICAgIHR3b0RpZ2l0ID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ3NzJykgIT09IC0xO1xuXG4gICAgICAgICAgICBmb3IoaT0wOyBpPD01OTsgaSs9IHRoaXMub3B0aW9ucy5zZWNvbmRTdGVwKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IHR3b0RpZ2l0ID8gdGhpcy5sZWFkWmVybyhpKSA6IGk7XG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChbaSwgbmFtZV0pO1xuICAgICAgICAgICAgfSAgICBcbiAgICAgICAgICAgIHJldHVybiBpdGVtczsgICAgICAgICAgICAgIFxuICAgICAgICB9LCAgXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICBmaWxsIGFtcG1cbiAgICAgICAgKi9cbiAgICAgICAgZmlsbEFtcG06IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFtcG1MID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ2EnKSAhPT0gLTEsXG4gICAgICAgICAgICAgICAgYW1wbVUgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUuaW5kZXhPZignQScpICE9PSAtMSwgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpdGVtcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgWydhbScsIGFtcG1MID8gJ2FtJyA6ICdBTSddLFxuICAgICAgICAgICAgICAgICAgICBbJ3BtJywgYW1wbUwgPyAncG0nIDogJ1BNJ11cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB9LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgIC8qXG4gICAgICAgICBSZXR1cm5zIGN1cnJlbnQgZGF0ZSB2YWx1ZSBmcm9tIGNvbWJvcy4gXG4gICAgICAgICBJZiBmb3JtYXQgbm90IHNwZWNpZmllZCAtIGBvcHRpb25zLmZvcm1hdGAgdXNlZC5cbiAgICAgICAgIElmIGZvcm1hdCA9IGBudWxsYCAtIE1vbWVudCBvYmplY3QgcmV0dXJuZWQuXG4gICAgICAgICovXG4gICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgICAgIHZhciBkdCwgdmFsdWVzID0ge30sIFxuICAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIG5vdFNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2dldHRpbmcgc2VsZWN0ZWQgdmFsdWVzICAgIFxuICAgICAgICAgICAgJC5lYWNoKHRoaXMubWFwLCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgICAgICAgICAgaWYoayA9PT0gJ2FtcG0nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRlZiA9IGsgPT09ICdkYXknID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YWx1ZXNba10gPSB0aGF0WyckJytrXSA/IHBhcnNlSW50KHRoYXRbJyQnK2tdLnZhbCgpLCAxMCkgOiBkZWY7IFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKGlzTmFOKHZhbHVlc1trXSkpIHtcbiAgICAgICAgICAgICAgICAgICBub3RTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pZiBhdCBsZWFzdCBvbmUgdmlzaWJsZSBjb21ibyBub3Qgc2VsZWN0ZWQgLSByZXR1cm4gZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICBpZihub3RTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2NvbnZlcnQgaG91cnMgMTJoIC0tPiAyNGggXG4gICAgICAgICAgICBpZih0aGlzLiRhbXBtKSB7XG4gICAgICAgICAgICAgICAgLy8xMjowMCBwbSAtLT4gMTI6MDAgKDI0LWggZm9ybWF0LCBtaWRkYXkpLCAxMjowMCBhbSAtLT4gMDA6MDAgKDI0LWggZm9ybWF0LCBtaWRuaWdodCwgc3RhcnQgb2YgZGF5KVxuICAgICAgICAgICAgICAgIGlmKHZhbHVlcy5ob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuaG91ciA9IHRoaXMuJGFtcG0udmFsKCkgPT09ICdhbScgPyAwIDogMTI7ICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuaG91ciA9IHRoaXMuJGFtcG0udmFsKCkgPT09ICdhbScgPyB2YWx1ZXMuaG91ciA6IHZhbHVlcy5ob3VyKzEyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGR0ID0gbW9tZW50KFt2YWx1ZXMueWVhciwgdmFsdWVzLm1vbnRoLCB2YWx1ZXMuZGF5LCB2YWx1ZXMuaG91ciwgdmFsdWVzLm1pbnV0ZSwgdmFsdWVzLnNlY29uZF0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2hpZ2hsaWdodCBpbnZhbGlkIGRhdGVcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0KGR0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0ID09PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuZm9ybWF0IDogZm9ybWF0O1xuICAgICAgICAgICAgaWYoZm9ybWF0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gZHQuaXNWYWxpZCgpID8gZHQgOiBudWxsOyBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICByZXR1cm4gZHQuaXNWYWxpZCgpID8gZHQuZm9ybWF0KGZvcm1hdCkgOiAnJzsgXG4gICAgICAgICAgICB9ICAgICAgICAgICBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgZHQgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gbW9tZW50KHZhbHVlLCB0aGlzLm9wdGlvbnMuZm9ybWF0KSA6IG1vbWVudCh2YWx1ZSksXG4gICAgICAgICAgICAgICAgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgdmFsdWVzID0ge307XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vZnVuY3Rpb24gdG8gZmluZCBuZWFyZXN0IHZhbHVlIGluIHNlbGVjdCBvcHRpb25zXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXROZWFyZXN0KCRzZWxlY3QsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhID0ge307XG4gICAgICAgICAgICAgICAgJHNlbGVjdC5jaGlsZHJlbignb3B0aW9uJykuZWFjaChmdW5jdGlvbihpLCBvcHQpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0VmFsdWUgPSAkKG9wdCkuYXR0cigndmFsdWUnKSxcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYob3B0VmFsdWUgPT09ICcnKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMob3B0VmFsdWUgLSB2YWx1ZSk7IFxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgZGVsdGEuZGlzdGFuY2UgPT09ICd1bmRlZmluZWQnIHx8IGRpc3RhbmNlIDwgZGVsdGEuZGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhID0ge3ZhbHVlOiBvcHRWYWx1ZSwgZGlzdGFuY2U6IGRpc3RhbmNlfTtcbiAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICB9KTsgXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlbHRhLnZhbHVlO1xuICAgICAgICAgICAgfSAgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoZHQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgLy9yZWFkIHZhbHVlcyBmcm9tIGRhdGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgJC5lYWNoKHRoaXMubWFwLCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGsgPT09ICdhbXBtJykge1xuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1trXSA9IGR0W3ZbMV1dKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZih0aGlzLiRhbXBtKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vMTI6MDAgcG0gLS0+IDEyOjAwICgyNC1oIGZvcm1hdCwgbWlkZGF5KSwgMTI6MDAgYW0gLS0+IDAwOjAwICgyNC1oIGZvcm1hdCwgbWlkbmlnaHQsIHN0YXJ0IG9mIGRheSlcbiAgICAgICAgICAgICAgICAgICAgaWYodmFsdWVzLmhvdXIgPj0gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5hbXBtID0gJ3BtJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHZhbHVlcy5ob3VyID4gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuaG91ciAtPSAxMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5hbXBtID0gJ2FtJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHZhbHVlcy5ob3VyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmhvdXIgPSAxMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAkLmVhY2godmFsdWVzLCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vY2FsbCB2YWwoKSBmb3IgZWFjaCBleGlzdGluZyBjb21ibywgZS5nLiB0aGlzLiRob3VyLnZhbCgpXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoYXRbJyQnK2tdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoayA9PT0gJ21pbnV0ZScgJiYgdGhhdC5vcHRpb25zLm1pbnV0ZVN0ZXAgPiAxICYmIHRoYXQub3B0aW9ucy5yb3VuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnZXROZWFyZXN0KHRoYXRbJyQnK2tdLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihrID09PSAnc2Vjb25kJyAmJiB0aGF0Lm9wdGlvbnMuc2Vjb25kU3RlcCA+IDEgJiYgdGhhdC5vcHRpb25zLnJvdW5kVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGdldE5lYXJlc3QodGhhdFsnJCcra10sIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdFsnJCcra10udmFsKHYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZGF5cyBjb3VudFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21hcnREYXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsbENvbWJvKCdkYXknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQudmFsKGR0LmZvcm1hdCh0aGlzLm9wdGlvbnMuZm9ybWF0KSkuY2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICAgaGlnaGxpZ2h0IGNvbWJvcyBpZiBkYXRlIGlzIGludmFsaWRcbiAgICAgICAgKi9cbiAgICAgICAgaGlnaGxpZ2h0OiBmdW5jdGlvbihkdCkge1xuICAgICAgICAgICAgaWYoIWR0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5lcnJvckNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHdpZGdldC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZXJyb3JDbGFzcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy9zdG9yZSBvcmlnaW5hbCBib3JkZXIgY29sb3JcbiAgICAgICAgICAgICAgICAgICAgaWYoIXRoaXMuYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSB0aGlzLiR3aWRnZXQuZmluZCgnc2VsZWN0JykuY3NzKCdib3JkZXItY29sb3InKTsgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kd2lkZ2V0LmZpbmQoJ3NlbGVjdCcpLmNzcygnYm9yZGVyLWNvbG9yJywgJ3JlZCcpO1xuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5lcnJvckNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHdpZGdldC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZXJyb3JDbGFzcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kd2lkZ2V0LmZpbmQoJ3NlbGVjdCcpLmNzcygnYm9yZGVyLWNvbG9yJywgdGhpcy5ib3JkZXJDb2xvcik7XG4gICAgICAgICAgICAgICAgfSAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBsZWFkWmVybzogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIHYgPD0gOSA/ICcwJyArIHYgOiB2OyBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kd2lkZ2V0LnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVEYXRhKCdjb21ib2RhdGUnKS5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vdG9kbzogY2xlYXIgbWV0aG9kICAgICAgICBcbiAgICB9O1xuXG4gICAgJC5mbi5jb21ib2RhdGUgPSBmdW5jdGlvbiAoIG9wdGlvbiApIHtcbiAgICAgICAgdmFyIGQsIGFyZ3MgPSBBcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICBhcmdzLnNoaWZ0KCk7XG5cbiAgICAgICAgLy9nZXRWYWx1ZSByZXR1cm5zIGRhdGUgYXMgc3RyaW5nIC8gb2JqZWN0IChub3QgalF1ZXJ5IG9iamVjdClcbiAgICAgICAgaWYob3B0aW9uID09PSAnZ2V0VmFsdWUnICYmIHRoaXMubGVuZ3RoICYmIChkID0gdGhpcy5lcSgwKS5kYXRhKCdjb21ib2RhdGUnKSkpIHtcbiAgICAgICAgICByZXR1cm4gZC5nZXRWYWx1ZS5hcHBseShkLCBhcmdzKTtcbiAgICAgICAgfSAgICAgICAgXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXG4gICAgICAgICAgICBkYXRhID0gJHRoaXMuZGF0YSgnY29tYm9kYXRlJyksXG4gICAgICAgICAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb247XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5kYXRhKCdjb21ib2RhdGUnLCAoZGF0YSA9IG5ldyBDb21ib2RhdGUodGhpcywgb3B0aW9ucykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnICYmIHR5cGVvZiBkYXRhW29wdGlvbl0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGRhdGFbb3B0aW9uXS5hcHBseShkYXRhLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTsgIFxuICAgIFxuICAgICQuZm4uY29tYm9kYXRlLmRlZmF1bHRzID0ge1xuICAgICAgICAgLy9pbiB0aGlzIGZvcm1hdCB2YWx1ZSBzdG9yZWQgaW4gb3JpZ2luYWwgaW5wdXRcbiAgICAgICAgZm9ybWF0OiAnREQtTU0tWVlZWSBISDptbScsICAgICAgXG4gICAgICAgIC8vaW4gdGhpcyBmb3JtYXQgaXRlbXMgaW4gZHJvcGRvd25zIGFyZSBkaXNwbGF5ZWRcbiAgICAgICAgdGVtcGxhdGU6ICdEIC8gTU1NIC8gWVlZWSAgIEggOiBtbScsXG4gICAgICAgIC8vaW5pdGlhbCB2YWx1ZSwgY2FuIGJlIGBuZXcgRGF0ZSgpYCAgICBcbiAgICAgICAgdmFsdWU6IG51bGwsICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgbWluWWVhcjogMTk3MCxcbiAgICAgICAgbWF4WWVhcjogMjAxNSxcbiAgICAgICAgeWVhckRlc2NlbmRpbmc6IHRydWUsXG4gICAgICAgIG1pbnV0ZVN0ZXA6IDUsXG4gICAgICAgIHNlY29uZFN0ZXA6IDEsXG4gICAgICAgIGZpcnN0SXRlbTogJ2VtcHR5JywgLy8nbmFtZScsICdlbXB0eScsICdub25lJ1xuICAgICAgICBlcnJvckNsYXNzOiBudWxsLFxuICAgICAgICByb3VuZFRpbWU6IHRydWUsIC8vIHdoZXRoZXIgdG8gcm91bmQgbWludXRlcyBhbmQgc2Vjb25kcyBpZiBzdGVwID4gMVxuICAgICAgICBzbWFydERheXM6IGZhbHNlIC8vIHdoZXRoZXIgZGF5cyBpbiBjb21ibyBkZXBlbmQgb24gc2VsZWN0ZWQgbW9udGg6IDMxLCAzMCwgMjhcbiAgICB9O1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcbi8qKlxuQ29tYm9kYXRlIGlucHV0IC0gZHJvcGRvd24gZGF0ZSBhbmQgdGltZSBwaWNrZXIuICAgIFxuQmFzZWQgb24gW2NvbWJvZGF0ZV0oaHR0cDovL3ZpdGFsZXRzLmdpdGh1Yi5jb20vY29tYm9kYXRlKSBwbHVnaW4gKGluY2x1ZGVkKS4gVG8gdXNlIGl0IHlvdSBzaG91bGQgbWFudWFsbHkgaW5jbHVkZSBbbW9tZW50anNdKGh0dHA6Ly9tb21lbnRqcy5jb20pLlxuXG4gICAgPHNjcmlwdCBzcmM9XCJqcy9tb21lbnQubWluLmpzXCI+PC9zY3JpcHQ+XG4gICBcbkFsbG93cyB0byBpbnB1dDpcblxuKiBvbmx5IGRhdGVcbiogb25seSB0aW1lIFxuKiBib3RoIGRhdGUgYW5kIHRpbWUgIFxuXG5QbGVhc2Ugbm90ZSwgdGhhdCBmb3JtYXQgaXMgdGFrZW4gZnJvbSBtb21lbnRqcyBhbmQgKipub3QgY29tcGF0aWJsZSoqIHdpdGggYm9vdHN0cmFwLWRhdGVwaWNrZXIgLyBqcXVlcnkgVUkgZGF0ZXBpY2tlci4gIFxuSW50ZXJuYWxseSB2YWx1ZSBzdG9yZWQgYXMgYG1vbWVudGpzYCBvYmplY3QuIFxuXG5AY2xhc3MgY29tYm9kYXRlXG5AZXh0ZW5kcyBhYnN0cmFjdGlucHV0XG5AZmluYWxcbkBzaW5jZSAxLjQuMFxuQGV4YW1wbGVcbjxhIGhyZWY9XCIjXCIgaWQ9XCJkb2JcIiBkYXRhLXR5cGU9XCJjb21ib2RhdGVcIiBkYXRhLXBrPVwiMVwiIGRhdGEtdXJsPVwiL3Bvc3RcIiBkYXRhLXZhbHVlPVwiMTk4NC0wNS0xNVwiIGRhdGEtdGl0bGU9XCJTZWxlY3QgZGF0ZVwiPjwvYT5cbjxzY3JpcHQ+XG4kKGZ1bmN0aW9uKCl7XG4gICAgJCgnI2RvYicpLmVkaXRhYmxlKHtcbiAgICAgICAgZm9ybWF0OiAnWVlZWS1NTS1ERCcsICAgIFxuICAgICAgICB2aWV3Zm9ybWF0OiAnREQuTU0uWVlZWScsICAgIFxuICAgICAgICB0ZW1wbGF0ZTogJ0QgLyBNTU1NIC8gWVlZWScsICAgIFxuICAgICAgICBjb21ib2RhdGU6IHtcbiAgICAgICAgICAgICAgICBtaW5ZZWFyOiAyMDAwLFxuICAgICAgICAgICAgICAgIG1heFllYXI6IDIwMTUsXG4gICAgICAgICAgICAgICAgbWludXRlU3RlcDogMVxuICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuPC9zY3JpcHQ+XG4qKi9cblxuLypnbG9iYWwgbW9tZW50Ki9cblxuKGZ1bmN0aW9uICgkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgXG4gICAgdmFyIENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCdjb21ib2RhdGUnLCBvcHRpb25zLCBDb25zdHJ1Y3Rvci5kZWZhdWx0cyk7XG4gICAgICAgIFxuICAgICAgICAvL2J5IGRlZmF1bHQgdmlld2Zvcm1hdCBlcXVhbHMgdG8gZm9ybWF0XG4gICAgICAgIGlmKCF0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnZpZXdmb3JtYXQgPSB0aGlzLm9wdGlvbnMuZm9ybWF0O1xuICAgICAgICB9ICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIC8vdHJ5IHBhcnNlIGNvbWJvZGF0ZSBjb25maWcgZGVmaW5lZCBhcyBqc29uIHN0cmluZyBpbiBkYXRhLWNvbWJvZGF0ZVxuICAgICAgICBvcHRpb25zLmNvbWJvZGF0ZSA9ICQuZm4uZWRpdGFibGV1dGlscy50cnlQYXJzZUpzb24ob3B0aW9ucy5jb21ib2RhdGUsIHRydWUpO1xuXG4gICAgICAgIC8vb3ZlcnJpZGluZyBjb21ib2RhdGUgY29uZmlnIChhcyBieSBkZWZhdWx0IGpRdWVyeSBleHRlbmQoKSBpcyBub3QgcmVjdXJzaXZlKVxuICAgICAgICB0aGlzLm9wdGlvbnMuY29tYm9kYXRlID0gJC5leHRlbmQoe30sIENvbnN0cnVjdG9yLmRlZmF1bHRzLmNvbWJvZGF0ZSwgb3B0aW9ucy5jb21ib2RhdGUsIHtcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5vcHRpb25zLmZvcm1hdCxcbiAgICAgICAgICAgIHRlbXBsYXRlOiB0aGlzLm9wdGlvbnMudGVtcGxhdGVcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgICQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KENvbnN0cnVjdG9yLCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dCk7ICAgIFxuICAgIFxuICAgICQuZXh0ZW5kKENvbnN0cnVjdG9yLnByb3RvdHlwZSwge1xuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LmNvbWJvZGF0ZSh0aGlzLm9wdGlvbnMuY29tYm9kYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBpZigkLmZuLmVkaXRhYmxlZm9ybS5lbmdpbmUgPT09ICdiczMnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQuc2libGluZ3MoKS5maW5kKCdzZWxlY3QnKS5hZGRDbGFzcygnZm9ybS1jb250cm9sJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5pbnB1dGNsYXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQuc2libGluZ3MoKS5maW5kKCdzZWxlY3QnKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuaW5wdXRjbGFzcyk7XG4gICAgICAgICAgICB9ICAgICAgICAgICAgXG4gICAgICAgICAgICAvL1wiY2xlYXJcIiBsaW5rXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmNsZWFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2xlYXIgPSAkKCc8YSBocmVmPVwiI1wiPjwvYT4nKS5odG1sKHRoaXMub3B0aW9ucy5jbGVhcikuY2xpY2soJC5wcm94eShmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuJHRwbC5wYXJlbnQoKS5hcHBlbmQoJCgnPGRpdiBjbGFzcz1cImVkaXRhYmxlLWNsZWFyXCI+JykuYXBwZW5kKHRoaXMuJGNsZWFyKSk7ICBcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAqLyAgICAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgdmFsdWUyaHRtbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdmFsdWUgPyB2YWx1ZS5mb3JtYXQodGhpcy5vcHRpb25zLnZpZXdmb3JtYXQpIDogJyc7XG4gICAgICAgICAgICAvLyQoZWxlbWVudCkudGV4dCh0ZXh0KTtcbiAgICAgICAgICAgIENvbnN0cnVjdG9yLnN1cGVyY2xhc3MudmFsdWUyaHRtbC5jYWxsKHRoaXMsIHRleHQsIGVsZW1lbnQpOyAgXG4gICAgICAgIH0sXG5cbiAgICAgICAgaHRtbDJ2YWx1ZTogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwgPyBtb21lbnQoaHRtbCwgdGhpcy5vcHRpb25zLnZpZXdmb3JtYXQpIDogbnVsbDtcbiAgICAgICAgfSwgICBcbiAgICAgICAgXG4gICAgICAgIHZhbHVlMnN0cjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/IHZhbHVlLmZvcm1hdCh0aGlzLm9wdGlvbnMuZm9ybWF0KSA6ICcnO1xuICAgICAgIH0sIFxuICAgICAgIFxuICAgICAgIHN0cjJ2YWx1ZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgIHJldHVybiBzdHIgPyBtb21lbnQoc3RyLCB0aGlzLm9wdGlvbnMuZm9ybWF0KSA6IG51bGw7XG4gICAgICAgfSwgXG4gICAgICAgXG4gICAgICAgdmFsdWUyc3VibWl0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTJzdHIodmFsdWUpO1xuICAgICAgIH0sICAgICAgICAgICAgICAgICAgICBcblxuICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICB0aGlzLiRpbnB1dC5jb21ib2RhdGUoJ3NldFZhbHVlJywgdmFsdWUpO1xuICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgIGlucHV0MnZhbHVlOiBmdW5jdGlvbigpIHsgXG4gICAgICAgICAgIHJldHVybiB0aGlzLiRpbnB1dC5jb21ib2RhdGUoJ2dldFZhbHVlJywgbnVsbCk7XG4gICAgICAgfSwgICAgICAgXG4gICAgICAgXG4gICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICB0aGlzLiRpbnB1dC5zaWJsaW5ncygnLmNvbWJvZGF0ZScpLmZpbmQoJ3NlbGVjdCcpLmVxKDApLmZvY3VzKCk7XG4gICAgICAgfSxcbiAgICAgICBcbiAgICAgICAvKlxuICAgICAgIGNsZWFyOiAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy4kaW5wdXQuZGF0YSgnZGF0ZXBpY2tlcicpLmRhdGUgPSBudWxsO1xuICAgICAgICAgIHRoaXMuJGlucHV0LmZpbmQoJy5hY3RpdmUnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgfSxcbiAgICAgICAqL1xuICAgICAgIFxuICAgICAgIGF1dG9zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICBcbiAgICAgICB9XG5cbiAgICB9KTtcbiAgICBcbiAgICBDb25zdHJ1Y3Rvci5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dC5kZWZhdWx0cywge1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IHRwbCBcbiAgICAgICAgQGRlZmF1bHQgPGlucHV0IHR5cGU9XCJ0ZXh0XCI+XG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICB0cGw6JzxpbnB1dCB0eXBlPVwidGV4dFwiPicsXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgaW5wdXRjbGFzcyBcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgaW5wdXRjbGFzczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIEZvcm1hdCB1c2VkIGZvciBzZW5kaW5nIHZhbHVlIHRvIHNlcnZlci4gQWxzbyBhcHBsaWVkIHdoZW4gY29udmVydGluZyBkYXRlIGZyb20gPGNvZGU+ZGF0YS12YWx1ZTwvY29kZT4gYXR0cmlidXRlLjxicj5cbiAgICAgICAgU2VlIGxpc3Qgb2YgdG9rZW5zIGluIFttb21lbnRqcyBkb2NzXShodHRwOi8vbW9tZW50anMuY29tL2RvY3MvIy9wYXJzaW5nL3N0cmluZy1mb3JtYXQpICBcbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBmb3JtYXQgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCBZWVlZLU1NLUREXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBmb3JtYXQ6J1lZWVktTU0tREQnLFxuICAgICAgICAvKipcbiAgICAgICAgRm9ybWF0IHVzZWQgZm9yIGRpc3BsYXlpbmcgZGF0ZS4gQWxzbyBhcHBsaWVkIHdoZW4gY29udmVydGluZyBkYXRlIGZyb20gZWxlbWVudCdzIHRleHQgb24gaW5pdC4gICBcbiAgICAgICAgSWYgbm90IHNwZWNpZmllZCBlcXVhbHMgdG8gYGZvcm1hdGAuXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgdmlld2Zvcm1hdCBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovICAgICAgICAgIFxuICAgICAgICB2aWV3Zm9ybWF0OiBudWxsLCAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBUZW1wbGF0ZSB1c2VkIGZvciBkaXNwbGF5aW5nIGRyb3Bkb3ducy5cbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSB0ZW1wbGF0ZSBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IEQgLyBNTU0gLyBZWVlZXG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgdGVtcGxhdGU6ICdEIC8gTU1NIC8gWVlZWScsICBcbiAgICAgICAgLyoqXG4gICAgICAgIENvbmZpZ3VyYXRpb24gb2YgY29tYm9kYXRlLlxuICAgICAgICBGdWxsIGxpc3Qgb2Ygb3B0aW9uczogaHR0cDovL3ZpdGFsZXRzLmdpdGh1Yi5jb20vY29tYm9kYXRlLyNkb2NzXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgY29tYm9kYXRlIFxuICAgICAgICBAdHlwZSBvYmplY3RcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi9cbiAgICAgICAgY29tYm9kYXRlOiBudWxsXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICAobm90IGltcGxlbWVudGVkIHlldClcbiAgICAgICAgVGV4dCBzaG93biBhcyBjbGVhciBkYXRlIGJ1dHRvbi4gXG4gICAgICAgIElmIDxjb2RlPmZhbHNlPC9jb2RlPiBjbGVhciBidXR0b24gd2lsbCBub3QgYmUgcmVuZGVyZWQuXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgY2xlYXIgXG4gICAgICAgIEB0eXBlIGJvb2xlYW58c3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICd4IGNsZWFyJyAgICAgICAgIFxuICAgICAgICAqL1xuICAgICAgICAvL2NsZWFyOiAnJnRpbWVzOyBjbGVhcidcbiAgICB9KTsgICBcblxuICAgICQuZm4uZWRpdGFibGV0eXBlcy5jb21ib2RhdGUgPSBDb25zdHJ1Y3RvcjtcblxufSh3aW5kb3cualF1ZXJ5KSk7XG5cbi8qXG5FZGl0YWJsZWZvcm0gYmFzZWQgb24gVHdpdHRlciBCb290c3RyYXAgM1xuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFxuICAgIC8vc3RvcmUgcGFyZW50IG1ldGhvZHNcbiAgICB2YXIgcEluaXRJbnB1dCA9ICQuZm4uZWRpdGFibGVmb3JtLkNvbnN0cnVjdG9yLnByb3RvdHlwZS5pbml0SW5wdXQ7XG4gICAgXG4gICAgJC5leHRlbmQoJC5mbi5lZGl0YWJsZWZvcm0uQ29uc3RydWN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGluaXRUZW1wbGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLiRmb3JtID0gJCgkLmZuLmVkaXRhYmxlZm9ybS50ZW1wbGF0ZSk7IFxuICAgICAgICAgICAgdGhpcy4kZm9ybS5maW5kKCcuY29udHJvbC1ncm91cCcpLmFkZENsYXNzKCdmb3JtLWdyb3VwJyk7XG4gICAgICAgICAgICB0aGlzLiRmb3JtLmZpbmQoJy5lZGl0YWJsZS1lcnJvci1ibG9jaycpLmFkZENsYXNzKCdoZWxwLWJsb2NrJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRJbnB1dDogZnVuY3Rpb24oKSB7ICBcbiAgICAgICAgICAgIHBJbml0SW5wdXQuYXBwbHkodGhpcyk7XG5cbiAgICAgICAgICAgIC8vZm9yIGJzMyBzZXQgZGVmYXVsdCBjbGFzcyBgaW5wdXQtc21gIHRvIHN0YW5kYXJkIGlucHV0c1xuICAgICAgICAgICAgdmFyIGVtcHR5SW5wdXRDbGFzcyA9IHRoaXMuaW5wdXQub3B0aW9ucy5pbnB1dGNsYXNzID09PSBudWxsIHx8IHRoaXMuaW5wdXQub3B0aW9ucy5pbnB1dGNsYXNzID09PSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0Q2xhc3MgPSAnaW5wdXQtc20nO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2JzMyBhZGQgYGZvcm0tY29udHJvbGAgY2xhc3MgdG8gc3RhbmRhcmQgaW5wdXRzXG4gICAgICAgICAgICB2YXIgc3RkdHlwZXMgPSAndGV4dCxzZWxlY3QsdGV4dGFyZWEscGFzc3dvcmQsZW1haWwsdXJsLHRlbCxudW1iZXIscmFuZ2UsdGltZSx0eXBlYWhlYWRqcycuc3BsaXQoJywnKTsgXG4gICAgICAgICAgICBpZih+JC5pbkFycmF5KHRoaXMuaW5wdXQudHlwZSwgc3RkdHlwZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC4kaW5wdXQuYWRkQ2xhc3MoJ2Zvcm0tY29udHJvbCcpO1xuICAgICAgICAgICAgICAgIGlmKGVtcHR5SW5wdXRDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0Lm9wdGlvbnMuaW5wdXRjbGFzcyA9IGRlZmF1bHRDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC4kaW5wdXQuYWRkQ2xhc3MoZGVmYXVsdENsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICAgICAgICAgICAgIFxuICAgICAgICBcbiAgICAgICAgICAgIC8vYXBwbHkgYnMzIHNpemUgY2xhc3MgYWxzbyB0byBidXR0b25zICh0byBmaXQgc2l6ZSBvZiBjb250cm9sKVxuICAgICAgICAgICAgdmFyICRidG4gPSB0aGlzLiRmb3JtLmZpbmQoJy5lZGl0YWJsZS1idXR0b25zJyk7XG4gICAgICAgICAgICB2YXIgY2xhc3NlcyA9IGVtcHR5SW5wdXRDbGFzcyA/IFtkZWZhdWx0Q2xhc3NdIDogdGhpcy5pbnB1dC5vcHRpb25zLmlucHV0Y2xhc3Muc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBgYnRuLXNtYCBpcyBkZWZhdWx0IG5vd1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgaWYoY2xhc3Nlc1tpXS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQtc20nKSB7IFxuICAgICAgICAgICAgICAgICAgICAkYnRuLmZpbmQoJ2J1dHRvbicpLmFkZENsYXNzKCdidG4tc20nKTsgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmKGNsYXNzZXNbaV0udG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0LWxnJykge1xuICAgICAgICAgICAgICAgICAgICAkYnRuLmZpbmQoJ2J1dHRvbicpLnJlbW92ZUNsYXNzKCdidG4tc20nKS5hZGRDbGFzcygnYnRuLWxnJyk7IFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pOyAgICBcbiAgICBcbiAgICAvL2J1dHRvbnNcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5idXR0b25zID0gXG4gICAgICAnPGJ1dHRvbiB0eXBlPVwic3VibWl0XCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgYnRuLXNtIGVkaXRhYmxlLXN1Ym1pdFwiPicrXG4gICAgICAgICc8aSBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tb2tcIj48L2k+JytcbiAgICAgICc8L2J1dHRvbj4nK1xuICAgICAgJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSBlZGl0YWJsZS1jYW5jZWxcIj4nK1xuICAgICAgICAnPGkgY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLXJlbW92ZVwiPjwvaT4nK1xuICAgICAgJzwvYnV0dG9uPic7ICAgICAgICAgXG4gICAgXG4gICAgLy9lcnJvciBjbGFzc2VzXG4gICAgJC5mbi5lZGl0YWJsZWZvcm0uZXJyb3JHcm91cENsYXNzID0gJ2hhcy1lcnJvcic7XG4gICAgJC5mbi5lZGl0YWJsZWZvcm0uZXJyb3JCbG9ja0NsYXNzID0gbnVsbDsgIFxuICAgIC8vZW5naW5lXG4gICAgJC5mbi5lZGl0YWJsZWZvcm0uZW5naW5lID0gJ2JzMyc7ICBcbn0od2luZG93LmpRdWVyeSkpO1xuLyoqXG4qIEVkaXRhYmxlIFBvcG92ZXIzIChmb3IgQm9vdHN0cmFwIDMpIFxuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogcmVxdWlyZXMgYm9vdHN0cmFwLXBvcG92ZXIuanNcbiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vZXh0ZW5kIG1ldGhvZHNcbiAgICAkLmV4dGVuZCgkLmZuLmVkaXRhYmxlQ29udGFpbmVyLlBvcHVwLnByb3RvdHlwZSwge1xuICAgICAgICBjb250YWluZXJOYW1lOiAncG9wb3ZlcicsXG4gICAgICAgIGNvbnRhaW5lckRhdGFOYW1lOiAnYnMucG9wb3ZlcicsXG4gICAgICAgIGlubmVyQ3NzOiAnLnBvcG92ZXItY29udGVudCcsXG4gICAgICAgIGRlZmF1bHRzOiAkLmZuLnBvcG92ZXIuQ29uc3RydWN0b3IuREVGQVVMVFMsXG5cbiAgICAgICAgaW5pdENvbnRhaW5lcjogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICQuZXh0ZW5kKHRoaXMuY29udGFpbmVyT3B0aW9ucywge1xuICAgICAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnICcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IHRoaXMuZGVmYXVsdHMudGVtcGxhdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2FzIHRlbXBsYXRlIHByb3BlcnR5IGlzIHVzZWQgaW4gaW5wdXRzLCBoaWRlIGl0IGZyb20gcG9wb3ZlclxuICAgICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgICBpZih0aGlzLiRlbGVtZW50LmRhdGEoJ3RlbXBsYXRlJykpIHtcbiAgICAgICAgICAgICAgIHQgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ3RlbXBsYXRlJyk7XG4gICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZURhdGEoJ3RlbXBsYXRlJyk7ICBcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuY2FsbCh0aGlzLmNvbnRhaW5lck9wdGlvbnMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZih0KSB7XG4gICAgICAgICAgICAgICAvL3Jlc3RvcmUgZGF0YSgndGVtcGxhdGUnKVxuICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5kYXRhKCd0ZW1wbGF0ZScsIHQpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgXG4gICAgICAgIFxuICAgICAgICAvKiBzaG93ICovXG4gICAgICAgIGlubmVyU2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsKCdzaG93Jyk7ICAgICAgICAgICAgICAgIFxuICAgICAgICB9LCAgXG4gICAgICAgIFxuICAgICAgICAvKiBoaWRlICovXG4gICAgICAgIGlubmVySGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsKCdoaWRlJyk7ICAgICAgIFxuICAgICAgICB9LCBcbiAgICAgICAgXG4gICAgICAgIC8qIGRlc3Ryb3kgKi9cbiAgICAgICAgaW5uZXJEZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbCgnZGVzdHJveScpO1xuICAgICAgICB9LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHNldENvbnRhaW5lck9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIoKS5vcHRpb25zW2tleV0gPSB2YWx1ZTsgXG4gICAgICAgIH0sICAgICAgICAgICAgICAgXG5cbiAgICAgICAgLyoqXG4gICAgICAgICogbW92ZSBwb3BvdmVyIHRvIG5ldyBwb3NpdGlvbi4gVGhpcyBmdW5jdGlvbiBtYWlubHkgY29waWVkIGZyb20gYm9vdHN0cmFwLXBvcG92ZXIuXG4gICAgICAgICovXG4gICAgICAgIC8qanNoaW50IGxheGNvbW1hOiB0cnVlLCBlcWVxZXE6IGZhbHNlKi9cbiAgICAgICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHsgXG5cbiAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8qICAgIFxuICAgICAgICAgICAgICAgIHZhciAkdGlwID0gdGhpcy50aXAoKVxuICAgICAgICAgICAgICAgICwgaW5zaWRlXG4gICAgICAgICAgICAgICAgLCBwb3NcbiAgICAgICAgICAgICAgICAsIGFjdHVhbFdpZHRoXG4gICAgICAgICAgICAgICAgLCBhY3R1YWxIZWlnaHRcbiAgICAgICAgICAgICAgICAsIHBsYWNlbWVudFxuICAgICAgICAgICAgICAgICwgdHBcbiAgICAgICAgICAgICAgICAsIHRwdFxuICAgICAgICAgICAgICAgICwgdHBiXG4gICAgICAgICAgICAgICAgLCB0cGxcbiAgICAgICAgICAgICAgICAsIHRwcjtcblxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IHR5cGVvZiB0aGlzLm9wdGlvbnMucGxhY2VtZW50ID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucGxhY2VtZW50LmNhbGwodGhpcywgJHRpcFswXSwgdGhpcy4kZWxlbWVudFswXSkgOlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICBpbnNpZGUgPSAvaW4vLnRlc3QocGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICR0aXBcbiAgICAgICAgICAgICAgLy8gIC5kZXRhY2goKVxuICAgICAgICAgICAgICAvL3ZpdGFsZXRzOiByZW1vdmUgYW55IHBsYWNlbWVudCBjbGFzcyBiZWNhdXNlIG90aGVyd2lzZSB0aGV5IGRvbnQgaW5mbHVlbmNlIG9uIHJlLXBvc2l0aW9uaW5nIG9mIHZpc2libGUgcG9wb3ZlclxuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygndG9wIHJpZ2h0IGJvdHRvbSBsZWZ0JylcbiAgICAgICAgICAgICAgICAuY3NzKHsgdG9wOiAwLCBsZWZ0OiAwLCBkaXNwbGF5OiAnYmxvY2snIH0pO1xuICAgICAgICAgICAgICAvLyAgLmluc2VydEFmdGVyKHRoaXMuJGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcG9zID0gdGhpcy5nZXRQb3NpdGlvbihpbnNpZGUpO1xuXG4gICAgICAgICAgICAgICAgYWN0dWFsV2lkdGggPSAkdGlwWzBdLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIGFjdHVhbEhlaWdodCA9ICR0aXBbMF0ub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gaW5zaWRlID8gcGxhY2VtZW50LnNwbGl0KCcgJylbMV0gOiBwbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICB0cGIgPSB7dG9wOiBwb3MudG9wICsgcG9zLmhlaWdodCwgbGVmdDogcG9zLmxlZnQgKyBwb3Mud2lkdGggLyAyIC0gYWN0dWFsV2lkdGggLyAyfTtcbiAgICAgICAgICAgICAgICB0cHQgPSB7dG9wOiBwb3MudG9wIC0gYWN0dWFsSGVpZ2h0LCBsZWZ0OiBwb3MubGVmdCArIHBvcy53aWR0aCAvIDIgLSBhY3R1YWxXaWR0aCAvIDJ9O1xuICAgICAgICAgICAgICAgIHRwbCA9IHt0b3A6IHBvcy50b3AgKyBwb3MuaGVpZ2h0IC8gMiAtIGFjdHVhbEhlaWdodCAvIDIsIGxlZnQ6IHBvcy5sZWZ0IC0gYWN0dWFsV2lkdGh9O1xuICAgICAgICAgICAgICAgIHRwciA9IHt0b3A6IHBvcy50b3AgKyBwb3MuaGVpZ2h0IC8gMiAtIGFjdHVhbEhlaWdodCAvIDIsIGxlZnQ6IHBvcy5sZWZ0ICsgcG9zLndpZHRofTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAocGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRwYi50b3AgKyBhY3R1YWxIZWlnaHQpID4gKCQod2luZG93KS5zY3JvbGxUb3AoKSArICQod2luZG93KS5oZWlnaHQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHB0LnRvcCA+ICQod2luZG93KS5zY3JvbGxUb3AoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAndG9wJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCh0cHIubGVmdCArIGFjdHVhbFdpZHRoKSA8ICgkKHdpbmRvdykuc2Nyb2xsTGVmdCgpICsgJCh3aW5kb3cpLndpZHRoKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0cGwubGVmdCA+ICQod2luZG93KS5zY3JvbGxMZWZ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHB0LnRvcCA8ICQod2luZG93KS5zY3JvbGxUb3AoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodHBiLnRvcCArIGFjdHVhbEhlaWdodCkgPCAoJCh3aW5kb3cpLnNjcm9sbFRvcCgpICsgJCh3aW5kb3cpLmhlaWdodCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAnYm90dG9tJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCh0cHIubGVmdCArIGFjdHVhbFdpZHRoKSA8ICgkKHdpbmRvdykuc2Nyb2xsTGVmdCgpICsgJCh3aW5kb3cpLndpZHRoKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0cGwubGVmdCA+ICQod2luZG93KS5zY3JvbGxMZWZ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRwbC5sZWZ0IDwgJCh3aW5kb3cpLnNjcm9sbExlZnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodHByLmxlZnQgKyBhY3R1YWxXaWR0aCkgPCAoJCh3aW5kb3cpLnNjcm9sbExlZnQoKSArICQod2luZG93KS53aWR0aCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHB0LnRvcCA+ICQod2luZG93KS5zY3JvbGxUb3AoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAndG9wJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRwdC50b3AgPiAkKHdpbmRvdykuc2Nyb2xsVG9wKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0cHIubGVmdCArIGFjdHVhbFdpZHRoKSA+ICgkKHdpbmRvdykuc2Nyb2xsTGVmdCgpICsgJCh3aW5kb3cpLndpZHRoKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRwbC5sZWZ0ID4gJCh3aW5kb3cpLnNjcm9sbExlZnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0cHQudG9wID4gJCh3aW5kb3cpLnNjcm9sbFRvcCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICd0b3AnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHB0LnRvcCA+ICQod2luZG93KS5zY3JvbGxUb3AoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAnYm90dG9tJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHAgPSB0cGI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRwID0gdHB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHAgPSB0cGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHAgPSB0cHI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAkdGlwXG4gICAgICAgICAgICAgICAgLm9mZnNldCh0cClcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MocGxhY2VtZW50KVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnaW4nKTtcbiAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciAkdGlwID0gdGhpcy50aXAoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHBsYWNlbWVudCA9IHR5cGVvZiB0aGlzLm9wdGlvbnMucGxhY2VtZW50ID09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wbGFjZW1lbnQuY2FsbCh0aGlzLCAkdGlwWzBdLCB0aGlzLiRlbGVtZW50WzBdKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBsYWNlbWVudDsgICAgICAgICAgICBcblxuICAgICAgICAgICAgdmFyIGF1dG9Ub2tlbiA9IC9cXHM/YXV0bz9cXHM/L2k7XG4gICAgICAgICAgICB2YXIgYXV0b1BsYWNlID0gYXV0b1Rva2VuLnRlc3QocGxhY2VtZW50KTtcbiAgICAgICAgICAgIGlmIChhdXRvUGxhY2UpIHtcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQucmVwbGFjZShhdXRvVG9rZW4sICcnKSB8fCAndG9wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgdmFyIGFjdHVhbFdpZHRoID0gJHRpcFswXS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIHZhciBhY3R1YWxIZWlnaHQgPSAkdGlwWzBdLm9mZnNldEhlaWdodDtcblxuICAgICAgICAgICAgaWYgKGF1dG9QbGFjZSkge1xuICAgICAgICAgICAgICAgIHZhciAkcGFyZW50ID0gdGhpcy4kZWxlbWVudC5wYXJlbnQoKTtcblxuICAgICAgICAgICAgICAgIHZhciBvcmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGRvY1Njcm9sbCAgICA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFdpZHRoICA9IHRoaXMub3B0aW9ucy5jb250YWluZXIgPT0gJ2JvZHknID8gd2luZG93LmlubmVyV2lkdGggIDogJHBhcmVudC5vdXRlcldpZHRoKCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEhlaWdodCA9IHRoaXMub3B0aW9ucy5jb250YWluZXIgPT0gJ2JvZHknID8gd2luZG93LmlubmVySGVpZ2h0IDogJHBhcmVudC5vdXRlckhlaWdodCgpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRMZWZ0ICAgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyID09ICdib2R5JyA/IDAgOiAkcGFyZW50Lm9mZnNldCgpLmxlZnQ7XG5cbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQgPT0gJ2JvdHRvbScgJiYgcG9zLnRvcCAgICsgcG9zLmhlaWdodCAgKyBhY3R1YWxIZWlnaHQgLSBkb2NTY3JvbGwgPiBwYXJlbnRIZWlnaHQgID8gJ3RvcCcgICAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9PSAndG9wJyAgICAmJiBwb3MudG9wICAgLSBkb2NTY3JvbGwgICAtIGFjdHVhbEhlaWdodCA8IDAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnYm90dG9tJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID09ICdyaWdodCcgICYmIHBvcy5yaWdodCArIGFjdHVhbFdpZHRoID4gcGFyZW50V2lkdGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdsZWZ0JyAgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPT0gJ2xlZnQnICAgJiYgcG9zLmxlZnQgIC0gYWN0dWFsV2lkdGggPCBwYXJlbnRMZWZ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ3JpZ2h0JyAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudDtcblxuICAgICAgICAgICAgICAgICR0aXBcbiAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhvcmdQbGFjZW1lbnQpXG4gICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MocGxhY2VtZW50KTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB2YXIgY2FsY3VsYXRlZE9mZnNldCA9IHRoaXMuZ2V0Q2FsY3VsYXRlZE9mZnNldChwbGFjZW1lbnQsIHBvcywgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodCk7XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlQbGFjZW1lbnQoY2FsY3VsYXRlZE9mZnNldCwgcGxhY2VtZW50KTsgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSkuY2FsbCh0aGlzLmNvbnRhaW5lcigpKTtcbiAgICAgICAgICAvKmpzaGludCBsYXhjb21tYTogZmFsc2UsIGVxZXFlcTogdHJ1ZSovICBcbiAgICAgICAgfSAgICAgICAgICAgIFxuICAgIH0pO1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBib290c3RyYXAtZGF0ZXBpY2tlci5qc1xuICogaHR0cDovL3d3dy5leWVjb24ucm8vYm9vdHN0cmFwLWRhdGVwaWNrZXJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTIgU3RlZmFuIFBldHJlXG4gKiBJbXByb3ZlbWVudHMgYnkgQW5kcmV3IFJvd2xzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuKGZ1bmN0aW9uKCAkICkge1xuXG5cdGZ1bmN0aW9uIFVUQ0RhdGUoKXtcblx0XHRyZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkoRGF0ZSwgYXJndW1lbnRzKSk7XG5cdH1cblx0ZnVuY3Rpb24gVVRDVG9kYXkoKXtcblx0XHR2YXIgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuXHRcdHJldHVybiBVVENEYXRlKHRvZGF5LmdldFVUQ0Z1bGxZZWFyKCksIHRvZGF5LmdldFVUQ01vbnRoKCksIHRvZGF5LmdldFVUQ0RhdGUoKSk7XG5cdH1cblxuXHQvLyBQaWNrZXIgb2JqZWN0XG5cblx0dmFyIERhdGVwaWNrZXIgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy5fcHJvY2Vzc19vcHRpb25zKG9wdGlvbnMpO1xuXG5cdFx0dGhpcy5lbGVtZW50ID0gJChlbGVtZW50KTtcblx0XHR0aGlzLmlzSW5saW5lID0gZmFsc2U7XG5cdFx0dGhpcy5pc0lucHV0ID0gdGhpcy5lbGVtZW50LmlzKCdpbnB1dCcpO1xuXHRcdHRoaXMuY29tcG9uZW50ID0gdGhpcy5lbGVtZW50LmlzKCcuZGF0ZScpID8gdGhpcy5lbGVtZW50LmZpbmQoJy5hZGQtb24sIC5idG4nKSA6IGZhbHNlO1xuXHRcdHRoaXMuaGFzSW5wdXQgPSB0aGlzLmNvbXBvbmVudCAmJiB0aGlzLmVsZW1lbnQuZmluZCgnaW5wdXQnKS5sZW5ndGg7XG5cdFx0aWYodGhpcy5jb21wb25lbnQgJiYgdGhpcy5jb21wb25lbnQubGVuZ3RoID09PSAwKVxuXHRcdFx0dGhpcy5jb21wb25lbnQgPSBmYWxzZTtcblxuXHRcdHRoaXMucGlja2VyID0gJChEUEdsb2JhbC50ZW1wbGF0ZSk7XG5cdFx0dGhpcy5fYnVpbGRFdmVudHMoKTtcblx0XHR0aGlzLl9hdHRhY2hFdmVudHMoKTtcblxuXHRcdGlmKHRoaXMuaXNJbmxpbmUpIHtcblx0XHRcdHRoaXMucGlja2VyLmFkZENsYXNzKCdkYXRlcGlja2VyLWlubGluZScpLmFwcGVuZFRvKHRoaXMuZWxlbWVudCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucGlja2VyLmFkZENsYXNzKCdkYXRlcGlja2VyLWRyb3Bkb3duIGRyb3Bkb3duLW1lbnUnKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vLnJ0bCl7XG5cdFx0XHR0aGlzLnBpY2tlci5hZGRDbGFzcygnZGF0ZXBpY2tlci1ydGwnKTtcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5wcmV2IGksIC5uZXh0IGknKVxuXHRcdFx0XHRcdFx0LnRvZ2dsZUNsYXNzKCdpY29uLWFycm93LWxlZnQgaWNvbi1hcnJvdy1yaWdodCcpO1xuXHRcdH1cblxuXG5cdFx0dGhpcy52aWV3TW9kZSA9IHRoaXMuby5zdGFydFZpZXc7XG5cblx0XHRpZiAodGhpcy5vLmNhbGVuZGFyV2Vla3MpXG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCd0Zm9vdCB0aC50b2RheScpXG5cdFx0XHRcdFx0XHQuYXR0cignY29sc3BhbicsIGZ1bmN0aW9uKGksIHZhbCl7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBwYXJzZUludCh2YWwpICsgMTtcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0dGhpcy5fYWxsb3dfdXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLnNldFN0YXJ0RGF0ZSh0aGlzLm8uc3RhcnREYXRlKTtcblx0XHR0aGlzLnNldEVuZERhdGUodGhpcy5vLmVuZERhdGUpO1xuXHRcdHRoaXMuc2V0RGF5c09mV2Vla0Rpc2FibGVkKHRoaXMuby5kYXlzT2ZXZWVrRGlzYWJsZWQpO1xuXG5cdFx0dGhpcy5maWxsRG93KCk7XG5cdFx0dGhpcy5maWxsTW9udGhzKCk7XG5cblx0XHR0aGlzLl9hbGxvd191cGRhdGUgPSB0cnVlO1xuXG5cdFx0dGhpcy51cGRhdGUoKTtcblx0XHR0aGlzLnNob3dNb2RlKCk7XG5cblx0XHRpZih0aGlzLmlzSW5saW5lKSB7XG5cdFx0XHR0aGlzLnNob3coKTtcblx0XHR9XG5cdH07XG5cblx0RGF0ZXBpY2tlci5wcm90b3R5cGUgPSB7XG5cdFx0Y29uc3RydWN0b3I6IERhdGVwaWNrZXIsXG5cblx0XHRfcHJvY2Vzc19vcHRpb25zOiBmdW5jdGlvbihvcHRzKXtcblx0XHRcdC8vIFN0b3JlIHJhdyBvcHRpb25zIGZvciByZWZlcmVuY2Vcblx0XHRcdHRoaXMuX28gPSAkLmV4dGVuZCh7fSwgdGhpcy5fbywgb3B0cyk7XG5cdFx0XHQvLyBQcm9jZXNzZWQgb3B0aW9uc1xuXHRcdFx0dmFyIG8gPSB0aGlzLm8gPSAkLmV4dGVuZCh7fSwgdGhpcy5fbyk7XG5cblx0XHRcdC8vIENoZWNrIGlmIFwiZGUtREVcIiBzdHlsZSBkYXRlIGlzIGF2YWlsYWJsZSwgaWYgbm90IGxhbmd1YWdlIHNob3VsZFxuXHRcdFx0Ly8gZmFsbGJhY2sgdG8gMiBsZXR0ZXIgY29kZSBlZyBcImRlXCJcblx0XHRcdHZhciBsYW5nID0gby5sYW5ndWFnZTtcblx0XHRcdGlmICghZGF0ZXNbbGFuZ10pIHtcblx0XHRcdFx0bGFuZyA9IGxhbmcuc3BsaXQoJy0nKVswXTtcblx0XHRcdFx0aWYgKCFkYXRlc1tsYW5nXSlcblx0XHRcdFx0XHRsYW5nID0gZGVmYXVsdHMubGFuZ3VhZ2U7XG5cdFx0XHR9XG5cdFx0XHRvLmxhbmd1YWdlID0gbGFuZztcblxuXHRcdFx0c3dpdGNoKG8uc3RhcnRWaWV3KXtcblx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRjYXNlICdkZWNhZGUnOlxuXHRcdFx0XHRcdG8uc3RhcnRWaWV3ID0gMjtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRjYXNlICd5ZWFyJzpcblx0XHRcdFx0XHRvLnN0YXJ0VmlldyA9IDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0by5zdGFydFZpZXcgPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHRzd2l0Y2ggKG8ubWluVmlld01vZGUpIHtcblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRjYXNlICdtb250aHMnOlxuXHRcdFx0XHRcdG8ubWluVmlld01vZGUgPSAxO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdGNhc2UgJ3llYXJzJzpcblx0XHRcdFx0XHRvLm1pblZpZXdNb2RlID0gMjtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRvLm1pblZpZXdNb2RlID0gMDtcblx0XHRcdH1cblxuXHRcdFx0by5zdGFydFZpZXcgPSBNYXRoLm1heChvLnN0YXJ0Vmlldywgby5taW5WaWV3TW9kZSk7XG5cblx0XHRcdG8ud2Vla1N0YXJ0ICU9IDc7XG5cdFx0XHRvLndlZWtFbmQgPSAoKG8ud2Vla1N0YXJ0ICsgNikgJSA3KTtcblxuXHRcdFx0dmFyIGZvcm1hdCA9IERQR2xvYmFsLnBhcnNlRm9ybWF0KG8uZm9ybWF0KVxuXHRcdFx0aWYgKG8uc3RhcnREYXRlICE9PSAtSW5maW5pdHkpIHtcblx0XHRcdFx0by5zdGFydERhdGUgPSBEUEdsb2JhbC5wYXJzZURhdGUoby5zdGFydERhdGUsIGZvcm1hdCwgby5sYW5ndWFnZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoby5lbmREYXRlICE9PSBJbmZpbml0eSkge1xuXHRcdFx0XHRvLmVuZERhdGUgPSBEUEdsb2JhbC5wYXJzZURhdGUoby5lbmREYXRlLCBmb3JtYXQsIG8ubGFuZ3VhZ2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRvLmRheXNPZldlZWtEaXNhYmxlZCA9IG8uZGF5c09mV2Vla0Rpc2FibGVkfHxbXTtcblx0XHRcdGlmICghJC5pc0FycmF5KG8uZGF5c09mV2Vla0Rpc2FibGVkKSlcblx0XHRcdFx0by5kYXlzT2ZXZWVrRGlzYWJsZWQgPSBvLmRheXNPZldlZWtEaXNhYmxlZC5zcGxpdCgvWyxcXHNdKi8pO1xuXHRcdFx0by5kYXlzT2ZXZWVrRGlzYWJsZWQgPSAkLm1hcChvLmRheXNPZldlZWtEaXNhYmxlZCwgZnVuY3Rpb24gKGQpIHtcblx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KGQsIDEwKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0X2V2ZW50czogW10sXG5cdFx0X3NlY29uZGFyeUV2ZW50czogW10sXG5cdFx0X2FwcGx5RXZlbnRzOiBmdW5jdGlvbihldnMpe1xuXHRcdFx0Zm9yICh2YXIgaT0wLCBlbCwgZXY7IGk8ZXZzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0ZWwgPSBldnNbaV1bMF07XG5cdFx0XHRcdGV2ID0gZXZzW2ldWzFdO1xuXHRcdFx0XHRlbC5vbihldik7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRfdW5hcHBseUV2ZW50czogZnVuY3Rpb24oZXZzKXtcblx0XHRcdGZvciAodmFyIGk9MCwgZWwsIGV2OyBpPGV2cy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdGVsID0gZXZzW2ldWzBdO1xuXHRcdFx0XHRldiA9IGV2c1tpXVsxXTtcblx0XHRcdFx0ZWwub2ZmKGV2KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdF9idWlsZEV2ZW50czogZnVuY3Rpb24oKXtcblx0XHRcdGlmICh0aGlzLmlzSW5wdXQpIHsgLy8gc2luZ2xlIGlucHV0XG5cdFx0XHRcdHRoaXMuX2V2ZW50cyA9IFtcblx0XHRcdFx0XHRbdGhpcy5lbGVtZW50LCB7XG5cdFx0XHRcdFx0XHRmb2N1czogJC5wcm94eSh0aGlzLnNob3csIHRoaXMpLFxuXHRcdFx0XHRcdFx0a2V5dXA6ICQucHJveHkodGhpcy51cGRhdGUsIHRoaXMpLFxuXHRcdFx0XHRcdFx0a2V5ZG93bjogJC5wcm94eSh0aGlzLmtleWRvd24sIHRoaXMpXG5cdFx0XHRcdFx0fV1cblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHRoaXMuY29tcG9uZW50ICYmIHRoaXMuaGFzSW5wdXQpeyAvLyBjb21wb25lbnQ6IGlucHV0ICsgYnV0dG9uXG5cdFx0XHRcdHRoaXMuX2V2ZW50cyA9IFtcblx0XHRcdFx0XHQvLyBGb3IgY29tcG9uZW50cyB0aGF0IGFyZSBub3QgcmVhZG9ubHksIGFsbG93IGtleWJvYXJkIG5hdlxuXHRcdFx0XHRcdFt0aGlzLmVsZW1lbnQuZmluZCgnaW5wdXQnKSwge1xuXHRcdFx0XHRcdFx0Zm9jdXM6ICQucHJveHkodGhpcy5zaG93LCB0aGlzKSxcblx0XHRcdFx0XHRcdGtleXVwOiAkLnByb3h5KHRoaXMudXBkYXRlLCB0aGlzKSxcblx0XHRcdFx0XHRcdGtleWRvd246ICQucHJveHkodGhpcy5rZXlkb3duLCB0aGlzKVxuXHRcdFx0XHRcdH1dLFxuXHRcdFx0XHRcdFt0aGlzLmNvbXBvbmVudCwge1xuXHRcdFx0XHRcdFx0Y2xpY2s6ICQucHJveHkodGhpcy5zaG93LCB0aGlzKVxuXHRcdFx0XHRcdH1dXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0aGlzLmVsZW1lbnQuaXMoJ2RpdicpKSB7ICAvLyBpbmxpbmUgZGF0ZXBpY2tlclxuXHRcdFx0XHR0aGlzLmlzSW5saW5lID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9ldmVudHMgPSBbXG5cdFx0XHRcdFx0W3RoaXMuZWxlbWVudCwge1xuXHRcdFx0XHRcdFx0Y2xpY2s6ICQucHJveHkodGhpcy5zaG93LCB0aGlzKVxuXHRcdFx0XHRcdH1dXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3NlY29uZGFyeUV2ZW50cyA9IFtcblx0XHRcdFx0W3RoaXMucGlja2VyLCB7XG5cdFx0XHRcdFx0Y2xpY2s6ICQucHJveHkodGhpcy5jbGljaywgdGhpcylcblx0XHRcdFx0fV0sXG5cdFx0XHRcdFskKHdpbmRvdyksIHtcblx0XHRcdFx0XHRyZXNpemU6ICQucHJveHkodGhpcy5wbGFjZSwgdGhpcylcblx0XHRcdFx0fV0sXG5cdFx0XHRcdFskKGRvY3VtZW50KSwge1xuXHRcdFx0XHRcdG1vdXNlZG93bjogJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0Ly8gQ2xpY2tlZCBvdXRzaWRlIHRoZSBkYXRlcGlja2VyLCBoaWRlIGl0XG5cdFx0XHRcdFx0XHRpZiAoIShcblx0XHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LmlzKGUudGFyZ2V0KSB8fFxuXHRcdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuZmluZChlLnRhcmdldCkuc2l6ZSgpIHx8XG5cdFx0XHRcdFx0XHRcdHRoaXMucGlja2VyLmlzKGUudGFyZ2V0KSB8fFxuXHRcdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5maW5kKGUudGFyZ2V0KS5zaXplKClcblx0XHRcdFx0XHRcdCkpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5oaWRlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcylcblx0XHRcdFx0fV1cblx0XHRcdF07XG5cdFx0fSxcblx0XHRfYXR0YWNoRXZlbnRzOiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5fZGV0YWNoRXZlbnRzKCk7XG5cdFx0XHR0aGlzLl9hcHBseUV2ZW50cyh0aGlzLl9ldmVudHMpO1xuXHRcdH0sXG5cdFx0X2RldGFjaEV2ZW50czogZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMuX3VuYXBwbHlFdmVudHModGhpcy5fZXZlbnRzKTtcblx0XHR9LFxuXHRcdF9hdHRhY2hTZWNvbmRhcnlFdmVudHM6IGZ1bmN0aW9uKCl7XG5cdFx0XHR0aGlzLl9kZXRhY2hTZWNvbmRhcnlFdmVudHMoKTtcblx0XHRcdHRoaXMuX2FwcGx5RXZlbnRzKHRoaXMuX3NlY29uZGFyeUV2ZW50cyk7XG5cdFx0fSxcblx0XHRfZGV0YWNoU2Vjb25kYXJ5RXZlbnRzOiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5fdW5hcHBseUV2ZW50cyh0aGlzLl9zZWNvbmRhcnlFdmVudHMpO1xuXHRcdH0sXG5cdFx0X3RyaWdnZXI6IGZ1bmN0aW9uKGV2ZW50LCBhbHRkYXRlKXtcblx0XHRcdHZhciBkYXRlID0gYWx0ZGF0ZSB8fCB0aGlzLmRhdGUsXG5cdFx0XHRcdGxvY2FsX2RhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSArIChkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkqNjAwMDApKTtcblxuXHRcdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoe1xuXHRcdFx0XHR0eXBlOiBldmVudCxcblx0XHRcdFx0ZGF0ZTogbG9jYWxfZGF0ZSxcblx0XHRcdFx0Zm9ybWF0OiAkLnByb3h5KGZ1bmN0aW9uKGFsdGZvcm1hdCl7XG5cdFx0XHRcdFx0dmFyIGZvcm1hdCA9IGFsdGZvcm1hdCB8fCB0aGlzLm8uZm9ybWF0O1xuXHRcdFx0XHRcdHJldHVybiBEUEdsb2JhbC5mb3JtYXREYXRlKGRhdGUsIGZvcm1hdCwgdGhpcy5vLmxhbmd1YWdlKTtcblx0XHRcdFx0fSwgdGhpcylcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRzaG93OiBmdW5jdGlvbihlKSB7XG5cdFx0XHRpZiAoIXRoaXMuaXNJbmxpbmUpXG5cdFx0XHRcdHRoaXMucGlja2VyLmFwcGVuZFRvKCdib2R5Jyk7XG5cdFx0XHR0aGlzLnBpY2tlci5zaG93KCk7XG5cdFx0XHR0aGlzLmhlaWdodCA9IHRoaXMuY29tcG9uZW50ID8gdGhpcy5jb21wb25lbnQub3V0ZXJIZWlnaHQoKSA6IHRoaXMuZWxlbWVudC5vdXRlckhlaWdodCgpO1xuXHRcdFx0dGhpcy5wbGFjZSgpO1xuXHRcdFx0dGhpcy5fYXR0YWNoU2Vjb25kYXJ5RXZlbnRzKCk7XG5cdFx0XHRpZiAoZSkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90cmlnZ2VyKCdzaG93Jyk7XG5cdFx0fSxcblxuXHRcdGhpZGU6IGZ1bmN0aW9uKGUpe1xuXHRcdFx0aWYodGhpcy5pc0lubGluZSkgcmV0dXJuO1xuXHRcdFx0aWYgKCF0aGlzLnBpY2tlci5pcygnOnZpc2libGUnKSkgcmV0dXJuO1xuXHRcdFx0dGhpcy5waWNrZXIuaGlkZSgpLmRldGFjaCgpO1xuXHRcdFx0dGhpcy5fZGV0YWNoU2Vjb25kYXJ5RXZlbnRzKCk7XG5cdFx0XHR0aGlzLnZpZXdNb2RlID0gdGhpcy5vLnN0YXJ0Vmlldztcblx0XHRcdHRoaXMuc2hvd01vZGUoKTtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHR0aGlzLm8uZm9yY2VQYXJzZSAmJlxuXHRcdFx0XHQoXG5cdFx0XHRcdFx0dGhpcy5pc0lucHV0ICYmIHRoaXMuZWxlbWVudC52YWwoKSB8fFxuXHRcdFx0XHRcdHRoaXMuaGFzSW5wdXQgJiYgdGhpcy5lbGVtZW50LmZpbmQoJ2lucHV0JykudmFsKClcblx0XHRcdFx0KVxuXHRcdFx0KVxuXHRcdFx0XHR0aGlzLnNldFZhbHVlKCk7XG5cdFx0XHR0aGlzLl90cmlnZ2VyKCdoaWRlJyk7XG5cdFx0fSxcblxuXHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmhpZGUoKTtcblx0XHRcdHRoaXMuX2RldGFjaEV2ZW50cygpO1xuXHRcdFx0dGhpcy5fZGV0YWNoU2Vjb25kYXJ5RXZlbnRzKCk7XG5cdFx0XHR0aGlzLnBpY2tlci5yZW1vdmUoKTtcblx0XHRcdGRlbGV0ZSB0aGlzLmVsZW1lbnQuZGF0YSgpLmRhdGVwaWNrZXI7XG5cdFx0XHRpZiAoIXRoaXMuaXNJbnB1dCkge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5lbGVtZW50LmRhdGEoKS5kYXRlO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXREYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkID0gdGhpcy5nZXRVVENEYXRlKCk7XG5cdFx0XHRyZXR1cm4gbmV3IERhdGUoZC5nZXRUaW1lKCkgKyAoZC5nZXRUaW1lem9uZU9mZnNldCgpKjYwMDAwKSk7XG5cdFx0fSxcblxuXHRcdGdldFVUQ0RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF0ZTtcblx0XHR9LFxuXG5cdFx0c2V0RGF0ZTogZnVuY3Rpb24oZCkge1xuXHRcdFx0dGhpcy5zZXRVVENEYXRlKG5ldyBEYXRlKGQuZ2V0VGltZSgpIC0gKGQuZ2V0VGltZXpvbmVPZmZzZXQoKSo2MDAwMCkpKTtcblx0XHR9LFxuXG5cdFx0c2V0VVRDRGF0ZTogZnVuY3Rpb24oZCkge1xuXHRcdFx0dGhpcy5kYXRlID0gZDtcblx0XHRcdHRoaXMuc2V0VmFsdWUoKTtcblx0XHR9LFxuXG5cdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGZvcm1hdHRlZCA9IHRoaXMuZ2V0Rm9ybWF0dGVkRGF0ZSgpO1xuXHRcdFx0aWYgKCF0aGlzLmlzSW5wdXQpIHtcblx0XHRcdFx0aWYgKHRoaXMuY29tcG9uZW50KXtcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuZmluZCgnaW5wdXQnKS52YWwoZm9ybWF0dGVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnZhbChmb3JtYXR0ZWQpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXRGb3JtYXR0ZWREYXRlOiBmdW5jdGlvbihmb3JtYXQpIHtcblx0XHRcdGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0Zm9ybWF0ID0gdGhpcy5vLmZvcm1hdDtcblx0XHRcdHJldHVybiBEUEdsb2JhbC5mb3JtYXREYXRlKHRoaXMuZGF0ZSwgZm9ybWF0LCB0aGlzLm8ubGFuZ3VhZ2UpO1xuXHRcdH0sXG5cblx0XHRzZXRTdGFydERhdGU6IGZ1bmN0aW9uKHN0YXJ0RGF0ZSl7XG5cdFx0XHR0aGlzLl9wcm9jZXNzX29wdGlvbnMoe3N0YXJ0RGF0ZTogc3RhcnREYXRlfSk7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0dGhpcy51cGRhdGVOYXZBcnJvd3MoKTtcblx0XHR9LFxuXG5cdFx0c2V0RW5kRGF0ZTogZnVuY3Rpb24oZW5kRGF0ZSl7XG5cdFx0XHR0aGlzLl9wcm9jZXNzX29wdGlvbnMoe2VuZERhdGU6IGVuZERhdGV9KTtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHR0aGlzLnVwZGF0ZU5hdkFycm93cygpO1xuXHRcdH0sXG5cblx0XHRzZXREYXlzT2ZXZWVrRGlzYWJsZWQ6IGZ1bmN0aW9uKGRheXNPZldlZWtEaXNhYmxlZCl7XG5cdFx0XHR0aGlzLl9wcm9jZXNzX29wdGlvbnMoe2RheXNPZldlZWtEaXNhYmxlZDogZGF5c09mV2Vla0Rpc2FibGVkfSk7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0dGhpcy51cGRhdGVOYXZBcnJvd3MoKTtcblx0XHR9LFxuXG5cdFx0cGxhY2U6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRpZih0aGlzLmlzSW5saW5lKSByZXR1cm47XG5cdFx0XHR2YXIgekluZGV4ID0gcGFyc2VJbnQodGhpcy5lbGVtZW50LnBhcmVudHMoKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiAkKHRoaXMpLmNzcygnei1pbmRleCcpICE9ICdhdXRvJztcblx0XHRcdFx0XHRcdH0pLmZpcnN0KCkuY3NzKCd6LWluZGV4JykpKzEwO1xuXHRcdFx0dmFyIG9mZnNldCA9IHRoaXMuY29tcG9uZW50ID8gdGhpcy5jb21wb25lbnQucGFyZW50KCkub2Zmc2V0KCkgOiB0aGlzLmVsZW1lbnQub2Zmc2V0KCk7XG5cdFx0XHR2YXIgaGVpZ2h0ID0gdGhpcy5jb21wb25lbnQgPyB0aGlzLmNvbXBvbmVudC5vdXRlckhlaWdodCh0cnVlKSA6IHRoaXMuZWxlbWVudC5vdXRlckhlaWdodCh0cnVlKTtcblx0XHRcdHRoaXMucGlja2VyLmNzcyh7XG5cdFx0XHRcdHRvcDogb2Zmc2V0LnRvcCArIGhlaWdodCxcblx0XHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQsXG5cdFx0XHRcdHpJbmRleDogekluZGV4XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0X2FsbG93X3VwZGF0ZTogdHJ1ZSxcblx0XHR1cGRhdGU6IGZ1bmN0aW9uKCl7XG5cdFx0XHRpZiAoIXRoaXMuX2FsbG93X3VwZGF0ZSkgcmV0dXJuO1xuXG5cdFx0XHR2YXIgZGF0ZSwgZnJvbUFyZ3MgPSBmYWxzZTtcblx0XHRcdGlmKGFyZ3VtZW50cyAmJiBhcmd1bWVudHMubGVuZ3RoICYmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnc3RyaW5nJyB8fCBhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBEYXRlKSkge1xuXHRcdFx0XHRkYXRlID0gYXJndW1lbnRzWzBdO1xuXHRcdFx0XHRmcm9tQXJncyA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRlID0gdGhpcy5pc0lucHV0ID8gdGhpcy5lbGVtZW50LnZhbCgpIDogdGhpcy5lbGVtZW50LmRhdGEoJ2RhdGUnKSB8fCB0aGlzLmVsZW1lbnQuZmluZCgnaW5wdXQnKS52YWwoKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuZWxlbWVudC5kYXRhKCkuZGF0ZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5kYXRlID0gRFBHbG9iYWwucGFyc2VEYXRlKGRhdGUsIHRoaXMuby5mb3JtYXQsIHRoaXMuby5sYW5ndWFnZSk7XG5cblx0XHRcdGlmKGZyb21BcmdzKSB0aGlzLnNldFZhbHVlKCk7XG5cblx0XHRcdGlmICh0aGlzLmRhdGUgPCB0aGlzLm8uc3RhcnREYXRlKSB7XG5cdFx0XHRcdHRoaXMudmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLm8uc3RhcnREYXRlKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5kYXRlID4gdGhpcy5vLmVuZERhdGUpIHtcblx0XHRcdFx0dGhpcy52aWV3RGF0ZSA9IG5ldyBEYXRlKHRoaXMuby5lbmREYXRlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMudmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLmRhdGUpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5maWxsKCk7XG5cdFx0fSxcblxuXHRcdGZpbGxEb3c6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgZG93Q250ID0gdGhpcy5vLndlZWtTdGFydCxcblx0XHRcdGh0bWwgPSAnPHRyPic7XG5cdFx0XHRpZih0aGlzLm8uY2FsZW5kYXJXZWVrcyl7XG5cdFx0XHRcdHZhciBjZWxsID0gJzx0aCBjbGFzcz1cImN3XCI+Jm5ic3A7PC90aD4nO1xuXHRcdFx0XHRodG1sICs9IGNlbGw7XG5cdFx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5kYXRlcGlja2VyLWRheXMgdGhlYWQgdHI6Zmlyc3QtY2hpbGQnKS5wcmVwZW5kKGNlbGwpO1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKGRvd0NudCA8IHRoaXMuby53ZWVrU3RhcnQgKyA3KSB7XG5cdFx0XHRcdGh0bWwgKz0gJzx0aCBjbGFzcz1cImRvd1wiPicrZGF0ZXNbdGhpcy5vLmxhbmd1YWdlXS5kYXlzTWluWyhkb3dDbnQrKyklN10rJzwvdGg+Jztcblx0XHRcdH1cblx0XHRcdGh0bWwgKz0gJzwvdHI+Jztcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5kYXRlcGlja2VyLWRheXMgdGhlYWQnKS5hcHBlbmQoaHRtbCk7XG5cdFx0fSxcblxuXHRcdGZpbGxNb250aHM6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgaHRtbCA9ICcnLFxuXHRcdFx0aSA9IDA7XG5cdFx0XHR3aGlsZSAoaSA8IDEyKSB7XG5cdFx0XHRcdGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwibW9udGhcIj4nK2RhdGVzW3RoaXMuby5sYW5ndWFnZV0ubW9udGhzU2hvcnRbaSsrXSsnPC9zcGFuPic7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCcuZGF0ZXBpY2tlci1tb250aHMgdGQnKS5odG1sKGh0bWwpO1xuXHRcdH0sXG5cblx0XHRzZXRSYW5nZTogZnVuY3Rpb24ocmFuZ2Upe1xuXHRcdFx0aWYgKCFyYW5nZSB8fCAhcmFuZ2UubGVuZ3RoKVxuXHRcdFx0XHRkZWxldGUgdGhpcy5yYW5nZTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0dGhpcy5yYW5nZSA9ICQubWFwKHJhbmdlLCBmdW5jdGlvbihkKXsgcmV0dXJuIGQudmFsdWVPZigpOyB9KTtcblx0XHRcdHRoaXMuZmlsbCgpO1xuXHRcdH0sXG5cblx0XHRnZXRDbGFzc05hbWVzOiBmdW5jdGlvbihkYXRlKXtcblx0XHRcdHZhciBjbHMgPSBbXSxcblx0XHRcdFx0eWVhciA9IHRoaXMudmlld0RhdGUuZ2V0VVRDRnVsbFllYXIoKSxcblx0XHRcdFx0bW9udGggPSB0aGlzLnZpZXdEYXRlLmdldFVUQ01vbnRoKCksXG5cdFx0XHRcdGN1cnJlbnREYXRlID0gdGhpcy5kYXRlLnZhbHVlT2YoKSxcblx0XHRcdFx0dG9kYXkgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0aWYgKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA8IHllYXIgfHwgKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA9PSB5ZWFyICYmIGRhdGUuZ2V0VVRDTW9udGgoKSA8IG1vbnRoKSkge1xuXHRcdFx0XHRjbHMucHVzaCgnb2xkJyk7XG5cdFx0XHR9IGVsc2UgaWYgKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA+IHllYXIgfHwgKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA9PSB5ZWFyICYmIGRhdGUuZ2V0VVRDTW9udGgoKSA+IG1vbnRoKSkge1xuXHRcdFx0XHRjbHMucHVzaCgnbmV3Jyk7XG5cdFx0XHR9XG5cdFx0XHQvLyBDb21wYXJlIGludGVybmFsIFVUQyBkYXRlIHdpdGggbG9jYWwgdG9kYXksIG5vdCBVVEMgdG9kYXlcblx0XHRcdGlmICh0aGlzLm8udG9kYXlIaWdobGlnaHQgJiZcblx0XHRcdFx0ZGF0ZS5nZXRVVENGdWxsWWVhcigpID09IHRvZGF5LmdldEZ1bGxZZWFyKCkgJiZcblx0XHRcdFx0ZGF0ZS5nZXRVVENNb250aCgpID09IHRvZGF5LmdldE1vbnRoKCkgJiZcblx0XHRcdFx0ZGF0ZS5nZXRVVENEYXRlKCkgPT0gdG9kYXkuZ2V0RGF0ZSgpKSB7XG5cdFx0XHRcdGNscy5wdXNoKCd0b2RheScpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGN1cnJlbnREYXRlICYmIGRhdGUudmFsdWVPZigpID09IGN1cnJlbnREYXRlKSB7XG5cdFx0XHRcdGNscy5wdXNoKCdhY3RpdmUnKTtcblx0XHRcdH1cblx0XHRcdGlmIChkYXRlLnZhbHVlT2YoKSA8IHRoaXMuby5zdGFydERhdGUgfHwgZGF0ZS52YWx1ZU9mKCkgPiB0aGlzLm8uZW5kRGF0ZSB8fFxuXHRcdFx0XHQkLmluQXJyYXkoZGF0ZS5nZXRVVENEYXkoKSwgdGhpcy5vLmRheXNPZldlZWtEaXNhYmxlZCkgIT09IC0xKSB7XG5cdFx0XHRcdGNscy5wdXNoKCdkaXNhYmxlZCcpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMucmFuZ2Upe1xuXHRcdFx0XHRpZiAoZGF0ZSA+IHRoaXMucmFuZ2VbMF0gJiYgZGF0ZSA8IHRoaXMucmFuZ2VbdGhpcy5yYW5nZS5sZW5ndGgtMV0pe1xuXHRcdFx0XHRcdGNscy5wdXNoKCdyYW5nZScpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICgkLmluQXJyYXkoZGF0ZS52YWx1ZU9mKCksIHRoaXMucmFuZ2UpICE9IC0xKXtcblx0XHRcdFx0XHRjbHMucHVzaCgnc2VsZWN0ZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNscztcblx0XHR9LFxuXG5cdFx0ZmlsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZCA9IG5ldyBEYXRlKHRoaXMudmlld0RhdGUpLFxuXHRcdFx0XHR5ZWFyID0gZC5nZXRVVENGdWxsWWVhcigpLFxuXHRcdFx0XHRtb250aCA9IGQuZ2V0VVRDTW9udGgoKSxcblx0XHRcdFx0c3RhcnRZZWFyID0gdGhpcy5vLnN0YXJ0RGF0ZSAhPT0gLUluZmluaXR5ID8gdGhpcy5vLnN0YXJ0RGF0ZS5nZXRVVENGdWxsWWVhcigpIDogLUluZmluaXR5LFxuXHRcdFx0XHRzdGFydE1vbnRoID0gdGhpcy5vLnN0YXJ0RGF0ZSAhPT0gLUluZmluaXR5ID8gdGhpcy5vLnN0YXJ0RGF0ZS5nZXRVVENNb250aCgpIDogLUluZmluaXR5LFxuXHRcdFx0XHRlbmRZZWFyID0gdGhpcy5vLmVuZERhdGUgIT09IEluZmluaXR5ID8gdGhpcy5vLmVuZERhdGUuZ2V0VVRDRnVsbFllYXIoKSA6IEluZmluaXR5LFxuXHRcdFx0XHRlbmRNb250aCA9IHRoaXMuby5lbmREYXRlICE9PSBJbmZpbml0eSA/IHRoaXMuby5lbmREYXRlLmdldFVUQ01vbnRoKCkgOiBJbmZpbml0eSxcblx0XHRcdFx0Y3VycmVudERhdGUgPSB0aGlzLmRhdGUgJiYgdGhpcy5kYXRlLnZhbHVlT2YoKSxcblx0XHRcdFx0dG9vbHRpcDtcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5kYXRlcGlja2VyLWRheXMgdGhlYWQgdGguZGF0ZXBpY2tlci1zd2l0Y2gnKVxuXHRcdFx0XHRcdFx0LnRleHQoZGF0ZXNbdGhpcy5vLmxhbmd1YWdlXS5tb250aHNbbW9udGhdKycgJyt5ZWFyKTtcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJ3Rmb290IHRoLnRvZGF5Jylcblx0XHRcdFx0XHRcdC50ZXh0KGRhdGVzW3RoaXMuby5sYW5ndWFnZV0udG9kYXkpXG5cdFx0XHRcdFx0XHQudG9nZ2xlKHRoaXMuby50b2RheUJ0biAhPT0gZmFsc2UpO1xuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgndGZvb3QgdGguY2xlYXInKVxuXHRcdFx0XHRcdFx0LnRleHQoZGF0ZXNbdGhpcy5vLmxhbmd1YWdlXS5jbGVhcilcblx0XHRcdFx0XHRcdC50b2dnbGUodGhpcy5vLmNsZWFyQnRuICE9PSBmYWxzZSk7XG5cdFx0XHR0aGlzLnVwZGF0ZU5hdkFycm93cygpO1xuXHRcdFx0dGhpcy5maWxsTW9udGhzKCk7XG5cdFx0XHR2YXIgcHJldk1vbnRoID0gVVRDRGF0ZSh5ZWFyLCBtb250aC0xLCAyOCwwLDAsMCwwKSxcblx0XHRcdFx0ZGF5ID0gRFBHbG9iYWwuZ2V0RGF5c0luTW9udGgocHJldk1vbnRoLmdldFVUQ0Z1bGxZZWFyKCksIHByZXZNb250aC5nZXRVVENNb250aCgpKTtcblx0XHRcdHByZXZNb250aC5zZXRVVENEYXRlKGRheSk7XG5cdFx0XHRwcmV2TW9udGguc2V0VVRDRGF0ZShkYXkgLSAocHJldk1vbnRoLmdldFVUQ0RheSgpIC0gdGhpcy5vLndlZWtTdGFydCArIDcpJTcpO1xuXHRcdFx0dmFyIG5leHRNb250aCA9IG5ldyBEYXRlKHByZXZNb250aCk7XG5cdFx0XHRuZXh0TW9udGguc2V0VVRDRGF0ZShuZXh0TW9udGguZ2V0VVRDRGF0ZSgpICsgNDIpO1xuXHRcdFx0bmV4dE1vbnRoID0gbmV4dE1vbnRoLnZhbHVlT2YoKTtcblx0XHRcdHZhciBodG1sID0gW107XG5cdFx0XHR2YXIgY2xzTmFtZTtcblx0XHRcdHdoaWxlKHByZXZNb250aC52YWx1ZU9mKCkgPCBuZXh0TW9udGgpIHtcblx0XHRcdFx0aWYgKHByZXZNb250aC5nZXRVVENEYXkoKSA9PSB0aGlzLm8ud2Vla1N0YXJ0KSB7XG5cdFx0XHRcdFx0aHRtbC5wdXNoKCc8dHI+Jyk7XG5cdFx0XHRcdFx0aWYodGhpcy5vLmNhbGVuZGFyV2Vla3Mpe1xuXHRcdFx0XHRcdFx0Ly8gSVNPIDg2MDE6IEZpcnN0IHdlZWsgY29udGFpbnMgZmlyc3QgdGh1cnNkYXkuXG5cdFx0XHRcdFx0XHQvLyBJU08gYWxzbyBzdGF0ZXMgd2VlayBzdGFydHMgb24gTW9uZGF5LCBidXQgd2UgY2FuIGJlIG1vcmUgYWJzdHJhY3QgaGVyZS5cblx0XHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdFx0XHQvLyBTdGFydCBvZiBjdXJyZW50IHdlZWs6IGJhc2VkIG9uIHdlZWtzdGFydC9jdXJyZW50IGRhdGVcblx0XHRcdFx0XHRcdFx0d3MgPSBuZXcgRGF0ZSgrcHJldk1vbnRoICsgKHRoaXMuby53ZWVrU3RhcnQgLSBwcmV2TW9udGguZ2V0VVRDRGF5KCkgLSA3KSAlIDcgKiA4NjRlNSksXG5cdFx0XHRcdFx0XHRcdC8vIFRodXJzZGF5IG9mIHRoaXMgd2Vla1xuXHRcdFx0XHRcdFx0XHR0aCA9IG5ldyBEYXRlKCt3cyArICg3ICsgNCAtIHdzLmdldFVUQ0RheSgpKSAlIDcgKiA4NjRlNSksXG5cdFx0XHRcdFx0XHRcdC8vIEZpcnN0IFRodXJzZGF5IG9mIHllYXIsIHllYXIgZnJvbSB0aHVyc2RheVxuXHRcdFx0XHRcdFx0XHR5dGggPSBuZXcgRGF0ZSgrKHl0aCA9IFVUQ0RhdGUodGguZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSkpICsgKDcgKyA0IC0geXRoLmdldFVUQ0RheSgpKSU3Kjg2NGU1KSxcblx0XHRcdFx0XHRcdFx0Ly8gQ2FsZW5kYXIgd2VlazogbXMgYmV0d2VlbiB0aHVyc2RheXMsIGRpdiBtcyBwZXIgZGF5LCBkaXYgNyBkYXlzXG5cdFx0XHRcdFx0XHRcdGNhbFdlZWsgPSAgKHRoIC0geXRoKSAvIDg2NGU1IC8gNyArIDE7XG5cdFx0XHRcdFx0XHRodG1sLnB1c2goJzx0ZCBjbGFzcz1cImN3XCI+JysgY2FsV2VlayArJzwvdGQ+Jyk7XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2xzTmFtZSA9IHRoaXMuZ2V0Q2xhc3NOYW1lcyhwcmV2TW9udGgpO1xuXHRcdFx0XHRjbHNOYW1lLnB1c2goJ2RheScpO1xuXG5cdFx0XHRcdHZhciBiZWZvcmUgPSB0aGlzLm8uYmVmb3JlU2hvd0RheShwcmV2TW9udGgpO1xuXHRcdFx0XHRpZiAoYmVmb3JlID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0YmVmb3JlID0ge307XG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVvZihiZWZvcmUpID09PSAnYm9vbGVhbicpXG5cdFx0XHRcdFx0YmVmb3JlID0ge2VuYWJsZWQ6IGJlZm9yZX07XG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVvZihiZWZvcmUpID09PSAnc3RyaW5nJylcblx0XHRcdFx0XHRiZWZvcmUgPSB7Y2xhc3NlczogYmVmb3JlfTtcblx0XHRcdFx0aWYgKGJlZm9yZS5lbmFibGVkID09PSBmYWxzZSlcblx0XHRcdFx0XHRjbHNOYW1lLnB1c2goJ2Rpc2FibGVkJyk7XG5cdFx0XHRcdGlmIChiZWZvcmUuY2xhc3Nlcylcblx0XHRcdFx0XHRjbHNOYW1lID0gY2xzTmFtZS5jb25jYXQoYmVmb3JlLmNsYXNzZXMuc3BsaXQoL1xccysvKSk7XG5cdFx0XHRcdGlmIChiZWZvcmUudG9vbHRpcClcblx0XHRcdFx0XHR0b29sdGlwID0gYmVmb3JlLnRvb2x0aXA7XG5cblx0XHRcdFx0Y2xzTmFtZSA9ICQudW5pcXVlKGNsc05hbWUpO1xuXHRcdFx0XHRodG1sLnB1c2goJzx0ZCBjbGFzcz1cIicrY2xzTmFtZS5qb2luKCcgJykrJ1wiJyArICh0b29sdGlwID8gJyB0aXRsZT1cIicrdG9vbHRpcCsnXCInIDogJycpICsgJz4nK3ByZXZNb250aC5nZXRVVENEYXRlKCkgKyAnPC90ZD4nKTtcblx0XHRcdFx0aWYgKHByZXZNb250aC5nZXRVVENEYXkoKSA9PSB0aGlzLm8ud2Vla0VuZCkge1xuXHRcdFx0XHRcdGh0bWwucHVzaCgnPC90cj4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcmV2TW9udGguc2V0VVRDRGF0ZShwcmV2TW9udGguZ2V0VVRDRGF0ZSgpKzEpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLmRhdGVwaWNrZXItZGF5cyB0Ym9keScpLmVtcHR5KCkuYXBwZW5kKGh0bWwuam9pbignJykpO1xuXHRcdFx0dmFyIGN1cnJlbnRZZWFyID0gdGhpcy5kYXRlICYmIHRoaXMuZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuXG5cdFx0XHR2YXIgbW9udGhzID0gdGhpcy5waWNrZXIuZmluZCgnLmRhdGVwaWNrZXItbW9udGhzJylcblx0XHRcdFx0XHRcdC5maW5kKCd0aDplcSgxKScpXG5cdFx0XHRcdFx0XHRcdC50ZXh0KHllYXIpXG5cdFx0XHRcdFx0XHRcdC5lbmQoKVxuXHRcdFx0XHRcdFx0LmZpbmQoJ3NwYW4nKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG5cdFx0XHRpZiAoY3VycmVudFllYXIgJiYgY3VycmVudFllYXIgPT0geWVhcikge1xuXHRcdFx0XHRtb250aHMuZXEodGhpcy5kYXRlLmdldFVUQ01vbnRoKCkpLmFkZENsYXNzKCdhY3RpdmUnKTtcblx0XHRcdH1cblx0XHRcdGlmICh5ZWFyIDwgc3RhcnRZZWFyIHx8IHllYXIgPiBlbmRZZWFyKSB7XG5cdFx0XHRcdG1vbnRocy5hZGRDbGFzcygnZGlzYWJsZWQnKTtcblx0XHRcdH1cblx0XHRcdGlmICh5ZWFyID09IHN0YXJ0WWVhcikge1xuXHRcdFx0XHRtb250aHMuc2xpY2UoMCwgc3RhcnRNb250aCkuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoeWVhciA9PSBlbmRZZWFyKSB7XG5cdFx0XHRcdG1vbnRocy5zbGljZShlbmRNb250aCsxKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcblx0XHRcdH1cblxuXHRcdFx0aHRtbCA9ICcnO1xuXHRcdFx0eWVhciA9IHBhcnNlSW50KHllYXIvMTAsIDEwKSAqIDEwO1xuXHRcdFx0dmFyIHllYXJDb250ID0gdGhpcy5waWNrZXIuZmluZCgnLmRhdGVwaWNrZXIteWVhcnMnKVxuXHRcdFx0XHRcdFx0XHRcdC5maW5kKCd0aDplcSgxKScpXG5cdFx0XHRcdFx0XHRcdFx0XHQudGV4dCh5ZWFyICsgJy0nICsgKHllYXIgKyA5KSlcblx0XHRcdFx0XHRcdFx0XHRcdC5lbmQoKVxuXHRcdFx0XHRcdFx0XHRcdC5maW5kKCd0ZCcpO1xuXHRcdFx0eWVhciAtPSAxO1xuXHRcdFx0Zm9yICh2YXIgaSA9IC0xOyBpIDwgMTE7IGkrKykge1xuXHRcdFx0XHRodG1sICs9ICc8c3BhbiBjbGFzcz1cInllYXInKyhpID09IC0xID8gJyBvbGQnIDogaSA9PSAxMCA/ICcgbmV3JyA6ICcnKSsoY3VycmVudFllYXIgPT0geWVhciA/ICcgYWN0aXZlJyA6ICcnKSsoeWVhciA8IHN0YXJ0WWVhciB8fCB5ZWFyID4gZW5kWWVhciA/ICcgZGlzYWJsZWQnIDogJycpKydcIj4nK3llYXIrJzwvc3Bhbj4nO1xuXHRcdFx0XHR5ZWFyICs9IDE7XG5cdFx0XHR9XG5cdFx0XHR5ZWFyQ29udC5odG1sKGh0bWwpO1xuXHRcdH0sXG5cblx0XHR1cGRhdGVOYXZBcnJvd3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCF0aGlzLl9hbGxvd191cGRhdGUpIHJldHVybjtcblxuXHRcdFx0dmFyIGQgPSBuZXcgRGF0ZSh0aGlzLnZpZXdEYXRlKSxcblx0XHRcdFx0eWVhciA9IGQuZ2V0VVRDRnVsbFllYXIoKSxcblx0XHRcdFx0bW9udGggPSBkLmdldFVUQ01vbnRoKCk7XG5cdFx0XHRzd2l0Y2ggKHRoaXMudmlld01vZGUpIHtcblx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdGlmICh0aGlzLm8uc3RhcnREYXRlICE9PSAtSW5maW5pdHkgJiYgeWVhciA8PSB0aGlzLm8uc3RhcnREYXRlLmdldFVUQ0Z1bGxZZWFyKCkgJiYgbW9udGggPD0gdGhpcy5vLnN0YXJ0RGF0ZS5nZXRVVENNb250aCgpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5maW5kKCcucHJldicpLmNzcyh7dmlzaWJpbGl0eTogJ2hpZGRlbid9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLnByZXYnKS5jc3Moe3Zpc2liaWxpdHk6ICd2aXNpYmxlJ30pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5vLmVuZERhdGUgIT09IEluZmluaXR5ICYmIHllYXIgPj0gdGhpcy5vLmVuZERhdGUuZ2V0VVRDRnVsbFllYXIoKSAmJiBtb250aCA+PSB0aGlzLm8uZW5kRGF0ZS5nZXRVVENNb250aCgpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5maW5kKCcubmV4dCcpLmNzcyh7dmlzaWJpbGl0eTogJ2hpZGRlbid9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLm5leHQnKS5jc3Moe3Zpc2liaWxpdHk6ICd2aXNpYmxlJ30pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0aWYgKHRoaXMuby5zdGFydERhdGUgIT09IC1JbmZpbml0eSAmJiB5ZWFyIDw9IHRoaXMuby5zdGFydERhdGUuZ2V0VVRDRnVsbFllYXIoKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLnByZXYnKS5jc3Moe3Zpc2liaWxpdHk6ICdoaWRkZW4nfSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5wcmV2JykuY3NzKHt2aXNpYmlsaXR5OiAndmlzaWJsZSd9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuby5lbmREYXRlICE9PSBJbmZpbml0eSAmJiB5ZWFyID49IHRoaXMuby5lbmREYXRlLmdldFVUQ0Z1bGxZZWFyKCkpIHtcblx0XHRcdFx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5uZXh0JykuY3NzKHt2aXNpYmlsaXR5OiAnaGlkZGVuJ30pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5maW5kKCcubmV4dCcpLmNzcyh7dmlzaWJpbGl0eTogJ3Zpc2libGUnfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjbGljazogZnVuY3Rpb24oZSkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0dmFyIHRhcmdldCA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJ3NwYW4sIHRkLCB0aCcpO1xuXHRcdFx0aWYgKHRhcmdldC5sZW5ndGggPT0gMSkge1xuXHRcdFx0XHRzd2l0Y2godGFyZ2V0WzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcblx0XHRcdFx0XHRjYXNlICd0aCc6XG5cdFx0XHRcdFx0XHRzd2l0Y2godGFyZ2V0WzBdLmNsYXNzTmFtZSkge1xuXHRcdFx0XHRcdFx0XHRjYXNlICdkYXRlcGlja2VyLXN3aXRjaCc6XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zaG93TW9kZSgxKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAncHJldic6XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ25leHQnOlxuXHRcdFx0XHRcdFx0XHRcdHZhciBkaXIgPSBEUEdsb2JhbC5tb2Rlc1t0aGlzLnZpZXdNb2RlXS5uYXZTdGVwICogKHRhcmdldFswXS5jbGFzc05hbWUgPT0gJ3ByZXYnID8gLTEgOiAxKTtcblx0XHRcdFx0XHRcdFx0XHRzd2l0Y2godGhpcy52aWV3TW9kZSl7XG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlIDA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMudmlld0RhdGUgPSB0aGlzLm1vdmVNb250aCh0aGlzLnZpZXdEYXRlLCBkaXIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy52aWV3RGF0ZSA9IHRoaXMubW92ZVllYXIodGhpcy52aWV3RGF0ZSwgZGlyKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZmlsbCgpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlICd0b2RheSc6XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGUgPSBVVENEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSwgMCwgMCwgMCk7XG5cblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNob3dNb2RlKC0yKTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgd2hpY2ggPSB0aGlzLm8udG9kYXlCdG4gPT0gJ2xpbmtlZCcgPyBudWxsIDogJ3ZpZXcnO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3NldERhdGUoZGF0ZSwgd2hpY2gpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlICdjbGVhcic6XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGVsZW1lbnQ7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuaXNJbnB1dClcblx0XHRcdFx0XHRcdFx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAodGhpcy5jb21wb25lbnQpXG5cdFx0XHRcdFx0XHRcdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50LmZpbmQoJ2lucHV0Jyk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGVsZW1lbnQpXG5cdFx0XHRcdFx0XHRcdFx0XHRlbGVtZW50LnZhbChcIlwiKS5jaGFuZ2UoKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjaGFuZ2VEYXRlJyk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAodGhpcy5vLmF1dG9jbG9zZSlcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuaGlkZSgpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnc3Bhbic6XG5cdFx0XHRcdFx0XHRpZiAoIXRhcmdldC5pcygnLmRpc2FibGVkJykpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy52aWV3RGF0ZS5zZXRVVENEYXRlKDEpO1xuXHRcdFx0XHRcdFx0XHRpZiAodGFyZ2V0LmlzKCcubW9udGgnKSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBkYXkgPSAxO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBtb250aCA9IHRhcmdldC5wYXJlbnQoKS5maW5kKCdzcGFuJykuaW5kZXgodGFyZ2V0KTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgeWVhciA9IHRoaXMudmlld0RhdGUuZ2V0VVRDRnVsbFllYXIoKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnZpZXdEYXRlLnNldFVUQ01vbnRoKG1vbnRoKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjaGFuZ2VNb250aCcsIHRoaXMudmlld0RhdGUpO1xuXHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLm8ubWluVmlld01vZGUgPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX3NldERhdGUoVVRDRGF0ZSh5ZWFyLCBtb250aCwgZGF5LDAsMCwwLDApKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHllYXIgPSBwYXJzZUludCh0YXJnZXQudGV4dCgpLCAxMCl8fDA7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGRheSA9IDE7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIG1vbnRoID0gMDtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnZpZXdEYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3RyaWdnZXIoJ2NoYW5nZVllYXInLCB0aGlzLnZpZXdEYXRlKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAodGhpcy5vLm1pblZpZXdNb2RlID09PSAyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zZXREYXRlKFVUQ0RhdGUoeWVhciwgbW9udGgsIGRheSwwLDAsMCwwKSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2hvd01vZGUoLTEpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLmZpbGwoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3RkJzpcblx0XHRcdFx0XHRcdGlmICh0YXJnZXQuaXMoJy5kYXknKSAmJiAhdGFyZ2V0LmlzKCcuZGlzYWJsZWQnKSl7XG5cdFx0XHRcdFx0XHRcdHZhciBkYXkgPSBwYXJzZUludCh0YXJnZXQudGV4dCgpLCAxMCl8fDE7XG5cdFx0XHRcdFx0XHRcdHZhciB5ZWFyID0gdGhpcy52aWV3RGF0ZS5nZXRVVENGdWxsWWVhcigpLFxuXHRcdFx0XHRcdFx0XHRcdG1vbnRoID0gdGhpcy52aWV3RGF0ZS5nZXRVVENNb250aCgpO1xuXHRcdFx0XHRcdFx0XHRpZiAodGFyZ2V0LmlzKCcub2xkJykpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAobW9udGggPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1vbnRoID0gMTE7XG5cdFx0XHRcdFx0XHRcdFx0XHR5ZWFyIC09IDE7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1vbnRoIC09IDE7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHRhcmdldC5pcygnLm5ldycpKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKG1vbnRoID09IDExKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtb250aCA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHR5ZWFyICs9IDE7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1vbnRoICs9IDE7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3NldERhdGUoVVRDRGF0ZSh5ZWFyLCBtb250aCwgZGF5LDAsMCwwLDApKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9zZXREYXRlOiBmdW5jdGlvbihkYXRlLCB3aGljaCl7XG5cdFx0XHRpZiAoIXdoaWNoIHx8IHdoaWNoID09ICdkYXRlJylcblx0XHRcdFx0dGhpcy5kYXRlID0gbmV3IERhdGUoZGF0ZSk7XG5cdFx0XHRpZiAoIXdoaWNoIHx8IHdoaWNoICA9PSAndmlldycpXG5cdFx0XHRcdHRoaXMudmlld0RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcblx0XHRcdHRoaXMuZmlsbCgpO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZSgpO1xuXHRcdFx0dGhpcy5fdHJpZ2dlcignY2hhbmdlRGF0ZScpO1xuXHRcdFx0dmFyIGVsZW1lbnQ7XG5cdFx0XHRpZiAodGhpcy5pc0lucHV0KSB7XG5cdFx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuY29tcG9uZW50KXtcblx0XHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudC5maW5kKCdpbnB1dCcpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdFx0ZWxlbWVudC5jaGFuZ2UoKTtcblx0XHRcdFx0aWYgKHRoaXMuby5hdXRvY2xvc2UgJiYgKCF3aGljaCB8fCB3aGljaCA9PSAnZGF0ZScpKSB7XG5cdFx0XHRcdFx0dGhpcy5oaWRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0bW92ZU1vbnRoOiBmdW5jdGlvbihkYXRlLCBkaXIpe1xuXHRcdFx0aWYgKCFkaXIpIHJldHVybiBkYXRlO1xuXHRcdFx0dmFyIG5ld19kYXRlID0gbmV3IERhdGUoZGF0ZS52YWx1ZU9mKCkpLFxuXHRcdFx0XHRkYXkgPSBuZXdfZGF0ZS5nZXRVVENEYXRlKCksXG5cdFx0XHRcdG1vbnRoID0gbmV3X2RhdGUuZ2V0VVRDTW9udGgoKSxcblx0XHRcdFx0bWFnID0gTWF0aC5hYnMoZGlyKSxcblx0XHRcdFx0bmV3X21vbnRoLCB0ZXN0O1xuXHRcdFx0ZGlyID0gZGlyID4gMCA/IDEgOiAtMTtcblx0XHRcdGlmIChtYWcgPT0gMSl7XG5cdFx0XHRcdHRlc3QgPSBkaXIgPT0gLTFcblx0XHRcdFx0XHQvLyBJZiBnb2luZyBiYWNrIG9uZSBtb250aCwgbWFrZSBzdXJlIG1vbnRoIGlzIG5vdCBjdXJyZW50IG1vbnRoXG5cdFx0XHRcdFx0Ly8gKGVnLCBNYXIgMzEgLT4gRmViIDMxID09IEZlYiAyOCwgbm90IE1hciAwMilcblx0XHRcdFx0XHQ/IGZ1bmN0aW9uKCl7IHJldHVybiBuZXdfZGF0ZS5nZXRVVENNb250aCgpID09IG1vbnRoOyB9XG5cdFx0XHRcdFx0Ly8gSWYgZ29pbmcgZm9yd2FyZCBvbmUgbW9udGgsIG1ha2Ugc3VyZSBtb250aCBpcyBhcyBleHBlY3RlZFxuXHRcdFx0XHRcdC8vIChlZywgSmFuIDMxIC0+IEZlYiAzMSA9PSBGZWIgMjgsIG5vdCBNYXIgMDIpXG5cdFx0XHRcdFx0OiBmdW5jdGlvbigpeyByZXR1cm4gbmV3X2RhdGUuZ2V0VVRDTW9udGgoKSAhPSBuZXdfbW9udGg7IH07XG5cdFx0XHRcdG5ld19tb250aCA9IG1vbnRoICsgZGlyO1xuXHRcdFx0XHRuZXdfZGF0ZS5zZXRVVENNb250aChuZXdfbW9udGgpO1xuXHRcdFx0XHQvLyBEZWMgLT4gSmFuICgxMikgb3IgSmFuIC0+IERlYyAoLTEpIC0tIGxpbWl0IGV4cGVjdGVkIGRhdGUgdG8gMC0xMVxuXHRcdFx0XHRpZiAobmV3X21vbnRoIDwgMCB8fCBuZXdfbW9udGggPiAxMSlcblx0XHRcdFx0XHRuZXdfbW9udGggPSAobmV3X21vbnRoICsgMTIpICUgMTI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBGb3IgbWFnbml0dWRlcyA+MSwgbW92ZSBvbmUgbW9udGggYXQgYSB0aW1lLi4uXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTxtYWc7IGkrKylcblx0XHRcdFx0XHQvLyAuLi53aGljaCBtaWdodCBkZWNyZWFzZSB0aGUgZGF5IChlZywgSmFuIDMxIHRvIEZlYiAyOCwgZXRjKS4uLlxuXHRcdFx0XHRcdG5ld19kYXRlID0gdGhpcy5tb3ZlTW9udGgobmV3X2RhdGUsIGRpcik7XG5cdFx0XHRcdC8vIC4uLnRoZW4gcmVzZXQgdGhlIGRheSwga2VlcGluZyBpdCBpbiB0aGUgbmV3IG1vbnRoXG5cdFx0XHRcdG5ld19tb250aCA9IG5ld19kYXRlLmdldFVUQ01vbnRoKCk7XG5cdFx0XHRcdG5ld19kYXRlLnNldFVUQ0RhdGUoZGF5KTtcblx0XHRcdFx0dGVzdCA9IGZ1bmN0aW9uKCl7IHJldHVybiBuZXdfbW9udGggIT0gbmV3X2RhdGUuZ2V0VVRDTW9udGgoKTsgfTtcblx0XHRcdH1cblx0XHRcdC8vIENvbW1vbiBkYXRlLXJlc2V0dGluZyBsb29wIC0tIGlmIGRhdGUgaXMgYmV5b25kIGVuZCBvZiBtb250aCwgbWFrZSBpdFxuXHRcdFx0Ly8gZW5kIG9mIG1vbnRoXG5cdFx0XHR3aGlsZSAodGVzdCgpKXtcblx0XHRcdFx0bmV3X2RhdGUuc2V0VVRDRGF0ZSgtLWRheSk7XG5cdFx0XHRcdG5ld19kYXRlLnNldFVUQ01vbnRoKG5ld19tb250aCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3X2RhdGU7XG5cdFx0fSxcblxuXHRcdG1vdmVZZWFyOiBmdW5jdGlvbihkYXRlLCBkaXIpe1xuXHRcdFx0cmV0dXJuIHRoaXMubW92ZU1vbnRoKGRhdGUsIGRpcioxMik7XG5cdFx0fSxcblxuXHRcdGRhdGVXaXRoaW5SYW5nZTogZnVuY3Rpb24oZGF0ZSl7XG5cdFx0XHRyZXR1cm4gZGF0ZSA+PSB0aGlzLm8uc3RhcnREYXRlICYmIGRhdGUgPD0gdGhpcy5vLmVuZERhdGU7XG5cdFx0fSxcblxuXHRcdGtleWRvd246IGZ1bmN0aW9uKGUpe1xuXHRcdFx0aWYgKHRoaXMucGlja2VyLmlzKCc6bm90KDp2aXNpYmxlKScpKXtcblx0XHRcdFx0aWYgKGUua2V5Q29kZSA9PSAyNykgLy8gYWxsb3cgZXNjYXBlIHRvIGhpZGUgYW5kIHJlLXNob3cgcGlja2VyXG5cdFx0XHRcdFx0dGhpcy5zaG93KCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBkYXRlQ2hhbmdlZCA9IGZhbHNlLFxuXHRcdFx0XHRkaXIsIGRheSwgbW9udGgsXG5cdFx0XHRcdG5ld0RhdGUsIG5ld1ZpZXdEYXRlO1xuXHRcdFx0c3dpdGNoKGUua2V5Q29kZSl7XG5cdFx0XHRcdGNhc2UgMjc6IC8vIGVzY2FwZVxuXHRcdFx0XHRcdHRoaXMuaGlkZSgpO1xuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAzNzogLy8gbGVmdFxuXHRcdFx0XHRjYXNlIDM5OiAvLyByaWdodFxuXHRcdFx0XHRcdGlmICghdGhpcy5vLmtleWJvYXJkTmF2aWdhdGlvbikgYnJlYWs7XG5cdFx0XHRcdFx0ZGlyID0gZS5rZXlDb2RlID09IDM3ID8gLTEgOiAxO1xuXHRcdFx0XHRcdGlmIChlLmN0cmxLZXkpe1xuXHRcdFx0XHRcdFx0bmV3RGF0ZSA9IHRoaXMubW92ZVllYXIodGhpcy5kYXRlLCBkaXIpO1xuXHRcdFx0XHRcdFx0bmV3Vmlld0RhdGUgPSB0aGlzLm1vdmVZZWFyKHRoaXMudmlld0RhdGUsIGRpcik7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChlLnNoaWZ0S2V5KXtcblx0XHRcdFx0XHRcdG5ld0RhdGUgPSB0aGlzLm1vdmVNb250aCh0aGlzLmRhdGUsIGRpcik7XG5cdFx0XHRcdFx0XHRuZXdWaWV3RGF0ZSA9IHRoaXMubW92ZU1vbnRoKHRoaXMudmlld0RhdGUsIGRpcik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5ld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLmRhdGUpO1xuXHRcdFx0XHRcdFx0bmV3RGF0ZS5zZXRVVENEYXRlKHRoaXMuZGF0ZS5nZXRVVENEYXRlKCkgKyBkaXIpO1xuXHRcdFx0XHRcdFx0bmV3Vmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLnZpZXdEYXRlKTtcblx0XHRcdFx0XHRcdG5ld1ZpZXdEYXRlLnNldFVUQ0RhdGUodGhpcy52aWV3RGF0ZS5nZXRVVENEYXRlKCkgKyBkaXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5kYXRlV2l0aGluUmFuZ2UobmV3RGF0ZSkpe1xuXHRcdFx0XHRcdFx0dGhpcy5kYXRlID0gbmV3RGF0ZTtcblx0XHRcdFx0XHRcdHRoaXMudmlld0RhdGUgPSBuZXdWaWV3RGF0ZTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0VmFsdWUoKTtcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRkYXRlQ2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDM4OiAvLyB1cFxuXHRcdFx0XHRjYXNlIDQwOiAvLyBkb3duXG5cdFx0XHRcdFx0aWYgKCF0aGlzLm8ua2V5Ym9hcmROYXZpZ2F0aW9uKSBicmVhaztcblx0XHRcdFx0XHRkaXIgPSBlLmtleUNvZGUgPT0gMzggPyAtMSA6IDE7XG5cdFx0XHRcdFx0aWYgKGUuY3RybEtleSl7XG5cdFx0XHRcdFx0XHRuZXdEYXRlID0gdGhpcy5tb3ZlWWVhcih0aGlzLmRhdGUsIGRpcik7XG5cdFx0XHRcdFx0XHRuZXdWaWV3RGF0ZSA9IHRoaXMubW92ZVllYXIodGhpcy52aWV3RGF0ZSwgZGlyKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGUuc2hpZnRLZXkpe1xuXHRcdFx0XHRcdFx0bmV3RGF0ZSA9IHRoaXMubW92ZU1vbnRoKHRoaXMuZGF0ZSwgZGlyKTtcblx0XHRcdFx0XHRcdG5ld1ZpZXdEYXRlID0gdGhpcy5tb3ZlTW9udGgodGhpcy52aWV3RGF0ZSwgZGlyKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bmV3RGF0ZSA9IG5ldyBEYXRlKHRoaXMuZGF0ZSk7XG5cdFx0XHRcdFx0XHRuZXdEYXRlLnNldFVUQ0RhdGUodGhpcy5kYXRlLmdldFVUQ0RhdGUoKSArIGRpciAqIDcpO1xuXHRcdFx0XHRcdFx0bmV3Vmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLnZpZXdEYXRlKTtcblx0XHRcdFx0XHRcdG5ld1ZpZXdEYXRlLnNldFVUQ0RhdGUodGhpcy52aWV3RGF0ZS5nZXRVVENEYXRlKCkgKyBkaXIgKiA3KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuZGF0ZVdpdGhpblJhbmdlKG5ld0RhdGUpKXtcblx0XHRcdFx0XHRcdHRoaXMuZGF0ZSA9IG5ld0RhdGU7XG5cdFx0XHRcdFx0XHR0aGlzLnZpZXdEYXRlID0gbmV3Vmlld0RhdGU7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFZhbHVlKCk7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0ZGF0ZUNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAxMzogLy8gZW50ZXJcblx0XHRcdFx0XHR0aGlzLmhpZGUoKTtcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgOTogLy8gdGFiXG5cdFx0XHRcdFx0dGhpcy5oaWRlKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGF0ZUNoYW5nZWQpe1xuXHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjaGFuZ2VEYXRlJyk7XG5cdFx0XHRcdHZhciBlbGVtZW50O1xuXHRcdFx0XHRpZiAodGhpcy5pc0lucHV0KSB7XG5cdFx0XHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmNvbXBvbmVudCl7XG5cdFx0XHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudC5maW5kKCdpbnB1dCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRcdFx0ZWxlbWVudC5jaGFuZ2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzaG93TW9kZTogZnVuY3Rpb24oZGlyKSB7XG5cdFx0XHRpZiAoZGlyKSB7XG5cdFx0XHRcdHRoaXMudmlld01vZGUgPSBNYXRoLm1heCh0aGlzLm8ubWluVmlld01vZGUsIE1hdGgubWluKDIsIHRoaXMudmlld01vZGUgKyBkaXIpKTtcblx0XHRcdH1cblx0XHRcdC8qXG5cdFx0XHRcdHZpdGFsZXRzOiBmaXhpbmcgYnVnIG9mIHZlcnkgc3BlY2lhbCBjb25kaXRpb25zOlxuXHRcdFx0XHRqcXVlcnkgMS43LjEgKyB3ZWJraXQgKyBzaG93IGlubGluZSBkYXRlcGlja2VyIGluIGJvb3RzdHJhcCBwb3BvdmVyLlxuXHRcdFx0XHRNZXRob2Qgc2hvdygpIGRvZXMgbm90IHNldCBkaXNwbGF5IGNzcyBjb3JyZWN0bHkgYW5kIGRhdGVwaWNrZXIgaXMgbm90IHNob3duLlxuXHRcdFx0XHRDaGFuZ2VkIHRvIC5jc3MoJ2Rpc3BsYXknLCAnYmxvY2snKSBzb2x2ZSB0aGUgcHJvYmxlbS5cblx0XHRcdFx0U2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRhbGV0cy94LWVkaXRhYmxlL2lzc3Vlcy8zN1xuXG5cdFx0XHRcdEluIGpxdWVyeSAxLjcuMisgZXZlcnl0aGluZyB3b3JrcyBmaW5lLlxuXHRcdFx0Ki9cblx0XHRcdC8vdGhpcy5waWNrZXIuZmluZCgnPmRpdicpLmhpZGUoKS5maWx0ZXIoJy5kYXRlcGlja2VyLScrRFBHbG9iYWwubW9kZXNbdGhpcy52aWV3TW9kZV0uY2xzTmFtZSkuc2hvdygpO1xuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgnPmRpdicpLmhpZGUoKS5maWx0ZXIoJy5kYXRlcGlja2VyLScrRFBHbG9iYWwubW9kZXNbdGhpcy52aWV3TW9kZV0uY2xzTmFtZSkuY3NzKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XG5cdFx0XHR0aGlzLnVwZGF0ZU5hdkFycm93cygpO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgRGF0ZVJhbmdlUGlja2VyID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucyl7XG5cdFx0dGhpcy5lbGVtZW50ID0gJChlbGVtZW50KTtcblx0XHR0aGlzLmlucHV0cyA9ICQubWFwKG9wdGlvbnMuaW5wdXRzLCBmdW5jdGlvbihpKXsgcmV0dXJuIGkuanF1ZXJ5ID8gaVswXSA6IGk7IH0pO1xuXHRcdGRlbGV0ZSBvcHRpb25zLmlucHV0cztcblxuXHRcdCQodGhpcy5pbnB1dHMpXG5cdFx0XHQuZGF0ZXBpY2tlcihvcHRpb25zKVxuXHRcdFx0LmJpbmQoJ2NoYW5nZURhdGUnLCAkLnByb3h5KHRoaXMuZGF0ZVVwZGF0ZWQsIHRoaXMpKTtcblxuXHRcdHRoaXMucGlja2VycyA9ICQubWFwKHRoaXMuaW5wdXRzLCBmdW5jdGlvbihpKXsgcmV0dXJuICQoaSkuZGF0YSgnZGF0ZXBpY2tlcicpOyB9KTtcblx0XHR0aGlzLnVwZGF0ZURhdGVzKCk7XG5cdH07XG5cdERhdGVSYW5nZVBpY2tlci5wcm90b3R5cGUgPSB7XG5cdFx0dXBkYXRlRGF0ZXM6IGZ1bmN0aW9uKCl7XG5cdFx0XHR0aGlzLmRhdGVzID0gJC5tYXAodGhpcy5waWNrZXJzLCBmdW5jdGlvbihpKXsgcmV0dXJuIGkuZGF0ZTsgfSk7XG5cdFx0XHR0aGlzLnVwZGF0ZVJhbmdlcygpO1xuXHRcdH0sXG5cdFx0dXBkYXRlUmFuZ2VzOiBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIHJhbmdlID0gJC5tYXAodGhpcy5kYXRlcywgZnVuY3Rpb24oZCl7IHJldHVybiBkLnZhbHVlT2YoKTsgfSk7XG5cdFx0XHQkLmVhY2godGhpcy5waWNrZXJzLCBmdW5jdGlvbihpLCBwKXtcblx0XHRcdFx0cC5zZXRSYW5nZShyYW5nZSk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdGRhdGVVcGRhdGVkOiBmdW5jdGlvbihlKXtcblx0XHRcdHZhciBkcCA9ICQoZS50YXJnZXQpLmRhdGEoJ2RhdGVwaWNrZXInKSxcblx0XHRcdFx0bmV3X2RhdGUgPSBkcC5nZXRVVENEYXRlKCksXG5cdFx0XHRcdGkgPSAkLmluQXJyYXkoZS50YXJnZXQsIHRoaXMuaW5wdXRzKSxcblx0XHRcdFx0bCA9IHRoaXMuaW5wdXRzLmxlbmd0aDtcblx0XHRcdGlmIChpID09IC0xKSByZXR1cm47XG5cblx0XHRcdGlmIChuZXdfZGF0ZSA8IHRoaXMuZGF0ZXNbaV0pe1xuXHRcdFx0XHQvLyBEYXRlIGJlaW5nIG1vdmVkIGVhcmxpZXIvbGVmdFxuXHRcdFx0XHR3aGlsZSAoaT49MCAmJiBuZXdfZGF0ZSA8IHRoaXMuZGF0ZXNbaV0pe1xuXHRcdFx0XHRcdHRoaXMucGlja2Vyc1tpLS1dLnNldFVUQ0RhdGUobmV3X2RhdGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChuZXdfZGF0ZSA+IHRoaXMuZGF0ZXNbaV0pe1xuXHRcdFx0XHQvLyBEYXRlIGJlaW5nIG1vdmVkIGxhdGVyL3JpZ2h0XG5cdFx0XHRcdHdoaWxlIChpPGwgJiYgbmV3X2RhdGUgPiB0aGlzLmRhdGVzW2ldKXtcblx0XHRcdFx0XHR0aGlzLnBpY2tlcnNbaSsrXS5zZXRVVENEYXRlKG5ld19kYXRlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy51cGRhdGVEYXRlcygpO1xuXHRcdH0sXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbigpe1xuXHRcdFx0JC5tYXAodGhpcy5waWNrZXJzLCBmdW5jdGlvbihwKXsgcC5yZW1vdmUoKTsgfSk7XG5cdFx0XHRkZWxldGUgdGhpcy5lbGVtZW50LmRhdGEoKS5kYXRlcGlja2VyO1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBvcHRzX2Zyb21fZWwoZWwsIHByZWZpeCl7XG5cdFx0Ly8gRGVyaXZlIG9wdGlvbnMgZnJvbSBlbGVtZW50IGRhdGEtYXR0cnNcblx0XHR2YXIgZGF0YSA9ICQoZWwpLmRhdGEoKSxcblx0XHRcdG91dCA9IHt9LCBpbmtleSxcblx0XHRcdHJlcGxhY2UgPSBuZXcgUmVnRXhwKCdeJyArIHByZWZpeC50b0xvd2VyQ2FzZSgpICsgJyhbQS1aXSknKSxcblx0XHRcdHByZWZpeCA9IG5ldyBSZWdFeHAoJ14nICsgcHJlZml4LnRvTG93ZXJDYXNlKCkpO1xuXHRcdGZvciAodmFyIGtleSBpbiBkYXRhKVxuXHRcdFx0aWYgKHByZWZpeC50ZXN0KGtleSkpe1xuXHRcdFx0XHRpbmtleSA9IGtleS5yZXBsYWNlKHJlcGxhY2UsIGZ1bmN0aW9uKF8sYSl7IHJldHVybiBhLnRvTG93ZXJDYXNlKCk7IH0pO1xuXHRcdFx0XHRvdXRbaW5rZXldID0gZGF0YVtrZXldO1xuXHRcdFx0fVxuXHRcdHJldHVybiBvdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBvcHRzX2Zyb21fbG9jYWxlKGxhbmcpe1xuXHRcdC8vIERlcml2ZSBvcHRpb25zIGZyb20gbG9jYWxlIHBsdWdpbnNcblx0XHR2YXIgb3V0ID0ge307XG5cdFx0Ly8gQ2hlY2sgaWYgXCJkZS1ERVwiIHN0eWxlIGRhdGUgaXMgYXZhaWxhYmxlLCBpZiBub3QgbGFuZ3VhZ2Ugc2hvdWxkXG5cdFx0Ly8gZmFsbGJhY2sgdG8gMiBsZXR0ZXIgY29kZSBlZyBcImRlXCJcblx0XHRpZiAoIWRhdGVzW2xhbmddKSB7XG5cdFx0XHRsYW5nID0gbGFuZy5zcGxpdCgnLScpWzBdXG5cdFx0XHRpZiAoIWRhdGVzW2xhbmddKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBkID0gZGF0ZXNbbGFuZ107XG5cdFx0JC5lYWNoKGxvY2FsZV9vcHRzLCBmdW5jdGlvbihpLGspe1xuXHRcdFx0aWYgKGsgaW4gZClcblx0XHRcdFx0b3V0W2tdID0gZFtrXTtcblx0XHR9KTtcblx0XHRyZXR1cm4gb3V0O1xuXHR9XG5cblx0dmFyIG9sZCA9ICQuZm4uZGF0ZXBpY2tlcjtcblx0dmFyIGRhdGVwaWNrZXIgPSAkLmZuLmRhdGVwaWNrZXIgPSBmdW5jdGlvbiAoIG9wdGlvbiApIHtcblx0XHR2YXIgYXJncyA9IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdFx0YXJncy5zaGlmdCgpO1xuXHRcdHZhciBpbnRlcm5hbF9yZXR1cm4sXG5cdFx0XHR0aGlzX3JldHVybjtcblx0XHR0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyICR0aGlzID0gJCh0aGlzKSxcblx0XHRcdFx0ZGF0YSA9ICR0aGlzLmRhdGEoJ2RhdGVwaWNrZXInKSxcblx0XHRcdFx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uO1xuXHRcdFx0aWYgKCFkYXRhKSB7XG5cdFx0XHRcdHZhciBlbG9wdHMgPSBvcHRzX2Zyb21fZWwodGhpcywgJ2RhdGUnKSxcblx0XHRcdFx0XHQvLyBQcmVsaW1pbmFyeSBvdGlvbnNcblx0XHRcdFx0XHR4b3B0cyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgZWxvcHRzLCBvcHRpb25zKSxcblx0XHRcdFx0XHRsb2NvcHRzID0gb3B0c19mcm9tX2xvY2FsZSh4b3B0cy5sYW5ndWFnZSksXG5cdFx0XHRcdFx0Ly8gT3B0aW9ucyBwcmlvcml0eToganMgYXJncywgZGF0YS1hdHRycywgbG9jYWxlcywgZGVmYXVsdHNcblx0XHRcdFx0XHRvcHRzID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLCBsb2NvcHRzLCBlbG9wdHMsIG9wdGlvbnMpO1xuXHRcdFx0XHRpZiAoJHRoaXMuaXMoJy5pbnB1dC1kYXRlcmFuZ2UnKSB8fCBvcHRzLmlucHV0cyl7XG5cdFx0XHRcdFx0dmFyIHJvcHRzID0ge1xuXHRcdFx0XHRcdFx0aW5wdXRzOiBvcHRzLmlucHV0cyB8fCAkdGhpcy5maW5kKCdpbnB1dCcpLnRvQXJyYXkoKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0JHRoaXMuZGF0YSgnZGF0ZXBpY2tlcicsIChkYXRhID0gbmV3IERhdGVSYW5nZVBpY2tlcih0aGlzLCAkLmV4dGVuZChvcHRzLCByb3B0cykpKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZXtcblx0XHRcdFx0XHQkdGhpcy5kYXRhKCdkYXRlcGlja2VyJywgKGRhdGEgPSBuZXcgRGF0ZXBpY2tlcih0aGlzLCBvcHRzKSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZGF0YVtvcHRpb25dID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0aW50ZXJuYWxfcmV0dXJuID0gZGF0YVtvcHRpb25dLmFwcGx5KGRhdGEsIGFyZ3MpO1xuXHRcdFx0XHRpZiAoaW50ZXJuYWxfcmV0dXJuICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGlmIChpbnRlcm5hbF9yZXR1cm4gIT09IHVuZGVmaW5lZClcblx0XHRcdHJldHVybiBpbnRlcm5hbF9yZXR1cm47XG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0dmFyIGRlZmF1bHRzID0gJC5mbi5kYXRlcGlja2VyLmRlZmF1bHRzID0ge1xuXHRcdGF1dG9jbG9zZTogZmFsc2UsXG5cdFx0YmVmb3JlU2hvd0RheTogJC5ub29wLFxuXHRcdGNhbGVuZGFyV2Vla3M6IGZhbHNlLFxuXHRcdGNsZWFyQnRuOiBmYWxzZSxcblx0XHRkYXlzT2ZXZWVrRGlzYWJsZWQ6IFtdLFxuXHRcdGVuZERhdGU6IEluZmluaXR5LFxuXHRcdGZvcmNlUGFyc2U6IHRydWUsXG5cdFx0Zm9ybWF0OiAnbW0vZGQveXl5eScsXG5cdFx0a2V5Ym9hcmROYXZpZ2F0aW9uOiB0cnVlLFxuXHRcdGxhbmd1YWdlOiAnZW4nLFxuXHRcdG1pblZpZXdNb2RlOiAwLFxuXHRcdHJ0bDogZmFsc2UsXG5cdFx0c3RhcnREYXRlOiAtSW5maW5pdHksXG5cdFx0c3RhcnRWaWV3OiAwLFxuXHRcdHRvZGF5QnRuOiBmYWxzZSxcblx0XHR0b2RheUhpZ2hsaWdodDogZmFsc2UsXG5cdFx0d2Vla1N0YXJ0OiAwXG5cdH07XG5cdHZhciBsb2NhbGVfb3B0cyA9ICQuZm4uZGF0ZXBpY2tlci5sb2NhbGVfb3B0cyA9IFtcblx0XHQnZm9ybWF0Jyxcblx0XHQncnRsJyxcblx0XHQnd2Vla1N0YXJ0J1xuXHRdO1xuXHQkLmZuLmRhdGVwaWNrZXIuQ29uc3RydWN0b3IgPSBEYXRlcGlja2VyO1xuXHR2YXIgZGF0ZXMgPSAkLmZuLmRhdGVwaWNrZXIuZGF0ZXMgPSB7XG5cdFx0ZW46IHtcblx0XHRcdGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCIsIFwiU3VuZGF5XCJdLFxuXHRcdFx0ZGF5c1Nob3J0OiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIiwgXCJTdW5cIl0sXG5cdFx0XHRkYXlzTWluOiBbXCJTdVwiLCBcIk1vXCIsIFwiVHVcIiwgXCJXZVwiLCBcIlRoXCIsIFwiRnJcIiwgXCJTYVwiLCBcIlN1XCJdLFxuXHRcdFx0bW9udGhzOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSxcblx0XHRcdG1vbnRoc1Nob3J0OiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl0sXG5cdFx0XHR0b2RheTogXCJUb2RheVwiLFxuXHRcdFx0Y2xlYXI6IFwiQ2xlYXJcIlxuXHRcdH1cblx0fTtcblxuXHR2YXIgRFBHbG9iYWwgPSB7XG5cdFx0bW9kZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0Y2xzTmFtZTogJ2RheXMnLFxuXHRcdFx0XHRuYXZGbmM6ICdNb250aCcsXG5cdFx0XHRcdG5hdlN0ZXA6IDFcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdGNsc05hbWU6ICdtb250aHMnLFxuXHRcdFx0XHRuYXZGbmM6ICdGdWxsWWVhcicsXG5cdFx0XHRcdG5hdlN0ZXA6IDFcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdGNsc05hbWU6ICd5ZWFycycsXG5cdFx0XHRcdG5hdkZuYzogJ0Z1bGxZZWFyJyxcblx0XHRcdFx0bmF2U3RlcDogMTBcblx0XHR9XSxcblx0XHRpc0xlYXBZZWFyOiBmdW5jdGlvbiAoeWVhcikge1xuXHRcdFx0cmV0dXJuICgoKHllYXIgJSA0ID09PSAwKSAmJiAoeWVhciAlIDEwMCAhPT0gMCkpIHx8ICh5ZWFyICUgNDAwID09PSAwKSk7XG5cdFx0fSxcblx0XHRnZXREYXlzSW5Nb250aDogZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XG5cdFx0XHRyZXR1cm4gWzMxLCAoRFBHbG9iYWwuaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogMjgpLCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV1bbW9udGhdO1xuXHRcdH0sXG5cdFx0dmFsaWRQYXJ0czogL2RkP3xERD98bW0/fE1NP3x5eSg/Onl5KT8vZyxcblx0XHRub25wdW5jdHVhdGlvbjogL1teIC1cXC86LUBcXFtcXHUzNDAwLVxcdTlmZmYtYHstflxcdFxcblxccl0rL2csXG5cdFx0cGFyc2VGb3JtYXQ6IGZ1bmN0aW9uKGZvcm1hdCl7XG5cdFx0XHQvLyBJRSB0cmVhdHMgXFwwIGFzIGEgc3RyaW5nIGVuZCBpbiBpbnB1dHMgKHRydW5jYXRpbmcgdGhlIHZhbHVlKSxcblx0XHRcdC8vIHNvIGl0J3MgYSBiYWQgZm9ybWF0IGRlbGltaXRlciwgYW55d2F5XG5cdFx0XHR2YXIgc2VwYXJhdG9ycyA9IGZvcm1hdC5yZXBsYWNlKHRoaXMudmFsaWRQYXJ0cywgJ1xcMCcpLnNwbGl0KCdcXDAnKSxcblx0XHRcdFx0cGFydHMgPSBmb3JtYXQubWF0Y2godGhpcy52YWxpZFBhcnRzKTtcblx0XHRcdGlmICghc2VwYXJhdG9ycyB8fCAhc2VwYXJhdG9ycy5sZW5ndGggfHwgIXBhcnRzIHx8IHBhcnRzLmxlbmd0aCA9PT0gMCl7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBmb3JtYXQuXCIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtzZXBhcmF0b3JzOiBzZXBhcmF0b3JzLCBwYXJ0czogcGFydHN9O1xuXHRcdH0sXG5cdFx0cGFyc2VEYXRlOiBmdW5jdGlvbihkYXRlLCBmb3JtYXQsIGxhbmd1YWdlKSB7XG5cdFx0XHRpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHJldHVybiBkYXRlO1xuXHRcdFx0aWYgKHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKVxuXHRcdFx0XHRmb3JtYXQgPSBEUEdsb2JhbC5wYXJzZUZvcm1hdChmb3JtYXQpO1xuXHRcdFx0aWYgKC9eW1xcLStdXFxkK1tkbXd5XShbXFxzLF0rW1xcLStdXFxkK1tkbXd5XSkqJC8udGVzdChkYXRlKSkge1xuXHRcdFx0XHR2YXIgcGFydF9yZSA9IC8oW1xcLStdXFxkKykoW2Rtd3ldKS8sXG5cdFx0XHRcdFx0cGFydHMgPSBkYXRlLm1hdGNoKC8oW1xcLStdXFxkKykoW2Rtd3ldKS9nKSxcblx0XHRcdFx0XHRwYXJ0LCBkaXI7XG5cdFx0XHRcdGRhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8cGFydHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRwYXJ0ID0gcGFydF9yZS5leGVjKHBhcnRzW2ldKTtcblx0XHRcdFx0XHRkaXIgPSBwYXJzZUludChwYXJ0WzFdKTtcblx0XHRcdFx0XHRzd2l0Y2gocGFydFsyXSl7XG5cdFx0XHRcdFx0XHRjYXNlICdkJzpcblx0XHRcdFx0XHRcdFx0ZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgZGlyKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdtJzpcblx0XHRcdFx0XHRcdFx0ZGF0ZSA9IERhdGVwaWNrZXIucHJvdG90eXBlLm1vdmVNb250aC5jYWxsKERhdGVwaWNrZXIucHJvdG90eXBlLCBkYXRlLCBkaXIpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ3cnOlxuXHRcdFx0XHRcdFx0XHRkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBkaXIgKiA3KTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICd5Jzpcblx0XHRcdFx0XHRcdFx0ZGF0ZSA9IERhdGVwaWNrZXIucHJvdG90eXBlLm1vdmVZZWFyLmNhbGwoRGF0ZXBpY2tlci5wcm90b3R5cGUsIGRhdGUsIGRpcik7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gVVRDRGF0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIGRhdGUuZ2V0VVRDTW9udGgoKSwgZGF0ZS5nZXRVVENEYXRlKCksIDAsIDAsIDApO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHBhcnRzID0gZGF0ZSAmJiBkYXRlLm1hdGNoKHRoaXMubm9ucHVuY3R1YXRpb24pIHx8IFtdLFxuXHRcdFx0XHRkYXRlID0gbmV3IERhdGUoKSxcblx0XHRcdFx0cGFyc2VkID0ge30sXG5cdFx0XHRcdHNldHRlcnNfb3JkZXIgPSBbJ3l5eXknLCAneXknLCAnTScsICdNTScsICdtJywgJ21tJywgJ2QnLCAnZGQnXSxcblx0XHRcdFx0c2V0dGVyc19tYXAgPSB7XG5cdFx0XHRcdFx0eXl5eTogZnVuY3Rpb24oZCx2KXsgcmV0dXJuIGQuc2V0VVRDRnVsbFllYXIodik7IH0sXG5cdFx0XHRcdFx0eXk6IGZ1bmN0aW9uKGQsdil7IHJldHVybiBkLnNldFVUQ0Z1bGxZZWFyKDIwMDArdik7IH0sXG5cdFx0XHRcdFx0bTogZnVuY3Rpb24oZCx2KXtcblx0XHRcdFx0XHRcdHYgLT0gMTtcblx0XHRcdFx0XHRcdHdoaWxlICh2PDApIHYgKz0gMTI7XG5cdFx0XHRcdFx0XHR2ICU9IDEyO1xuXHRcdFx0XHRcdFx0ZC5zZXRVVENNb250aCh2KTtcblx0XHRcdFx0XHRcdHdoaWxlIChkLmdldFVUQ01vbnRoKCkgIT0gdilcblx0XHRcdFx0XHRcdFx0ZC5zZXRVVENEYXRlKGQuZ2V0VVRDRGF0ZSgpLTEpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGQ7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRkOiBmdW5jdGlvbihkLHYpeyByZXR1cm4gZC5zZXRVVENEYXRlKHYpOyB9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHZhbCwgZmlsdGVyZWQsIHBhcnQ7XG5cdFx0XHRzZXR0ZXJzX21hcFsnTSddID0gc2V0dGVyc19tYXBbJ01NJ10gPSBzZXR0ZXJzX21hcFsnbW0nXSA9IHNldHRlcnNfbWFwWydtJ107XG5cdFx0XHRzZXR0ZXJzX21hcFsnZGQnXSA9IHNldHRlcnNfbWFwWydkJ107XG5cdFx0XHRkYXRlID0gVVRDRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCksIDAsIDAsIDApO1xuXHRcdFx0dmFyIGZwYXJ0cyA9IGZvcm1hdC5wYXJ0cy5zbGljZSgpO1xuXHRcdFx0Ly8gUmVtb3ZlIG5vb3AgcGFydHNcblx0XHRcdGlmIChwYXJ0cy5sZW5ndGggIT0gZnBhcnRzLmxlbmd0aCkge1xuXHRcdFx0XHRmcGFydHMgPSAkKGZwYXJ0cykuZmlsdGVyKGZ1bmN0aW9uKGkscCl7XG5cdFx0XHRcdFx0cmV0dXJuICQuaW5BcnJheShwLCBzZXR0ZXJzX29yZGVyKSAhPT0gLTE7XG5cdFx0XHRcdH0pLnRvQXJyYXkoKTtcblx0XHRcdH1cblx0XHRcdC8vIFByb2Nlc3MgcmVtYWluZGVyXG5cdFx0XHRpZiAocGFydHMubGVuZ3RoID09IGZwYXJ0cy5sZW5ndGgpIHtcblx0XHRcdFx0Zm9yICh2YXIgaT0wLCBjbnQgPSBmcGFydHMubGVuZ3RoOyBpIDwgY250OyBpKyspIHtcblx0XHRcdFx0XHR2YWwgPSBwYXJzZUludChwYXJ0c1tpXSwgMTApO1xuXHRcdFx0XHRcdHBhcnQgPSBmcGFydHNbaV07XG5cdFx0XHRcdFx0aWYgKGlzTmFOKHZhbCkpIHtcblx0XHRcdFx0XHRcdHN3aXRjaChwYXJ0KSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ01NJzpcblx0XHRcdFx0XHRcdFx0XHRmaWx0ZXJlZCA9ICQoZGF0ZXNbbGFuZ3VhZ2VdLm1vbnRocykuZmlsdGVyKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgbSA9IHRoaXMuc2xpY2UoMCwgcGFydHNbaV0ubGVuZ3RoKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cCA9IHBhcnRzW2ldLnNsaWNlKDAsIG0ubGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBtID09IHA7XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0dmFsID0gJC5pbkFycmF5KGZpbHRlcmVkWzBdLCBkYXRlc1tsYW5ndWFnZV0ubW9udGhzKSArIDE7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ00nOlxuXHRcdFx0XHRcdFx0XHRcdGZpbHRlcmVkID0gJChkYXRlc1tsYW5ndWFnZV0ubW9udGhzU2hvcnQpLmZpbHRlcihmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIG0gPSB0aGlzLnNsaWNlKDAsIHBhcnRzW2ldLmxlbmd0aCksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHAgPSBwYXJ0c1tpXS5zbGljZSgwLCBtLmxlbmd0aCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbSA9PSBwO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdHZhbCA9ICQuaW5BcnJheShmaWx0ZXJlZFswXSwgZGF0ZXNbbGFuZ3VhZ2VdLm1vbnRoc1Nob3J0KSArIDE7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcnNlZFtwYXJ0XSA9IHZhbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKHZhciBpPTAsIHM7IGk8c2V0dGVyc19vcmRlci5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdFx0cyA9IHNldHRlcnNfb3JkZXJbaV07XG5cdFx0XHRcdFx0aWYgKHMgaW4gcGFyc2VkICYmICFpc05hTihwYXJzZWRbc10pKVxuXHRcdFx0XHRcdFx0c2V0dGVyc19tYXBbc10oZGF0ZSwgcGFyc2VkW3NdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRhdGU7XG5cdFx0fSxcblx0XHRmb3JtYXREYXRlOiBmdW5jdGlvbihkYXRlLCBmb3JtYXQsIGxhbmd1YWdlKXtcblx0XHRcdGlmICh0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJylcblx0XHRcdFx0Zm9ybWF0ID0gRFBHbG9iYWwucGFyc2VGb3JtYXQoZm9ybWF0KTtcblx0XHRcdHZhciB2YWwgPSB7XG5cdFx0XHRcdGQ6IGRhdGUuZ2V0VVRDRGF0ZSgpLFxuXHRcdFx0XHREOiBkYXRlc1tsYW5ndWFnZV0uZGF5c1Nob3J0W2RhdGUuZ2V0VVRDRGF5KCldLFxuXHRcdFx0XHRERDogZGF0ZXNbbGFuZ3VhZ2VdLmRheXNbZGF0ZS5nZXRVVENEYXkoKV0sXG5cdFx0XHRcdG06IGRhdGUuZ2V0VVRDTW9udGgoKSArIDEsXG5cdFx0XHRcdE06IGRhdGVzW2xhbmd1YWdlXS5tb250aHNTaG9ydFtkYXRlLmdldFVUQ01vbnRoKCldLFxuXHRcdFx0XHRNTTogZGF0ZXNbbGFuZ3VhZ2VdLm1vbnRoc1tkYXRlLmdldFVUQ01vbnRoKCldLFxuXHRcdFx0XHR5eTogZGF0ZS5nZXRVVENGdWxsWWVhcigpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFxuXHRcdFx0XHR5eXl5OiBkYXRlLmdldFVUQ0Z1bGxZZWFyKClcblx0XHRcdH07XG5cdFx0XHR2YWwuZGQgPSAodmFsLmQgPCAxMCA/ICcwJyA6ICcnKSArIHZhbC5kO1xuXHRcdFx0dmFsLm1tID0gKHZhbC5tIDwgMTAgPyAnMCcgOiAnJykgKyB2YWwubTtcblx0XHRcdHZhciBkYXRlID0gW10sXG5cdFx0XHRcdHNlcHMgPSAkLmV4dGVuZChbXSwgZm9ybWF0LnNlcGFyYXRvcnMpO1xuXHRcdFx0Zm9yICh2YXIgaT0wLCBjbnQgPSBmb3JtYXQucGFydHMubGVuZ3RoOyBpIDw9IGNudDsgaSsrKSB7XG5cdFx0XHRcdGlmIChzZXBzLmxlbmd0aClcblx0XHRcdFx0XHRkYXRlLnB1c2goc2Vwcy5zaGlmdCgpKTtcblx0XHRcdFx0ZGF0ZS5wdXNoKHZhbFtmb3JtYXQucGFydHNbaV1dKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBkYXRlLmpvaW4oJycpO1xuXHRcdH0sXG5cdFx0aGVhZFRlbXBsYXRlOiAnPHRoZWFkPicrXG5cdFx0XHRcdFx0XHRcdCc8dHI+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRoIGNsYXNzPVwicHJldlwiPjxpIGNsYXNzPVwiaWNvbi1hcnJvdy1sZWZ0XCIvPjwvdGg+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRoIGNvbHNwYW49XCI1XCIgY2xhc3M9XCJkYXRlcGlja2VyLXN3aXRjaFwiPjwvdGg+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRoIGNsYXNzPVwibmV4dFwiPjxpIGNsYXNzPVwiaWNvbi1hcnJvdy1yaWdodFwiLz48L3RoPicrXG5cdFx0XHRcdFx0XHRcdCc8L3RyPicrXG5cdFx0XHRcdFx0XHQnPC90aGVhZD4nLFxuXHRcdGNvbnRUZW1wbGF0ZTogJzx0Ym9keT48dHI+PHRkIGNvbHNwYW49XCI3XCI+PC90ZD48L3RyPjwvdGJvZHk+Jyxcblx0XHRmb290VGVtcGxhdGU6ICc8dGZvb3Q+PHRyPjx0aCBjb2xzcGFuPVwiN1wiIGNsYXNzPVwidG9kYXlcIj48L3RoPjwvdHI+PHRyPjx0aCBjb2xzcGFuPVwiN1wiIGNsYXNzPVwiY2xlYXJcIj48L3RoPjwvdHI+PC90Zm9vdD4nXG5cdH07XG5cdERQR2xvYmFsLnRlbXBsYXRlID0gJzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyXCI+Jytcblx0XHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLWRheXNcIj4nK1xuXHRcdFx0XHRcdFx0XHRcdCc8dGFibGUgY2xhc3M9XCIgdGFibGUtY29uZGVuc2VkXCI+Jytcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmhlYWRUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHRcdCc8dGJvZHk+PC90Ym9keT4nK1xuXHRcdFx0XHRcdFx0XHRcdFx0RFBHbG9iYWwuZm9vdFRlbXBsYXRlK1xuXHRcdFx0XHRcdFx0XHRcdCc8L3RhYmxlPicrXG5cdFx0XHRcdFx0XHRcdCc8L2Rpdj4nK1xuXHRcdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItbW9udGhzXCI+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+Jytcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmhlYWRUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmNvbnRUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmZvb3RUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHQnPC90YWJsZT4nK1xuXHRcdFx0XHRcdFx0XHQnPC9kaXY+Jytcblx0XHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLXllYXJzXCI+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+Jytcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmhlYWRUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmNvbnRUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmZvb3RUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHQnPC90YWJsZT4nK1xuXHRcdFx0XHRcdFx0XHQnPC9kaXY+Jytcblx0XHRcdFx0XHRcdCc8L2Rpdj4nO1xuXG5cdCQuZm4uZGF0ZXBpY2tlci5EUEdsb2JhbCA9IERQR2xvYmFsO1xuXG5cblx0LyogREFURVBJQ0tFUiBOTyBDT05GTElDVFxuXHQqID09PT09PT09PT09PT09PT09PT0gKi9cblxuXHQkLmZuLmRhdGVwaWNrZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCl7XG5cdFx0JC5mbi5kYXRlcGlja2VyID0gb2xkO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cblx0LyogREFURVBJQ0tFUiBEQVRBLUFQSVxuXHQqID09PT09PT09PT09PT09PT09PSAqL1xuXG5cdCQoZG9jdW1lbnQpLm9uKFxuXHRcdCdmb2N1cy5kYXRlcGlja2VyLmRhdGEtYXBpIGNsaWNrLmRhdGVwaWNrZXIuZGF0YS1hcGknLFxuXHRcdCdbZGF0YS1wcm92aWRlPVwiZGF0ZXBpY2tlclwiXScsXG5cdFx0ZnVuY3Rpb24oZSl7XG5cdFx0XHR2YXIgJHRoaXMgPSAkKHRoaXMpO1xuXHRcdFx0aWYgKCR0aGlzLmRhdGEoJ2RhdGVwaWNrZXInKSkgcmV0dXJuO1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0Ly8gY29tcG9uZW50IGNsaWNrIHJlcXVpcmVzIHVzIHRvIGV4cGxpY2l0bHkgc2hvdyBpdFxuXHRcdFx0ZGF0ZXBpY2tlci5jYWxsKCR0aGlzLCAnc2hvdycpO1xuXHRcdH1cblx0KTtcblx0JChmdW5jdGlvbigpe1xuXHRcdC8vJCgnW2RhdGEtcHJvdmlkZT1cImRhdGVwaWNrZXItaW5saW5lXCJdJykuZGF0ZXBpY2tlcigpO1xuICAgICAgICAvL3ZpdDogY2hhbmdlZCB0byBzdXBwb3J0IG5vQ29uZmxpY3QoKVxuICAgICAgICBkYXRlcGlja2VyLmNhbGwoJCgnW2RhdGEtcHJvdmlkZT1cImRhdGVwaWNrZXItaW5saW5lXCJdJykpO1xuXHR9KTtcblxufSggd2luZG93LmpRdWVyeSApKTtcblxuLyoqXG5Cb290c3RyYXAtZGF0ZXBpY2tlci4gIFxuRGVzY3JpcHRpb24gYW5kIGV4YW1wbGVzOiBodHRwczovL2dpdGh1Yi5jb20vZXRlcm5pY29kZS9ib290c3RyYXAtZGF0ZXBpY2tlci4gIFxuRm9yICoqaTE4bioqIHlvdSBzaG91bGQgaW5jbHVkZSBqcyBmaWxlIGZyb20gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL2V0ZXJuaWNvZGUvYm9vdHN0cmFwLWRhdGVwaWNrZXIvdHJlZS9tYXN0ZXIvanMvbG9jYWxlc1xuYW5kIHNldCBgbGFuZ3VhZ2VgIG9wdGlvbi4gIFxuU2luY2UgMS40LjAgZGF0ZSBoYXMgZGlmZmVyZW50IGFwcGVhcmFuY2UgaW4gKipwb3B1cCoqIGFuZCAqKmlubGluZSoqIG1vZGVzLiBcblxuQGNsYXNzIGRhdGVcbkBleHRlbmRzIGFic3RyYWN0aW5wdXRcbkBmaW5hbFxuQGV4YW1wbGVcbjxhIGhyZWY9XCIjXCIgaWQ9XCJkb2JcIiBkYXRhLXR5cGU9XCJkYXRlXCIgZGF0YS1waz1cIjFcIiBkYXRhLXVybD1cIi9wb3N0XCIgZGF0YS10aXRsZT1cIlNlbGVjdCBkYXRlXCI+MTUvMDUvMTk4NDwvYT5cbjxzY3JpcHQ+XG4kKGZ1bmN0aW9uKCl7XG4gICAgJCgnI2RvYicpLmVkaXRhYmxlKHtcbiAgICAgICAgZm9ybWF0OiAneXl5eS1tbS1kZCcsICAgIFxuICAgICAgICB2aWV3Zm9ybWF0OiAnZGQvbW0veXl5eScsICAgIFxuICAgICAgICBkYXRlcGlja2VyOiB7XG4gICAgICAgICAgICAgICAgd2Vla1N0YXJ0OiAxXG4gICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG48L3NjcmlwdD5cbioqL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgXG4gICAgLy9zdG9yZSBib290c3RyYXAtZGF0ZXBpY2tlciBhcyBiZGF0ZWlja2VyIHRvIGV4Y2x1ZGUgY29uZmxpY3Qgd2l0aCBqUXVlcnkgVUkgb25lXG4gICAgJC5mbi5iZGF0ZXBpY2tlciA9ICQuZm4uZGF0ZXBpY2tlci5ub0NvbmZsaWN0KCk7XG4gICAgaWYoISQuZm4uZGF0ZXBpY2tlcikgeyAvL2lmIHRoZXJlIHdlcmUgbm8gb3RoZXIgZGF0ZXBpY2tlcnMsIGtlZXAgYWxzbyBvcmlnaW5hbCBuYW1lXG4gICAgICAgICQuZm4uZGF0ZXBpY2tlciA9ICQuZm4uYmRhdGVwaWNrZXI7ICAgIFxuICAgIH0gICAgXG4gICAgXG4gICAgdmFyIERhdGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ2RhdGUnLCBvcHRpb25zLCBEYXRlLmRlZmF1bHRzKTtcbiAgICAgICAgdGhpcy5pbml0UGlja2VyKG9wdGlvbnMsIERhdGUuZGVmYXVsdHMpO1xuICAgIH07XG5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChEYXRlLCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dCk7ICAgIFxuICAgIFxuICAgICQuZXh0ZW5kKERhdGUucHJvdG90eXBlLCB7XG4gICAgICAgIGluaXRQaWNrZXI6IGZ1bmN0aW9uKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gICAgICAgICAgICAvLydmb3JtYXQnIGlzIHNldCBkaXJlY3RseSBmcm9tIHNldHRpbmdzIG9yIGRhdGEtKiBhdHRyaWJ1dGVzXG5cbiAgICAgICAgICAgIC8vYnkgZGVmYXVsdCB2aWV3Zm9ybWF0IGVxdWFscyB0byBmb3JtYXRcbiAgICAgICAgICAgIGlmKCF0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy52aWV3Zm9ybWF0ID0gdGhpcy5vcHRpb25zLmZvcm1hdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy90cnkgcGFyc2UgZGF0ZXBpY2tlciBjb25maWcgZGVmaW5lZCBhcyBqc29uIHN0cmluZyBpbiBkYXRhLWRhdGVwaWNrZXJcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0ZXBpY2tlciA9ICQuZm4uZWRpdGFibGV1dGlscy50cnlQYXJzZUpzb24ob3B0aW9ucy5kYXRlcGlja2VyLCB0cnVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9vdmVycmlkaW5nIGRhdGVwaWNrZXIgY29uZmlnIChhcyBieSBkZWZhdWx0IGpRdWVyeSBleHRlbmQoKSBpcyBub3QgcmVjdXJzaXZlKVxuICAgICAgICAgICAgLy9zaW5jZSAxLjQgZGF0ZXBpY2tlciBpbnRlcm5hbGx5IHVzZXMgdmlld2Zvcm1hdCBpbnN0ZWFkIG9mIGZvcm1hdC4gRm9ybWF0IGlzIGZvciBzdWJtaXQgb25seVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRhdGVwaWNrZXIgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdHMuZGF0ZXBpY2tlciwgb3B0aW9ucy5kYXRlcGlja2VyLCB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiB0aGlzLm9wdGlvbnMudmlld2Zvcm1hdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vbGFuZ3VhZ2VcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kYXRlcGlja2VyLmxhbmd1YWdlID0gdGhpcy5vcHRpb25zLmRhdGVwaWNrZXIubGFuZ3VhZ2UgfHwgJ2VuJzsgXG5cbiAgICAgICAgICAgIC8vc3RvcmUgRFBnbG9iYWxcbiAgICAgICAgICAgIHRoaXMuZHBnID0gJC5mbi5iZGF0ZXBpY2tlci5EUEdsb2JhbDsgXG5cbiAgICAgICAgICAgIC8vc3RvcmUgcGFyc2VkIGZvcm1hdHNcbiAgICAgICAgICAgIHRoaXMucGFyc2VkRm9ybWF0ID0gdGhpcy5kcGcucGFyc2VGb3JtYXQodGhpcy5vcHRpb25zLmZvcm1hdCk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZFZpZXdGb3JtYXQgPSB0aGlzLmRwZy5wYXJzZUZvcm1hdCh0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCk7ICAgICAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LmJkYXRlcGlja2VyKHRoaXMub3B0aW9ucy5kYXRlcGlja2VyKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9cImNsZWFyXCIgbGlua1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmNsZWFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2xlYXIgPSAkKCc8YSBocmVmPVwiI1wiPjwvYT4nKS5odG1sKHRoaXMub3B0aW9ucy5jbGVhcikuY2xpY2soJC5wcm94eShmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuJHRwbC5wYXJlbnQoKS5hcHBlbmQoJCgnPGRpdiBjbGFzcz1cImVkaXRhYmxlLWNsZWFyXCI+JykuYXBwZW5kKHRoaXMuJGNsZWFyKSk7ICBcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICB2YWx1ZTJodG1sOiBmdW5jdGlvbih2YWx1ZSwgZWxlbWVudCkge1xuICAgICAgICAgICB2YXIgdGV4dCA9IHZhbHVlID8gdGhpcy5kcGcuZm9ybWF0RGF0ZSh2YWx1ZSwgdGhpcy5wYXJzZWRWaWV3Rm9ybWF0LCB0aGlzLm9wdGlvbnMuZGF0ZXBpY2tlci5sYW5ndWFnZSkgOiAnJztcbiAgICAgICAgICAgRGF0ZS5zdXBlcmNsYXNzLnZhbHVlMmh0bWwuY2FsbCh0aGlzLCB0ZXh0LCBlbGVtZW50KTsgXG4gICAgICAgIH0sXG5cbiAgICAgICAgaHRtbDJ2YWx1ZTogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VEYXRlKGh0bWwsIHRoaXMucGFyc2VkVmlld0Zvcm1hdCk7XG4gICAgICAgIH0sICAgXG5cbiAgICAgICAgdmFsdWUyc3RyOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gdGhpcy5kcGcuZm9ybWF0RGF0ZSh2YWx1ZSwgdGhpcy5wYXJzZWRGb3JtYXQsIHRoaXMub3B0aW9ucy5kYXRlcGlja2VyLmxhbmd1YWdlKSA6ICcnO1xuICAgICAgICB9LCBcblxuICAgICAgICBzdHIydmFsdWU6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VEYXRlKHN0ciwgdGhpcy5wYXJzZWRGb3JtYXQpO1xuICAgICAgICB9LCBcblxuICAgICAgICB2YWx1ZTJzdWJtaXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTJzdHIodmFsdWUpO1xuICAgICAgICB9LCAgICAgICAgICAgICAgICAgICAgXG5cbiAgICAgICAgdmFsdWUyaW5wdXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5iZGF0ZXBpY2tlcigndXBkYXRlJywgdmFsdWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlucHV0MnZhbHVlOiBmdW5jdGlvbigpIHsgXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaW5wdXQuZGF0YSgnZGF0ZXBpY2tlcicpLmRhdGU7XG4gICAgICAgIH0sICAgICAgIFxuXG4gICAgICAgIGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhcjogIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQuZGF0YSgnZGF0ZXBpY2tlcicpLmRhdGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQuZmluZCgnLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIGlmKCF0aGlzLm9wdGlvbnMuc2hvd2J1dHRvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5jbG9zZXN0KCdmb3JtJykuc3VibWl0KCk7IFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGF1dG9zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQub24oJ21vdXNldXAnLCAnLmRheScsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgICAgIGlmKCQoZS5jdXJyZW50VGFyZ2V0KS5pcygnLm9sZCcpIHx8ICQoZS5jdXJyZW50VGFyZ2V0KS5pcygnLm5ldycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyICRmb3JtID0gJCh0aGlzKS5jbG9zZXN0KCdmb3JtJyk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAvL2NoYW5nZWRhdGUgaXMgbm90IHN1aXRhYmxlIGFzIGl0IHRyaWdnZXJlZCB3aGVuIHNob3dpbmcgZGF0ZXBpY2tlci4gc2VlICMxNDlcbiAgICAgICAgICAgLypcbiAgICAgICAgICAgdGhpcy4kaW5wdXQub24oJ2NoYW5nZURhdGUnLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgIHZhciAkZm9ybSA9ICQodGhpcykuY2xvc2VzdCgnZm9ybScpO1xuICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAkZm9ybS5zdWJtaXQoKTtcbiAgICAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgICAgIH0pO1xuICAgICAgICAgICAqL1xuICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgLypcbiAgICAgICAgRm9yIGluY29ycmVjdCBkYXRlIGJvb3RzdHJhcC1kYXRlcGlja2VyIHJldHVybnMgY3VycmVudCBkYXRlIHRoYXQgaXMgbm90IHN1aXRhYmxlXG4gICAgICAgIGZvciBkYXRlZmllbGQuXG4gICAgICAgIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBudWxsIGZvciBpbmNvcnJlY3QgZGF0ZS4gIFxuICAgICAgICovXG4gICAgICAgcGFyc2VEYXRlOiBmdW5jdGlvbihzdHIsIGZvcm1hdCkge1xuICAgICAgICAgICB2YXIgZGF0ZSA9IG51bGwsIGZvcm1hdHRlZEJhY2s7XG4gICAgICAgICAgIGlmKHN0cikge1xuICAgICAgICAgICAgICAgZGF0ZSA9IHRoaXMuZHBnLnBhcnNlRGF0ZShzdHIsIGZvcm1hdCwgdGhpcy5vcHRpb25zLmRhdGVwaWNrZXIubGFuZ3VhZ2UpO1xuICAgICAgICAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRCYWNrID0gdGhpcy5kcGcuZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQsIHRoaXMub3B0aW9ucy5kYXRlcGlja2VyLmxhbmd1YWdlKTtcbiAgICAgICAgICAgICAgICAgICBpZihzdHIgIT09IGZvcm1hdHRlZEJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgRGF0ZS5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dC5kZWZhdWx0cywge1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IHRwbCBcbiAgICAgICAgQGRlZmF1bHQgPGRpdj48L2Rpdj5cbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHRwbDonPGRpdiBjbGFzcz1cImVkaXRhYmxlLWRhdGUgd2VsbFwiPjwvZGl2PicsXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgaW5wdXRjbGFzcyBcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi9cbiAgICAgICAgaW5wdXRjbGFzczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIEZvcm1hdCB1c2VkIGZvciBzZW5kaW5nIHZhbHVlIHRvIHNlcnZlci4gQWxzbyBhcHBsaWVkIHdoZW4gY29udmVydGluZyBkYXRlIGZyb20gPGNvZGU+ZGF0YS12YWx1ZTwvY29kZT4gYXR0cmlidXRlLjxicj5cbiAgICAgICAgUG9zc2libGUgdG9rZW5zIGFyZTogPGNvZGU+ZCwgZGQsIG0sIG1tLCB5eSwgeXl5eTwvY29kZT4gIFxuXG4gICAgICAgIEBwcm9wZXJ0eSBmb3JtYXQgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCB5eXl5LW1tLWRkXG4gICAgICAgICoqL1xuICAgICAgICBmb3JtYXQ6J3l5eXktbW0tZGQnLFxuICAgICAgICAvKipcbiAgICAgICAgRm9ybWF0IHVzZWQgZm9yIGRpc3BsYXlpbmcgZGF0ZS4gQWxzbyBhcHBsaWVkIHdoZW4gY29udmVydGluZyBkYXRlIGZyb20gZWxlbWVudCdzIHRleHQgb24gaW5pdC4gICBcbiAgICAgICAgSWYgbm90IHNwZWNpZmllZCBlcXVhbHMgdG8gPGNvZGU+Zm9ybWF0PC9jb2RlPlxuXG4gICAgICAgIEBwcm9wZXJ0eSB2aWV3Zm9ybWF0IFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi9cbiAgICAgICAgdmlld2Zvcm1hdDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIENvbmZpZ3VyYXRpb24gb2YgZGF0ZXBpY2tlci5cbiAgICAgICAgRnVsbCBsaXN0IG9mIG9wdGlvbnM6IGh0dHA6Ly9ib290c3RyYXAtZGF0ZXBpY2tlci5yZWFkdGhlZG9jcy5vcmcvZW4vbGF0ZXN0L29wdGlvbnMuaHRtbFxuXG4gICAgICAgIEBwcm9wZXJ0eSBkYXRlcGlja2VyIFxuICAgICAgICBAdHlwZSBvYmplY3RcbiAgICAgICAgQGRlZmF1bHQge1xuICAgICAgICAgICAgd2Vla1N0YXJ0OiAwLFxuICAgICAgICAgICAgc3RhcnRWaWV3OiAwLFxuICAgICAgICAgICAgbWluVmlld01vZGU6IDAsXG4gICAgICAgICAgICBhdXRvY2xvc2U6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgKiovXG4gICAgICAgIGRhdGVwaWNrZXI6e1xuICAgICAgICAgICAgd2Vla1N0YXJ0OiAwLFxuICAgICAgICAgICAgc3RhcnRWaWV3OiAwLFxuICAgICAgICAgICAgbWluVmlld01vZGU6IDAsXG4gICAgICAgICAgICBhdXRvY2xvc2U6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICBUZXh0IHNob3duIGFzIGNsZWFyIGRhdGUgYnV0dG9uLiBcbiAgICAgICAgSWYgPGNvZGU+ZmFsc2U8L2NvZGU+IGNsZWFyIGJ1dHRvbiB3aWxsIG5vdCBiZSByZW5kZXJlZC5cblxuICAgICAgICBAcHJvcGVydHkgY2xlYXIgXG4gICAgICAgIEB0eXBlIGJvb2xlYW58c3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICd4IGNsZWFyJ1xuICAgICAgICAqKi9cbiAgICAgICAgY2xlYXI6ICcmdGltZXM7IGNsZWFyJ1xuICAgIH0pO1xuXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGUgPSBEYXRlO1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG5Cb290c3RyYXAgZGF0ZWZpZWxkIGlucHV0IC0gbW9kaWZpY2F0aW9uIGZvciBpbmxpbmUgbW9kZS5cblNob3dzIG5vcm1hbCA8aW5wdXQgdHlwZT1cInRleHRcIj4gYW5kIGJpbmRzIHBvcHVwIGRhdGVwaWNrZXIuICBcbkF1dG9tYXRpY2FsbHkgc2hvd24gaW4gaW5saW5lIG1vZGUuXG5cbkBjbGFzcyBkYXRlZmllbGRcbkBleHRlbmRzIGRhdGVcblxuQHNpbmNlIDEuNC4wXG4qKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFxuICAgIHZhciBEYXRlRmllbGQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ2RhdGVmaWVsZCcsIG9wdGlvbnMsIERhdGVGaWVsZC5kZWZhdWx0cyk7XG4gICAgICAgIHRoaXMuaW5pdFBpY2tlcihvcHRpb25zLCBEYXRlRmllbGQuZGVmYXVsdHMpO1xuICAgIH07XG5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChEYXRlRmllbGQsICQuZm4uZWRpdGFibGV0eXBlcy5kYXRlKTsgICAgXG4gICAgXG4gICAgJC5leHRlbmQoRGF0ZUZpZWxkLnByb3RvdHlwZSwge1xuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0ID0gdGhpcy4kdHBsLmZpbmQoJ2lucHV0Jyk7XG4gICAgICAgICAgICB0aGlzLnNldENsYXNzKCk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3BsYWNlaG9sZGVyJyk7XG4gICAgXG4gICAgICAgICAgICAvL2Jvb3RzdHJhcC1kYXRlcGlja2VyIGlzIHNldCBgYmRhdGVpY2tlcmAgdG8gZXhjbHVkZSBjb25mbGljdCB3aXRoIGpRdWVyeSBVSSBvbmUuIChpbiBkYXRlLmpzKSAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiR0cGwuYmRhdGVwaWNrZXIodGhpcy5vcHRpb25zLmRhdGVwaWNrZXIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL25lZWQgdG8gZGlzYWJsZSBvcmlnaW5hbCBldmVudCBoYW5kbGVyc1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQub2ZmKCdmb2N1cyBrZXlkb3duJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vdXBkYXRlIHZhbHVlIG9mIGRhdGVwaWNrZXJcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LmtleXVwKCQucHJveHkoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgIHRoaXMuJHRwbC5yZW1vdmVEYXRhKCdkYXRlJyk7XG4gICAgICAgICAgICAgICB0aGlzLiR0cGwuYmRhdGVwaWNrZXIoJ3VwZGF0ZScpO1xuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICAgICAgXG4gICAgICAgIH0sICAgXG4gICAgICAgIFxuICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICB0aGlzLiRpbnB1dC52YWwodmFsdWUgPyB0aGlzLmRwZy5mb3JtYXREYXRlKHZhbHVlLCB0aGlzLnBhcnNlZFZpZXdGb3JtYXQsIHRoaXMub3B0aW9ucy5kYXRlcGlja2VyLmxhbmd1YWdlKSA6ICcnKTtcbiAgICAgICAgICAgdGhpcy4kdHBsLmJkYXRlcGlja2VyKCd1cGRhdGUnKTtcbiAgICAgICB9LFxuICAgICAgICBcbiAgICAgICBpbnB1dDJ2YWx1ZTogZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICByZXR1cm4gdGhpcy5odG1sMnZhbHVlKHRoaXMuJGlucHV0LnZhbCgpKTtcbiAgICAgICB9LCAgICAgICAgICAgICAgXG4gICAgICAgIFxuICAgICAgIGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQucHJvdG90eXBlLmFjdGl2YXRlLmNhbGwodGhpcyk7XG4gICAgICAgfSxcbiAgICAgICBcbiAgICAgICBhdXRvc3VibWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgIC8vcmVzZXQgYXV0b3N1Ym1pdCB0byBlbXB0eSAgXG4gICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIERhdGVGaWVsZC5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxldHlwZXMuZGF0ZS5kZWZhdWx0cywge1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IHRwbCBcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHRwbDonPGRpdiBjbGFzcz1cImlucHV0LWFwcGVuZCBkYXRlXCI+PGlucHV0IHR5cGU9XCJ0ZXh0XCIvPjxzcGFuIGNsYXNzPVwiYWRkLW9uXCI+PGkgY2xhc3M9XCJpY29uLXRoXCI+PC9pPjwvc3Bhbj48L2Rpdj4nLFxuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IGlucHV0Y2xhc3MgXG4gICAgICAgIEBkZWZhdWx0ICdpbnB1dC1zbWFsbCdcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGlucHV0Y2xhc3M6ICdpbnB1dC1zbWFsbCcsXG4gICAgICAgIFxuICAgICAgICAvKiBkYXRlcGlja2VyIGNvbmZpZyAqL1xuICAgICAgICBkYXRlcGlja2VyOiB7XG4gICAgICAgICAgICB3ZWVrU3RhcnQ6IDAsXG4gICAgICAgICAgICBzdGFydFZpZXc6IDAsXG4gICAgICAgICAgICBtaW5WaWV3TW9kZTogMCxcbiAgICAgICAgICAgIGF1dG9jbG9zZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGVmaWVsZCA9IERhdGVGaWVsZDtcblxufSh3aW5kb3cualF1ZXJ5KSk7XG4vKipcbkJvb3RzdHJhcC1kYXRldGltZXBpY2tlci4gIFxuQmFzZWQgb24gW3NtYWxvdCBib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIgcGx1Z2luXShodHRwczovL2dpdGh1Yi5jb20vc21hbG90L2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlcikuIFxuQmVmb3JlIHVzYWdlIHlvdSBzaG91bGQgbWFudWFsbHkgaW5jbHVkZSBkZXBlbmRlbnQganMgYW5kIGNzczpcblxuICAgIDxsaW5rIGhyZWY9XCJjc3MvZGF0ZXRpbWVwaWNrZXIuY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiIHR5cGU9XCJ0ZXh0L2Nzc1wiPjwvbGluaz4gXG4gICAgPHNjcmlwdCBzcmM9XCJqcy9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIuanNcIj48L3NjcmlwdD5cblxuRm9yICoqaTE4bioqIHlvdSBzaG91bGQgaW5jbHVkZSBqcyBmaWxlIGZyb20gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3NtYWxvdC9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIvdHJlZS9tYXN0ZXIvanMvbG9jYWxlc1xuYW5kIHNldCBgbGFuZ3VhZ2VgIG9wdGlvbi4gIFxuXG5AY2xhc3MgZGF0ZXRpbWVcbkBleHRlbmRzIGFic3RyYWN0aW5wdXRcbkBmaW5hbFxuQHNpbmNlIDEuNC40XG5AZXhhbXBsZVxuPGEgaHJlZj1cIiNcIiBpZD1cImxhc3Rfc2VlblwiIGRhdGEtdHlwZT1cImRhdGV0aW1lXCIgZGF0YS1waz1cIjFcIiBkYXRhLXVybD1cIi9wb3N0XCIgdGl0bGU9XCJTZWxlY3QgZGF0ZSAmIHRpbWVcIj4xNS8wMy8yMDEzIDEyOjQ1PC9hPlxuPHNjcmlwdD5cbiQoZnVuY3Rpb24oKXtcbiAgICAkKCcjbGFzdF9zZWVuJykuZWRpdGFibGUoe1xuICAgICAgICBmb3JtYXQ6ICd5eXl5LW1tLWRkIGhoOmlpJywgICAgXG4gICAgICAgIHZpZXdmb3JtYXQ6ICdkZC9tbS95eXl5IGhoOmlpJywgICAgXG4gICAgICAgIGRhdGV0aW1lcGlja2VyOiB7XG4gICAgICAgICAgICAgICAgd2Vla1N0YXJ0OiAxXG4gICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG48L3NjcmlwdD5cbioqL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgRGF0ZVRpbWUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ2RhdGV0aW1lJywgb3B0aW9ucywgRGF0ZVRpbWUuZGVmYXVsdHMpO1xuICAgICAgICB0aGlzLmluaXRQaWNrZXIob3B0aW9ucywgRGF0ZVRpbWUuZGVmYXVsdHMpO1xuICAgIH07XG5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChEYXRlVGltZSwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQpO1xuXG4gICAgJC5leHRlbmQoRGF0ZVRpbWUucHJvdG90eXBlLCB7XG4gICAgICAgIGluaXRQaWNrZXI6IGZ1bmN0aW9uKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gICAgICAgICAgICAvLydmb3JtYXQnIGlzIHNldCBkaXJlY3RseSBmcm9tIHNldHRpbmdzIG9yIGRhdGEtKiBhdHRyaWJ1dGVzXG5cbiAgICAgICAgICAgIC8vYnkgZGVmYXVsdCB2aWV3Zm9ybWF0IGVxdWFscyB0byBmb3JtYXRcbiAgICAgICAgICAgIGlmKCF0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy52aWV3Zm9ybWF0ID0gdGhpcy5vcHRpb25zLmZvcm1hdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy90cnkgcGFyc2UgZGF0ZXRpbWVwaWNrZXIgY29uZmlnIGRlZmluZWQgYXMganNvbiBzdHJpbmcgaW4gZGF0YS1kYXRldGltZXBpY2tlclxuICAgICAgICAgICAgb3B0aW9ucy5kYXRldGltZXBpY2tlciA9ICQuZm4uZWRpdGFibGV1dGlscy50cnlQYXJzZUpzb24ob3B0aW9ucy5kYXRldGltZXBpY2tlciwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vb3ZlcnJpZGluZyBkYXRldGltZXBpY2tlciBjb25maWcgKGFzIGJ5IGRlZmF1bHQgalF1ZXJ5IGV4dGVuZCgpIGlzIG5vdCByZWN1cnNpdmUpXG4gICAgICAgICAgICAvL3NpbmNlIDEuNCBkYXRldGltZXBpY2tlciBpbnRlcm5hbGx5IHVzZXMgdmlld2Zvcm1hdCBpbnN0ZWFkIG9mIGZvcm1hdC4gRm9ybWF0IGlzIGZvciBzdWJtaXQgb25seVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRhdGV0aW1lcGlja2VyID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLmRhdGV0aW1lcGlja2VyLCBvcHRpb25zLmRhdGV0aW1lcGlja2VyLCB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiB0aGlzLm9wdGlvbnMudmlld2Zvcm1hdFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vbGFuZ3VhZ2VcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kYXRldGltZXBpY2tlci5sYW5ndWFnZSA9IHRoaXMub3B0aW9ucy5kYXRldGltZXBpY2tlci5sYW5ndWFnZSB8fCAnZW4nOyBcblxuICAgICAgICAgICAgLy9zdG9yZSBEUGdsb2JhbFxuICAgICAgICAgICAgdGhpcy5kcGcgPSAkLmZuLmRhdGV0aW1lcGlja2VyLkRQR2xvYmFsOyBcblxuICAgICAgICAgICAgLy9zdG9yZSBwYXJzZWQgZm9ybWF0c1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRGb3JtYXQgPSB0aGlzLmRwZy5wYXJzZUZvcm1hdCh0aGlzLm9wdGlvbnMuZm9ybWF0LCB0aGlzLm9wdGlvbnMuZm9ybWF0VHlwZSk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZFZpZXdGb3JtYXQgPSB0aGlzLmRwZy5wYXJzZUZvcm1hdCh0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCwgdGhpcy5vcHRpb25zLmZvcm1hdFR5cGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQuZGF0ZXRpbWVwaWNrZXIodGhpcy5vcHRpb25zLmRhdGV0aW1lcGlja2VyKTtcblxuICAgICAgICAgICAgLy9hZGp1c3QgY29udGFpbmVyIHBvc2l0aW9uIHdoZW4gdmlld01vZGUgY2hhbmdlc1xuICAgICAgICAgICAgLy9zZWUgaHR0cHM6Ly9naXRodWIuY29tL3NtYWxvdC9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIvcHVsbC84MFxuICAgICAgICAgICAgdGhpcy4kaW5wdXQub24oJ2NoYW5nZU1vZGUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKS5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICAvL3RpbWVvdXQgaGVyZSwgb3RoZXJ3aXNlIGNvbnRhaW5lciBjaGFuZ2VzIHBvc2l0aW9uIGJlZm9yZSBmb3JtIGhhcyBuZXcgc2l6ZVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgZi50cmlnZ2VySGFuZGxlcigncmVzaXplJyk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy9cImNsZWFyXCIgbGlua1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmNsZWFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2xlYXIgPSAkKCc8YSBocmVmPVwiI1wiPjwvYT4nKS5odG1sKHRoaXMub3B0aW9ucy5jbGVhcikuY2xpY2soJC5wcm94eShmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy4kdHBsLnBhcmVudCgpLmFwcGVuZCgkKCc8ZGl2IGNsYXNzPVwiZWRpdGFibGUtY2xlYXJcIj4nKS5hcHBlbmQodGhpcy4kY2xlYXIpKTsgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHZhbHVlMmh0bWw6IGZ1bmN0aW9uKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAvL2Zvcm1hdERhdGUgd29ya3Mgd2l0aCBVVENEYXRlIVxuICAgICAgICAgICAgdmFyIHRleHQgPSB2YWx1ZSA/IHRoaXMuZHBnLmZvcm1hdERhdGUodGhpcy50b1VUQyh2YWx1ZSksIHRoaXMucGFyc2VkVmlld0Zvcm1hdCwgdGhpcy5vcHRpb25zLmRhdGV0aW1lcGlja2VyLmxhbmd1YWdlLCB0aGlzLm9wdGlvbnMuZm9ybWF0VHlwZSkgOiAnJztcbiAgICAgICAgICAgIGlmKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBEYXRlVGltZS5zdXBlcmNsYXNzLnZhbHVlMmh0bWwuY2FsbCh0aGlzLCB0ZXh0LCBlbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaHRtbDJ2YWx1ZTogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICAgLy9wYXJzZURhdGUgcmV0dXJuIHV0YyBkYXRlIVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5wYXJzZURhdGUoaHRtbCwgdGhpcy5wYXJzZWRWaWV3Rm9ybWF0KTsgXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPyB0aGlzLmZyb21VVEModmFsdWUpIDogbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICB2YWx1ZTJzdHI6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAvL2Zvcm1hdERhdGUgd29ya3Mgd2l0aCBVVENEYXRlIVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gdGhpcy5kcGcuZm9ybWF0RGF0ZSh0aGlzLnRvVVRDKHZhbHVlKSwgdGhpcy5wYXJzZWRGb3JtYXQsIHRoaXMub3B0aW9ucy5kYXRldGltZXBpY2tlci5sYW5ndWFnZSwgdGhpcy5vcHRpb25zLmZvcm1hdFR5cGUpIDogJyc7XG4gICAgICAgfSxcblxuICAgICAgIHN0cjJ2YWx1ZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgIC8vcGFyc2VEYXRlIHJldHVybiB1dGMgZGF0ZSFcbiAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5wYXJzZURhdGUoc3RyLCB0aGlzLnBhcnNlZEZvcm1hdCk7XG4gICAgICAgICAgIHJldHVybiB2YWx1ZSA/IHRoaXMuZnJvbVVUQyh2YWx1ZSkgOiBudWxsO1xuICAgICAgIH0sXG5cbiAgICAgICB2YWx1ZTJzdWJtaXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlMnN0cih2YWx1ZSk7XG4gICAgICAgfSxcblxuICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICBpZih2YWx1ZSkge1xuICAgICAgICAgICAgIHRoaXMuJGlucHV0LmRhdGEoJ2RhdGV0aW1lcGlja2VyJykuc2V0RGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgIH1cbiAgICAgICB9LFxuXG4gICAgICAgaW5wdXQydmFsdWU6IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgLy9kYXRlIG1heSBiZSBjbGVhcmVkLCBpbiB0aGF0IGNhc2UgZ2V0RGF0ZSgpIHRyaWdnZXJzIGVycm9yXG4gICAgICAgICAgIHZhciBkdCA9IHRoaXMuJGlucHV0LmRhdGEoJ2RhdGV0aW1lcGlja2VyJyk7XG4gICAgICAgICAgIHJldHVybiBkdC5kYXRlID8gZHQuZ2V0RGF0ZSgpIDogbnVsbDtcbiAgICAgICB9LFxuXG4gICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgIH0sXG5cbiAgICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy4kaW5wdXQuZGF0YSgnZGF0ZXRpbWVwaWNrZXInKS5kYXRlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLiRpbnB1dC5maW5kKCcuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgIGlmKCF0aGlzLm9wdGlvbnMuc2hvd2J1dHRvbnMpIHtcbiAgICAgICAgICAgICB0aGlzLiRpbnB1dC5jbG9zZXN0KCdmb3JtJykuc3VibWl0KCk7IFxuICAgICAgICAgIH0gICAgICAgICAgXG4gICAgICAgfSxcblxuICAgICAgIGF1dG9zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICB0aGlzLiRpbnB1dC5vbignbW91c2V1cCcsICcubWludXRlJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICB2YXIgJGZvcm0gPSAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKTtcbiAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgJGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgICB9KTtcbiAgICAgICB9LFxuXG4gICAgICAgLy9jb252ZXJ0IGRhdGUgZnJvbSBsb2NhbCB0byB1dGNcbiAgICAgICB0b1VUQzogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgIHJldHVybiB2YWx1ZSA/IG5ldyBEYXRlKHZhbHVlLnZhbHVlT2YoKSAtIHZhbHVlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMCkgOiB2YWx1ZTsgIFxuICAgICAgIH0sXG5cbiAgICAgICAvL2NvbnZlcnQgZGF0ZSBmcm9tIHV0YyB0byBsb2NhbFxuICAgICAgIGZyb21VVEM6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICByZXR1cm4gdmFsdWUgPyBuZXcgRGF0ZSh2YWx1ZS52YWx1ZU9mKCkgKyB2YWx1ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDApIDogdmFsdWU7ICBcbiAgICAgICB9LFxuXG4gICAgICAgLypcbiAgICAgICAgRm9yIGluY29ycmVjdCBkYXRlIGJvb3RzdHJhcC1kYXRldGltZXBpY2tlciByZXR1cm5zIGN1cnJlbnQgZGF0ZSB0aGF0IGlzIG5vdCBzdWl0YWJsZVxuICAgICAgICBmb3IgZGF0ZXRpbWVmaWVsZC5cbiAgICAgICAgVGhpcyBmdW5jdGlvbiByZXR1cm5zIG51bGwgZm9yIGluY29ycmVjdCBkYXRlLiAgXG4gICAgICAgKi9cbiAgICAgICBwYXJzZURhdGU6IGZ1bmN0aW9uKHN0ciwgZm9ybWF0KSB7XG4gICAgICAgICAgIHZhciBkYXRlID0gbnVsbCwgZm9ybWF0dGVkQmFjaztcbiAgICAgICAgICAgaWYoc3RyKSB7XG4gICAgICAgICAgICAgICBkYXRlID0gdGhpcy5kcGcucGFyc2VEYXRlKHN0ciwgZm9ybWF0LCB0aGlzLm9wdGlvbnMuZGF0ZXRpbWVwaWNrZXIubGFuZ3VhZ2UsIHRoaXMub3B0aW9ucy5mb3JtYXRUeXBlKTtcbiAgICAgICAgICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkQmFjayA9IHRoaXMuZHBnLmZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCB0aGlzLm9wdGlvbnMuZGF0ZXRpbWVwaWNrZXIubGFuZ3VhZ2UsIHRoaXMub3B0aW9ucy5mb3JtYXRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICBpZihzdHIgIT09IGZvcm1hdHRlZEJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIERhdGVUaW1lLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0LmRlZmF1bHRzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgdHBsIFxuICAgICAgICBAZGVmYXVsdCA8ZGl2PjwvZGl2PlxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgdHBsOic8ZGl2IGNsYXNzPVwiZWRpdGFibGUtZGF0ZSB3ZWxsXCI+PC9kaXY+JyxcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBpbnB1dGNsYXNzIFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqL1xuICAgICAgICBpbnB1dGNsYXNzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgRm9ybWF0IHVzZWQgZm9yIHNlbmRpbmcgdmFsdWUgdG8gc2VydmVyLiBBbHNvIGFwcGxpZWQgd2hlbiBjb252ZXJ0aW5nIGRhdGUgZnJvbSA8Y29kZT5kYXRhLXZhbHVlPC9jb2RlPiBhdHRyaWJ1dGUuPGJyPlxuICAgICAgICBQb3NzaWJsZSB0b2tlbnMgYXJlOiA8Y29kZT5kLCBkZCwgbSwgbW0sIHl5LCB5eXl5LCBoLCBpPC9jb2RlPiAgXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgZm9ybWF0IFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgeXl5eS1tbS1kZCBoaDppaVxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgZm9ybWF0Oid5eXl5LW1tLWRkIGhoOmlpJyxcbiAgICAgICAgZm9ybWF0VHlwZTonc3RhbmRhcmQnLFxuICAgICAgICAvKipcbiAgICAgICAgRm9ybWF0IHVzZWQgZm9yIGRpc3BsYXlpbmcgZGF0ZS4gQWxzbyBhcHBsaWVkIHdoZW4gY29udmVydGluZyBkYXRlIGZyb20gZWxlbWVudCdzIHRleHQgb24gaW5pdC4gICBcbiAgICAgICAgSWYgbm90IHNwZWNpZmllZCBlcXVhbHMgdG8gPGNvZGU+Zm9ybWF0PC9jb2RlPlxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IHZpZXdmb3JtYXQgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqL1xuICAgICAgICB2aWV3Zm9ybWF0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgQ29uZmlndXJhdGlvbiBvZiBkYXRldGltZXBpY2tlci5cbiAgICAgICAgRnVsbCBsaXN0IG9mIG9wdGlvbnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9zbWFsb3QvYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyXG5cbiAgICAgICAgQHByb3BlcnR5IGRhdGV0aW1lcGlja2VyIFxuICAgICAgICBAdHlwZSBvYmplY3RcbiAgICAgICAgQGRlZmF1bHQgeyB9XG4gICAgICAgICoqL1xuICAgICAgICBkYXRldGltZXBpY2tlcjp7XG4gICAgICAgICAgICB0b2RheUhpZ2hsaWdodDogZmFsc2UsXG4gICAgICAgICAgICBhdXRvY2xvc2U6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICBUZXh0IHNob3duIGFzIGNsZWFyIGRhdGUgYnV0dG9uLiBcbiAgICAgICAgSWYgPGNvZGU+ZmFsc2U8L2NvZGU+IGNsZWFyIGJ1dHRvbiB3aWxsIG5vdCBiZSByZW5kZXJlZC5cblxuICAgICAgICBAcHJvcGVydHkgY2xlYXIgXG4gICAgICAgIEB0eXBlIGJvb2xlYW58c3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICd4IGNsZWFyJ1xuICAgICAgICAqKi9cbiAgICAgICAgY2xlYXI6ICcmdGltZXM7IGNsZWFyJ1xuICAgIH0pO1xuXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGV0aW1lID0gRGF0ZVRpbWU7XG5cbn0od2luZG93LmpRdWVyeSkpO1xuLyoqXG5Cb290c3RyYXAgZGF0ZXRpbWVmaWVsZCBpbnB1dCAtIGRhdGV0aW1lIGlucHV0IGZvciBpbmxpbmUgbW9kZS5cblNob3dzIG5vcm1hbCA8aW5wdXQgdHlwZT1cInRleHRcIj4gYW5kIGJpbmRzIHBvcHVwIGRhdGV0aW1lcGlja2VyLiAgXG5BdXRvbWF0aWNhbGx5IHNob3duIGluIGlubGluZSBtb2RlLlxuXG5AY2xhc3MgZGF0ZXRpbWVmaWVsZFxuQGV4dGVuZHMgZGF0ZXRpbWVcblxuKiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBcbiAgICB2YXIgRGF0ZVRpbWVGaWVsZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdCgnZGF0ZXRpbWVmaWVsZCcsIG9wdGlvbnMsIERhdGVUaW1lRmllbGQuZGVmYXVsdHMpO1xuICAgICAgICB0aGlzLmluaXRQaWNrZXIob3B0aW9ucywgRGF0ZVRpbWVGaWVsZC5kZWZhdWx0cyk7XG4gICAgfTtcblxuICAgICQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KERhdGVUaW1lRmllbGQsICQuZm4uZWRpdGFibGV0eXBlcy5kYXRldGltZSk7XG4gICAgXG4gICAgJC5leHRlbmQoRGF0ZVRpbWVGaWVsZC5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dCA9IHRoaXMuJHRwbC5maW5kKCdpbnB1dCcpO1xuICAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdwbGFjZWhvbGRlcicpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiR0cGwuZGF0ZXRpbWVwaWNrZXIodGhpcy5vcHRpb25zLmRhdGV0aW1lcGlja2VyKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9uZWVkIHRvIGRpc2FibGUgb3JpZ2luYWwgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgICAgIHRoaXMuJGlucHV0Lm9mZignZm9jdXMga2V5ZG93bicpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3VwZGF0ZSB2YWx1ZSBvZiBkYXRlcGlja2VyXG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5rZXl1cCgkLnByb3h5KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICB0aGlzLiR0cGwucmVtb3ZlRGF0YSgnZGF0ZScpO1xuICAgICAgICAgICAgICAgdGhpcy4kdHBsLmRhdGV0aW1lcGlja2VyKCd1cGRhdGUnKTtcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgIFxuICAgICAgICB9LCAgIFxuICAgICAgXG4gICAgICAgdmFsdWUyaW5wdXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgIHRoaXMuJGlucHV0LnZhbCh0aGlzLnZhbHVlMmh0bWwodmFsdWUpKTtcbiAgICAgICAgICAgdGhpcy4kdHBsLmRhdGV0aW1lcGlja2VyKCd1cGRhdGUnKTtcbiAgICAgICB9LFxuICAgICAgICBcbiAgICAgICBpbnB1dDJ2YWx1ZTogZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICByZXR1cm4gdGhpcy5odG1sMnZhbHVlKHRoaXMuJGlucHV0LnZhbCgpKTtcbiAgICAgICB9LCAgICAgICAgICAgICAgXG4gICAgICAgIFxuICAgICAgIGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQucHJvdG90eXBlLmFjdGl2YXRlLmNhbGwodGhpcyk7XG4gICAgICAgfSxcbiAgICAgICBcbiAgICAgICBhdXRvc3VibWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgIC8vcmVzZXQgYXV0b3N1Ym1pdCB0byBlbXB0eSAgXG4gICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIERhdGVUaW1lRmllbGQuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGV0aW1lLmRlZmF1bHRzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgdHBsIFxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgdHBsOic8ZGl2IGNsYXNzPVwiaW5wdXQtYXBwZW5kIGRhdGVcIj48aW5wdXQgdHlwZT1cInRleHRcIi8+PHNwYW4gY2xhc3M9XCJhZGQtb25cIj48aSBjbGFzcz1cImljb24tdGhcIj48L2k+PC9zcGFuPjwvZGl2PicsXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgaW5wdXRjbGFzcyBcbiAgICAgICAgQGRlZmF1bHQgJ2lucHV0LW1lZGl1bSdcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGlucHV0Y2xhc3M6ICdpbnB1dC1tZWRpdW0nLFxuICAgICAgICBcbiAgICAgICAgLyogZGF0ZXRpbWVwaWNrZXIgY29uZmlnICovXG4gICAgICAgIGRhdGV0aW1lcGlja2VyOntcbiAgICAgICAgICAgIHRvZGF5SGlnaGxpZ2h0OiBmYWxzZSxcbiAgICAgICAgICAgIGF1dG9jbG9zZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGV0aW1lZmllbGQgPSBEYXRlVGltZUZpZWxkO1xuXG59KHdpbmRvdy5qUXVlcnkpKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./Modules/Translation/node_modules/x-editable/dist/bootstrap3-editable/js/bootstrap-editable.js\n");

/***/ }),

/***/ "./Modules/Translation/Resources/assets/admin/js/TranslationEditor.js":
/*!****************************************************************************!*\
  !*** ./Modules/Translation/Resources/assets/admin/js/TranslationEditor.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _default)\n/* harmony export */ });\n/* harmony import */ var _node_modules_x_editable_dist_bootstrap3_editable_js_bootstrap_editable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../node_modules/x-editable/dist/bootstrap3-editable/js/bootstrap-editable */ \"./Modules/Translation/node_modules/x-editable/dist/bootstrap3-editable/js/bootstrap-editable.js\");\n/* harmony import */ var _node_modules_x_editable_dist_bootstrap3_editable_js_bootstrap_editable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_x_editable_dist_bootstrap3_editable_js_bootstrap_editable__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nvar _default = /*#__PURE__*/function () {\n  function _default() {\n    _classCallCheck(this, _default);\n    $('.translation').editable({\n      url: this.update,\n      type: 'text',\n      mode: 'inline',\n      send: 'always'\n    });\n  }\n  _createClass(_default, [{\n    key: \"update\",\n    value: function update(data) {\n      $.ajax({\n        url: route('admin.translations.update', this.dataset.key),\n        type: 'PUT',\n        data: {\n          locale: this.dataset.locale,\n          value: data.value\n        },\n        success: function (_success) {\n          function success(_x) {\n            return _success.apply(this, arguments);\n          }\n          success.toString = function () {\n            return _success.toString();\n          };\n          return success;\n        }(function (message) {\n          success(message);\n        }),\n        error: function (_error) {\n          function error(_x2) {\n            return _error.apply(this, arguments);\n          }\n          error.toString = function () {\n            return _error.toString();\n          };\n          return error;\n        }(function (xhr) {\n          error(xhr.responseJSON.message);\n        })\n      });\n    }\n  }]);\n  return _default;\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9Nb2R1bGVzL1RyYW5zbGF0aW9uL1Jlc291cmNlcy9hc3NldHMvYWRtaW4vanMvVHJhbnNsYXRpb25FZGl0b3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQTRGO0FBQUEsSUFBQUEsUUFBQTtFQUd4RixTQUFBQSxTQUFBLEVBQWM7SUFBQUMsZUFBQSxPQUFBRCxRQUFBO0lBQ1ZFLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQ0MsUUFBUSxDQUFDO01BQ3ZCQyxHQUFHLEVBQUUsSUFBSSxDQUFDQyxNQUFNO01BQ2hCQyxJQUFJLEVBQUUsTUFBTTtNQUNaQyxJQUFJLEVBQUUsUUFBUTtNQUNkQyxJQUFJLEVBQUU7SUFDVixDQUFDLENBQUM7RUFDTjtFQUFDQyxZQUFBLENBQUFULFFBQUE7SUFBQVUsR0FBQTtJQUFBQyxLQUFBLEVBRUQsU0FBQU4sT0FBT08sSUFBSSxFQUFFO01BQ1RWLENBQUMsQ0FBQ1csSUFBSSxDQUFDO1FBQ0hULEdBQUcsRUFBRVUsS0FBSyxDQUFDLDJCQUEyQixFQUFFLElBQUksQ0FBQ0MsT0FBTyxDQUFDTCxHQUFHLENBQUM7UUFDekRKLElBQUksRUFBRSxLQUFLO1FBQ1hNLElBQUksRUFBRTtVQUNGSSxNQUFNLEVBQUUsSUFBSSxDQUFDRCxPQUFPLENBQUNDLE1BQU07VUFDM0JMLEtBQUssRUFBRUMsSUFBSSxDQUFDRDtRQUNoQixDQUFDO1FBQ0RNLE9BQU8sWUFBQUMsUUFBQTtVQUFBLFNBQUFELFFBQUFFLEVBQUE7WUFBQSxPQUFBRCxRQUFBLENBQUFFLEtBQUEsT0FBQUMsU0FBQTtVQUFBO1VBQUFKLE9BQUEsQ0FBQUssUUFBQTtZQUFBLE9BQUFKLFFBQUEsQ0FBQUksUUFBQTtVQUFBO1VBQUEsT0FBQUwsT0FBQTtRQUFBLFlBQUNNLE9BQU8sRUFBRTtVQUNiTixPQUFPLENBQUNNLE9BQU8sQ0FBQztRQUNwQixDQUFDO1FBQ0RDLEtBQUssWUFBQUMsTUFBQTtVQUFBLFNBQUFELE1BQUFFLEdBQUE7WUFBQSxPQUFBRCxNQUFBLENBQUFMLEtBQUEsT0FBQUMsU0FBQTtVQUFBO1VBQUFHLEtBQUEsQ0FBQUYsUUFBQTtZQUFBLE9BQUFHLE1BQUEsQ0FBQUgsUUFBQTtVQUFBO1VBQUEsT0FBQUUsS0FBQTtRQUFBLFlBQUNHLEdBQUcsRUFBRTtVQUNQSCxLQUFLLENBQUNHLEdBQUcsQ0FBQ0MsWUFBWSxDQUFDTCxPQUFPLENBQUM7UUFDbkMsQ0FBQztNQUNMLENBQUMsQ0FBQztJQUNOO0VBQUM7RUFBQSxPQUFBdkIsUUFBQTtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZvbWFydC8uL01vZHVsZXMvVHJhbnNsYXRpb24vUmVzb3VyY2VzL2Fzc2V0cy9hZG1pbi9qcy9UcmFuc2xhdGlvbkVkaXRvci5qcz81YzhhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3gtZWRpdGFibGUvZGlzdC9ib290c3RyYXAzLWVkaXRhYmxlL2pzL2Jvb3RzdHJhcC1lZGl0YWJsZSc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAkKCcudHJhbnNsYXRpb24nKS5lZGl0YWJsZSh7XHJcbiAgICAgICAgICAgIHVybDogdGhpcy51cGRhdGUsXHJcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcclxuICAgICAgICAgICAgbW9kZTogJ2lubGluZScsXHJcbiAgICAgICAgICAgIHNlbmQ6ICdhbHdheXMnLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZShkYXRhKSB7XHJcbiAgICAgICAgJC5hamF4KHtcclxuICAgICAgICAgICAgdXJsOiByb3V0ZSgnYWRtaW4udHJhbnNsYXRpb25zLnVwZGF0ZScsIHRoaXMuZGF0YXNldC5rZXkpLFxyXG4gICAgICAgICAgICB0eXBlOiAnUFVUJyxcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmRhdGFzZXQubG9jYWxlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGRhdGEudmFsdWUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN1Y2Nlc3MobWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgc3VjY2VzcyhtZXNzYWdlKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXJyb3IoeGhyKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcih4aHIucmVzcG9uc2VKU09OLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJfZGVmYXVsdCIsIl9jbGFzc0NhbGxDaGVjayIsIiQiLCJlZGl0YWJsZSIsInVybCIsInVwZGF0ZSIsInR5cGUiLCJtb2RlIiwic2VuZCIsIl9jcmVhdGVDbGFzcyIsImtleSIsInZhbHVlIiwiZGF0YSIsImFqYXgiLCJyb3V0ZSIsImRhdGFzZXQiLCJsb2NhbGUiLCJzdWNjZXNzIiwiX3N1Y2Nlc3MiLCJfeCIsImFwcGx5IiwiYXJndW1lbnRzIiwidG9TdHJpbmciLCJtZXNzYWdlIiwiZXJyb3IiLCJfZXJyb3IiLCJfeDIiLCJ4aHIiLCJyZXNwb25zZUpTT04iLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./Modules/Translation/Resources/assets/admin/js/TranslationEditor.js\n");

/***/ }),

/***/ "./Modules/Translation/Resources/assets/admin/js/main.js":
/*!***************************************************************!*\
  !*** ./Modules/Translation/Resources/assets/admin/js/main.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _TranslationEditor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TranslationEditor */ \"./Modules/Translation/Resources/assets/admin/js/TranslationEditor.js\");\n\n$('.translations-table').dataTable({\n  pageLength: 20,\n  lengthMenu: [10, 20, 50, 100, 200],\n  drawCallback: function drawCallback() {\n    new _TranslationEditor__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9Nb2R1bGVzL1RyYW5zbGF0aW9uL1Jlc291cmNlcy9hc3NldHMvYWRtaW4vanMvbWFpbi5qcyIsIm1hcHBpbmdzIjoiOztBQUFvRDtBQUVwREMsQ0FBQyxDQUFDLHFCQUFxQixDQUFDLENBQUNDLFNBQVMsQ0FBQztFQUMvQkMsVUFBVSxFQUFFLEVBQUU7RUFDZEMsVUFBVSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQztFQUNsQ0MsWUFBWSxFQUFFLFNBQUFBLGFBQUEsRUFBTTtJQUNoQixJQUFJTCwwREFBaUIsRUFBRTtFQUMzQjtBQUNKLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2b21hcnQvLi9Nb2R1bGVzL1RyYW5zbGF0aW9uL1Jlc291cmNlcy9hc3NldHMvYWRtaW4vanMvbWFpbi5qcz9kOTI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBUcmFuc2xhdGlvbkVkaXRvciBmcm9tICcuL1RyYW5zbGF0aW9uRWRpdG9yJztcclxuXHJcbiQoJy50cmFuc2xhdGlvbnMtdGFibGUnKS5kYXRhVGFibGUoe1xyXG4gICAgcGFnZUxlbmd0aDogMjAsXHJcbiAgICBsZW5ndGhNZW51OiBbMTAsIDIwLCA1MCwgMTAwLCAyMDBdLFxyXG4gICAgZHJhd0NhbGxiYWNrOiAoKSA9PiB7XHJcbiAgICAgICAgbmV3IFRyYW5zbGF0aW9uRWRpdG9yKCk7XHJcbiAgICB9LFxyXG59KTtcclxuXHJcbiJdLCJuYW1lcyI6WyJUcmFuc2xhdGlvbkVkaXRvciIsIiQiLCJkYXRhVGFibGUiLCJwYWdlTGVuZ3RoIiwibGVuZ3RoTWVudSIsImRyYXdDYWxsYmFjayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./Modules/Translation/Resources/assets/admin/js/main.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./Modules/Translation/Resources/assets/admin/js/main.js");
/******/ 	
/******/ })()
;